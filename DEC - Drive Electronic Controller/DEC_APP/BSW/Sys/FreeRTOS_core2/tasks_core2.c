/*
 * FreeRTOS_core2 Kernel V10.5.1
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS_core2.org
 * https://github.com/FreeRTOS_core2
 *
 */

/* Standard includes. */
#include <stdlib.h>
#include <string.h>

/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE_core2 prevents task_core2.h from redefining
 * all the API functions to use the MPU wrappers.  That should only be done when
 * task_core2.h is included from an application file. */
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE_core2

/* FreeRTOS_core2 includes. */
#include "FreeRTOS_core2.h"
#include "task_core2.h"
#include "timers_core2.h"
#include "stack_macros_core2.h"

/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE_core2 to be defined
 * for the header files above, but not in this file, in order to generate the
 * correct privileged Vs unprivileged linkage and placement. */
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE_core2 /*lint !e961 !e750 !e9021. */

/* Set configUSE_STATS_FORMATTING_FUNCTIONS_core2 to 2 to include the stats formatting
 * functions but without including stdio.h here. */
#if ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 == 1 )

/* At the bottom of this file are two optional functions that can be used
 * to generate human readable text from the raw data generated by the
 * uxTaskGetSystemState_core2() function.  Note the formatting functions are provided
 * for convenience only, and are NOT considered part of the kernel. */
    #include <stdio.h>
#endif /* configUSE_STATS_FORMATTING_FUNCTIONS_core2 == 1 ) */

#if ( configUSE_PREEMPTION_core2 == 0 )

/* If the cooperative scheduler is being used then a yield should not be
 * performed just because a higher priority task_core2 has been woken. */
    #define taskYIELD_IF_USING_PREEMPTION_core2()
#else
    #define taskYIELD_IF_USING_PREEMPTION_core2()    portYIELD_WITHIN_API_core2()
#endif

/* Values that can be assigned to the ucNotifyState_core2 member of the TCB. */
#define taskNOT_WAITING_NOTIFICATION_core2              ( ( uint8_t ) 0 ) /* Must be zero as it is the initialised value. */
#define taskWAITING_NOTIFICATION_core2                  ( ( uint8_t ) 1 )
#define taskNOTIFICATION_RECEIVED_core2                 ( ( uint8_t ) 2 )

/*
 * The value used to fill the stack of a task_core2 when the task_core2 is created.  This
 * is used purely for checking the high water mark for tasks.
 */
#define tskSTACK_FILL_BYTE_core2                        ( 0xa5U )

/* Bits used to record how a task_core2's stack and TCB were allocated. */
#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB_core2    ( ( uint8_t ) 0 )
#define tskSTATICALLY_ALLOCATED_STACK_ONLY_core2        ( ( uint8_t ) 1 )
#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB_core2     ( ( uint8_t ) 2 )

/* If any of the following are set then task_core2 stacks are filled with a known
 * value so the high water mark can be determined.  If none of the following are
 * set then don't fill the stack so there is no unnecessary dependency on memset. */
#if ( ( configCHECK_FOR_STACK_OVERFLOW_core2 > 1 ) || ( configUSE_TRACE_FACILITY_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2_core2 == 1 ) )
    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE_core2    1
#else
    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE_core2    0
#endif

/*
 * Macros used by vListTask to indicate which state a task_core2 is in.
 */
#define tskRUNNING_CHAR_core2      ( 'X' )
#define tskBLOCKED_CHAR_core2      ( 'B' )
#define tskREADY_CHAR_core2        ( 'R' )
#define tskDELETED_CHAR_core2      ( 'D' )
#define tskSUSPENDED_CHAR_core2    ( 'S' )

/*
 * Some kernel aware debuggers require the data the debugger needs access to to
 * be global, rather than file scope.
 */
#ifdef portREMOVE_STATIC_QUALIFIER_core2
    #define static
#endif

/* The name allocated to the Idle task_core2.  This can be overridden by defining
 * configIDLE_TASK_NAME_core2 in FreeRTOSConfig.h. */
#ifndef configIDLE_TASK_NAME_core2
    #define configIDLE_TASK_NAME_core2    "IDLE_core2"
#endif

#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 == 0 )

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 is 0 then task_core2 selection is
 * performed in a generic way that is not optimised to any particular
 * microcontroller architecture. */

/* uxTopReadyPriority_core2 holds the priority of the highest priority ready
 * state task_core2. */
    #define taskRECORD_READY_PRIORITY_core2( uxPriority_core2 ) \
    {                                               \
        if( ( uxPriority_core2 ) > uxTopReadyPriority_core2 )   \
        {                                           \
            uxTopReadyPriority_core2 = ( uxPriority_core2 );    \
        }                                           \
    } /* taskRECORD_READY_PRIORITY_core2 */

/*-----------------------------------------------------------*/

    #define taskSELECT_HIGHEST_PRIORITY_TASK_core2()                                \
    {                                                                         \
        UBaseType_t_core2 uxTopPriority_core2 = uxTopReadyPriority_core2;                       \
                                                                              \
        /* Find the highest priority queue that contains ready tasks. */      \
        while( listLIST_IS_EMPTY_core2( &( pxReadyTasksLists_core2[ uxTopPriority_core2 ] ) ) ) \
        {                                                                     \
            configASSERT_core2( uxTopPriority_core2 );                                    \
            --uxTopPriority_core2;                                                  \
        }                                                                     \
                                                                              \
        /* listGET_OWNER_OF_NEXT_ENTRY_core2 indexes through the list, so the tasks of \
         * the  same priority get an equal share of the processor time. */                    \
        listGET_OWNER_OF_NEXT_ENTRY_core2( pxCurrentTCB_core2, &( pxReadyTasksLists_core2[ uxTopPriority_core2 ] ) ); \
        uxTopReadyPriority_core2 = uxTopPriority_core2;                                                   \
    } /* taskSELECT_HIGHEST_PRIORITY_TASK_core2 */

/*-----------------------------------------------------------*/

/* Define away taskRESET_READY_PRIORITY_core2() and portRESET_READY_PRIORITY_core2() as
 * they are only required when a port optimised method of task_core2 selection is
 * being used. */
    #define taskRESET_READY_PRIORITY_core2( uxPriority_core2 )
    #define portRESET_READY_PRIORITY_core2( uxPriority_core2, uxTopReadyPriority_core2 )

#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 */

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 is 1 then task_core2 selection is
 * performed in a way that is tailored to the particular microcontroller
 * architecture being used. */

/* A port optimised version is provided.  Call the port defined macros. */
    #define taskRECORD_READY_PRIORITY_core2( uxPriority_core2 )    portRECORD_READY_PRIORITY_core2( ( uxPriority_core2 ), uxTopReadyPriority_core2 )

/*-----------------------------------------------------------*/

    #define taskSELECT_HIGHEST_PRIORITY_TASK_core2()                                                  \
    {                                                                                           \
        UBaseType_t_core2 uxTopPriority_core2;                                                              \
                                                                                                \
        /* Find the highest priority list that contains ready tasks. */                         \
        portGET_HIGHEST_PRIORITY_core2( uxTopPriority_core2, uxTopReadyPriority_core2 );                          \
        configASSERT_core2( listCURRENT_LIST_LENGTH_core2( &( pxReadyTasksLists_core2[ uxTopPriority_core2 ] ) ) > 0 ); \
        listGET_OWNER_OF_NEXT_ENTRY_core2( pxCurrentTCB_core2, &( pxReadyTasksLists_core2[ uxTopPriority_core2 ] ) );   \
    } /* taskSELECT_HIGHEST_PRIORITY_TASK_core2() */

/*-----------------------------------------------------------*/

/* A port optimised version is provided, call it only if the TCB being reset
 * is being referenced from a ready list.  If it is referenced from a delayed
 * or suspended list then it won't be in a ready list. */
    #define taskRESET_READY_PRIORITY_core2( uxPriority_core2 )                                                     \
    {                                                                                                  \
        if( listCURRENT_LIST_LENGTH_core2( &( pxReadyTasksLists_core2[ ( uxPriority_core2 ) ] ) ) == ( UBaseType_t_core2 ) 0 ) \
        {                                                                                              \
            portRESET_READY_PRIORITY_core2( ( uxPriority_core2 ), ( uxTopReadyPriority_core2 ) );                        \
        }                                                                                              \
    }

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 */

/*-----------------------------------------------------------*/

/* pxDelayedTaskList_core2 and pxOverflowDelayedTaskList_core2 are switched when the tick
 * count overflows. */
#define taskSWITCH_DELAYED_LISTS_core2()                                                \
    {                                                                             \
        List_t_core2 * pxTemp_core2;                                                          \
                                                                                  \
        /* The delayed tasks list should be empty when the lists are switched. */ \
        configASSERT_core2( ( listLIST_IS_EMPTY_core2( pxDelayedTaskList_core2 ) ) );               \
                                                                                  \
        pxTemp_core2 = pxDelayedTaskList_core2;                                               \
        pxDelayedTaskList_core2 = pxOverflowDelayedTaskList_core2;                            \
        pxOverflowDelayedTaskList_core2 = pxTemp_core2;                                       \
        xNumOfOverflows_core2++;                                                        \
        prvResetNextTaskUnblockTime_core2();                                            \
    }

/*-----------------------------------------------------------*/

/*
 * Place the task_core2 represented by pxTCB_core2 into the appropriate ready list for
 * the task_core2.  It is inserted at the end of the list.
 */
#define prvAddTaskToReadyList_core2( pxTCB_core2 )                                                                 \
    traceMOVED_TASK_TO_READY_STATE_core2( pxTCB_core2 );                                                           \
    taskRECORD_READY_PRIORITY_core2( ( pxTCB_core2 )->uxPriority_core2 );                                                \
    listINSERT_END_core2( &( pxReadyTasksLists_core2[ ( pxTCB_core2 )->uxPriority_core2 ] ), &( ( pxTCB_core2 )->xStateListItem_core2 ) ); \
    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB_core2 )
/*-----------------------------------------------------------*/

/*
 * Several functions take a TaskHandle_t_core2 parameter that can optionally be NULL,
 * where NULL is used to indicate that the handle of the currently executing
 * task_core2 should be used in place of the parameter.  This macro simply checks to
 * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 */
#define prvGetTCBFromHandle_core2( pxHandle_core2 )    ( ( ( pxHandle_core2 ) == NULL ) ? pxCurrentTCB_core2 : ( pxHandle_core2 ) )

/* The item value of the event list item is normally used to hold the priority
 * of the task_core2 to which it belongs (coded to allow it to be held in reverse
 * priority order).  However, it is occasionally borrowed for other purposes.  It
 * is important its value is not updated due to a task_core2 priority change while it is
 * being used for another purpose.  The following bit definition is used to inform
 * the scheduler that the value should not be changed - in which case it is the
 * responsibility of whichever module is using the value to ensure it gets set back
 * to its original value when it is released. */
#if ( configUSE_16_BIT_TICKS_core2 == 1 )
    #define taskEVENT_LIST_ITEM_VALUE_IN_USE_core2    0x8000U
#else
    #define taskEVENT_LIST_ITEM_VALUE_IN_USE_core2    0x80000000UL
#endif

/*
 * Task control block.  A task_core2 control block (TCB) is allocated for each task_core2,
 * and stores task_core2 state information, including a pointer to the task_core2's context
 * (the task_core2's run time environment, including register values)
 */
typedef struct tskTaskControlBlock_core2       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
{
    volatile StackType_t_core2 * pxTopOfStack_core2; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */

    #if ( portUSING_MPU_WRAPPERS_core2 == 1 )
        xMPU_SETTINGS_core2 xMPUSettings_core2; /*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    #endif

    ListItem_t_core2 xStateListItem_core2;                  /*< The list that the state list item of a task_core2 is reference from denotes the state of that task_core2 (Ready, Blocked, Suspended ). */
    ListItem_t_core2 xEventListItem_core2;                  /*< Used to reference a task_core2 from an event list. */
    UBaseType_t_core2 uxPriority_core2;                     /*< The priority of the task_core2.  0 is the lowest priority. */
    StackType_t_core2 * pxStack_core2;                      /*< Points to the start of the stack. */
    char pcTaskName_core2[ configMAX_TASK_NAME_LEN_core2 ]; /*< Descriptive name given to the task_core2 when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

    #if ( ( portSTACK_GROWTH_core2 > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS_core2 == 1 ) )
        StackType_t_core2 * pxEndOfStack_core2; /*< Points to the highest valid address for the stack. */
    #endif

    #if ( portCRITICAL_NESTING_IN_TCB_core2 == 1 )
        UBaseType_t_core2 uxCriticalNesting_core2; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    #endif

    #if ( configUSE_TRACE_FACILITY_core2 == 1 )
        UBaseType_t_core2 uxTCBNumber_core2;  /*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task_core2 has been deleted and then recreated. */
        UBaseType_t_core2 uxTaskNumber_core2; /*< Stores a number specifically for use by third party trace code. */
    #endif

    #if ( configUSE_MUTEXES_core2 == 1 )
        UBaseType_t_core2 uxBasePriority_core2; /*< The priority last assigned to the task_core2 - used by the priority inheritance mechanism. */
        UBaseType_t_core2 uxMutexesHeld_core2;
    #endif

    #if ( configUSE_APPLICATION_TASK_TAG_core2 == 1 )
        TaskHookFunction_t_core2 pxTaskTag_core2;
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 > 0 )
        void * pvThreadLocalStoragePointers_core2[ configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 ];
    #endif

    #if ( configGENERATE_RUN_TIME_STATS_core2 == 1 )
        configRUN_TIME_COUNTER_TYPE_core2 ulRunTimeCounter_core2; /*< Stores the amount of time the task_core2 has spent in the Running state. */
    #endif

    #if ( ( configUSE_NEWLIB_REENTRANT_core2 == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT_core2 == 1 ) )
        configTLS_BLOCK_TYPE_core2 xTLSBlock_core2; /*< Memory block used as Thread Local Storage (TLS) Block for the task_core2. */
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )
        volatile uint32_t ulNotifiedValue_core2[ configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 ];
        volatile uint8_t ucNotifyState_core2[ configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 ];
    #endif

    /* See the comments in FreeRTOS_core2.h with the definition of
     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2. */
    #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
        uint8_t ucStaticallyAllocated_core2;                     /*< Set to pdTRUE_core2 if the task_core2 is a statically allocated to ensure no attempt is made to free the memory. */
    #endif

    #if ( INCLUDE_xTaskAbortDelay_core2 == 1 )
        uint8_t ucDelayAborted_core2;
    #endif

    #if ( configUSE_POSIX_ERRNO_core2 == 1 )
        int iTaskErrno_core2;
    #endif
} tskTCB_core2;

/* The old tskTCB_core2 name is maintained above then typedefed to the new TCB_t_core2 name
 * below to enable the use of older kernel aware debuggers. */
typedef tskTCB_core2 TCB_t_core2;

/*lint -save -e956 A manual analysis and inspection has been used to determine
 * which static variables must be declared volatile. */
portDONT_DISCARD_core2 PRIVILEGED_DATA_core2 TCB_t_core2 * volatile pxCurrentTCB_core2 = NULL;

/* Lists for ready and blocked tasks. --------------------
 * xDelayedTaskList1_core2 and xDelayedTaskList2_core2 could be moved to function scope but
 * doing so breaks some kernel aware debuggers and debuggers that rely on removing
 * the static qualifier. */
PRIVILEGED_DATA_core2 static List_t_core2 pxReadyTasksLists_core2[ configMAX_PRIORITIES_core2 ]; /*< Prioritised ready tasks. */
PRIVILEGED_DATA_core2 static List_t_core2 xDelayedTaskList1_core2;                         /*< Delayed tasks. */
PRIVILEGED_DATA_core2 static List_t_core2 xDelayedTaskList2_core2;                         /*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
PRIVILEGED_DATA_core2 static List_t_core2 * volatile pxDelayedTaskList_core2;              /*< Points to the delayed task_core2 list currently being used. */
PRIVILEGED_DATA_core2 static List_t_core2 * volatile pxOverflowDelayedTaskList_core2;      /*< Points to the delayed task_core2 list currently being used to hold tasks that have overflowed the current tick count. */
PRIVILEGED_DATA_core2 static List_t_core2 xPendingReadyList_core2;                         /*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */

#if ( INCLUDE_vTaskDelete_core2 == 1 )

    PRIVILEGED_DATA_core2 static List_t_core2 xTasksWaitingTermination_core2; /*< Tasks that have been deleted - but their memory not yet freed. */
    PRIVILEGED_DATA_core2 static volatile UBaseType_t_core2 uxDeletedTasksWaitingCleanUp_core2 = ( UBaseType_t_core2 ) 0U;

#endif

#if ( INCLUDE_vTaskSuspend_core2 == 1 )

    PRIVILEGED_DATA_core2 static List_t_core2 xSuspendedTaskList_core2; /*< Tasks that are currently suspended. */

#endif

/* Global POSIX errno. Its value is changed upon context switching to match
 * the errno of the currently running task_core2. */
#if ( configUSE_POSIX_ERRNO_core2 == 1 )
    int FreeRTOS_errno_core2 = 0;
#endif

/* Other file private variables. --------------------------------*/
PRIVILEGED_DATA_core2 static volatile UBaseType_t_core2 uxCurrentNumberOfTasks_core2 = ( UBaseType_t_core2 ) 0U;
PRIVILEGED_DATA_core2 static volatile TickType_t_core2 xTickCount_core2 = ( TickType_t_core2 ) configINITIAL_TICK_COUNT_core2;
PRIVILEGED_DATA_core2 static volatile UBaseType_t_core2 uxTopReadyPriority_core2 = tskIDLE_PRIORITY_core2;
PRIVILEGED_DATA_core2 static volatile BaseType_t_core2 xSchedulerRunning_core2 = pdFALSE_core2;
PRIVILEGED_DATA_core2 static volatile TickType_t_core2 xPendedTicks_core2 = ( TickType_t_core2 ) 0U;
PRIVILEGED_DATA_core2 static volatile BaseType_t_core2 xYieldPending_core2 = pdFALSE_core2;
PRIVILEGED_DATA_core2 static volatile BaseType_t_core2 xNumOfOverflows_core2 = ( BaseType_t_core2 ) 0;
PRIVILEGED_DATA_core2 static UBaseType_t_core2 uxTaskNumber_core2 = ( UBaseType_t_core2 ) 0U;
PRIVILEGED_DATA_core2 static volatile TickType_t_core2 xNextTaskUnblockTime_core2 = ( TickType_t_core2 ) 0U; /* Initialised to portMAX_DELAY_core2 before the scheduler starts. */
PRIVILEGED_DATA_core2 static TaskHandle_t_core2 xIdleTaskHandle_core2 = NULL;                          /*< Holds the handle of the idle task_core2.  The idle task_core2 is created automatically when the scheduler is started. */

/* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
 * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority_core2
 * to determine the number of priority lists to read back from the remote target. */
const volatile UBaseType_t_core2 uxTopUsedPriority_core2 = configMAX_PRIORITIES_core2 - 1U;

/* Context switches are held pending while the scheduler is suspended.  Also,
 * interrupts must not manipulate the xStateListItem_core2 of a TCB, or any of the
 * lists the xStateListItem_core2 can be referenced from, if the scheduler is suspended.
 * If an interrupt needs to unblock a task_core2 while the scheduler is suspended then it
 * moves the task_core2's event list item into the xPendingReadyList_core2, ready for the
 * kernel to move the task_core2 from the pending ready list into the real ready list
 * when the scheduler is unsuspended.  The pending ready list itself can only be
 * accessed from a critical section. */
PRIVILEGED_DATA_core2 static volatile UBaseType_t_core2 uxSchedulerSuspended_core2 = ( UBaseType_t_core2 ) pdFALSE_core2;

#if ( configGENERATE_RUN_TIME_STATS_core2 == 1 )

/* Do not move these variables to function scope as doing so prevents the
 * code working with debuggers that need to remove the static qualifier. */
    PRIVILEGED_DATA_core2 static configRUN_TIME_COUNTER_TYPE_core2 ulTaskSwitchedInTime_core2 = 0UL;    /*< Holds the value of a timer/counter the last time a task_core2 was switched in. */
    PRIVILEGED_DATA_core2 static volatile configRUN_TIME_COUNTER_TYPE_core2 ulTotalRunTime_core2 = 0UL; /*< Holds the total amount of execution time as defined by the run time counter clock. */

#endif

/*lint -restore */

/*-----------------------------------------------------------*/

/* File private functions. --------------------------------*/

/**
 * Utility task_core2 that simply returns pdTRUE_core2 if the task_core2 referenced by xTask_core2 is
 * currently in the Suspended state, or pdFALSE_core2 if the task_core2 referenced by xTask_core2
 * is in any other state.
 */
#if ( INCLUDE_vTaskSuspend_core2 == 1 )

    static BaseType_t_core2 prvTaskIsTaskSuspended_core2( const TaskHandle_t_core2 xTask_core2 ) PRIVILEGED_FUNCTION_core2;

#endif /* INCLUDE_vTaskSuspend_core2 */

/*
 * Utility to ready all the lists used by the scheduler.  This is called
 * automatically upon the creation of the first task_core2.
 */
static void prvInitialiseTaskLists_core2( void ) PRIVILEGED_FUNCTION_core2;

/*
 * The idle task_core2, which as all tasks is implemented as a never ending loop.
 * The idle task_core2 is automatically created and added to the ready lists upon
 * creation of the first user task_core2.
 *
 * The portTASK_FUNCTION_PROTO_core2() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask_core2( void *pvParameters_core2 );
 *
 */
static portTASK_FUNCTION_PROTO_core2( prvIdleTask_core2, pvParameters_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Utility to free all memory allocated by the scheduler to hold a TCB,
 * including the stack pointed to by the TCB.
 *
 * This does not free memory allocated by the task_core2 itself (i.e. memory
 * allocated by calls to pvPortMalloc_core2 from within the tasks application code).
 */
#if ( INCLUDE_vTaskDelete_core2 == 1 )

    static void prvDeleteTCB_core2( TCB_t_core2 * pxTCB_core2 ) PRIVILEGED_FUNCTION_core2;

#endif

/*
 * Used only by the idle task_core2.  This checks to see if anything has been placed
 * in the list of tasks waiting to be deleted.  If so the task_core2 is cleaned up
 * and its TCB deleted.
 */
static void prvCheckTasksWaitingTermination_core2( void ) PRIVILEGED_FUNCTION_core2;

/*
 * The currently executing task_core2 is entering the Blocked state.  Add the task_core2 to
 * either the current or the overflow delayed task_core2 list.
 */
static void prvAddCurrentTaskToDelayedList_core2( TickType_t_core2 xTicksToWait_core2,
                                            const BaseType_t_core2 xCanBlockIndefinitely_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Fills an TaskStatus_t_core2 structure with information on each task_core2 that is
 * referenced from the pxList_core2 list (which may be a ready list, a delayed list,
 * a suspended list, etc.).
 *
 * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 * NORMAL APPLICATION CODE.
 */
#if ( configUSE_TRACE_FACILITY_core2 == 1 )

    static UBaseType_t_core2 prvListTasksWithinSingleList_core2( TaskStatus_t_core2 * pxTaskStatusArray_core2,
                                                     List_t_core2 * pxList_core2,
                                                     eTaskState_core2 eState_core2 ) PRIVILEGED_FUNCTION_core2;

#endif

/*
 * Searches pxList_core2 for a task_core2 with name pcNameToQuery_core2 - returning a handle to
 * the task_core2 if it is found, or NULL if the task_core2 is not found.
 */
#if ( INCLUDE_xTaskGetHandle_core2 == 1 )

    static TCB_t_core2 * prvSearchForNameWithinSingleList_core2( List_t_core2 * pxList_core2,
                                                     const char pcNameToQuery_core2[] ) PRIVILEGED_FUNCTION_core2;

#endif

/*
 * When a task_core2 is created, the stack of the task_core2 is filled with a known value.
 * This function determines the 'high water mark' of the task_core2 stack by
 * determining how much of the stack remains at the original preset value.
 */
#if ( ( configUSE_TRACE_FACILITY_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2_core2 == 1 ) )

    static configSTACK_DEPTH_TYPE_core2 prvTaskCheckFreeStackSpace_core2( const uint8_t * pucStackByte_core2 ) PRIVILEGED_FUNCTION_core2;

#endif

/*
 * Return the amount of time, in ticks, that will pass before the kernel will
 * next move a task_core2 from the Blocked state to the Running state.
 *
 * This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure portSUPPRESS_TICKS_AND_SLEEP_core2() can be called when user
 * defined low power mode implementations require configUSE_TICKLESS_IDLE_core2 to be
 * set to a value other than 1.
 */
#if ( configUSE_TICKLESS_IDLE_core2 != 0 )

    static TickType_t_core2 prvGetExpectedIdleTime_core2( void ) PRIVILEGED_FUNCTION_core2;

#endif

/*
 * Set xNextTaskUnblockTime_core2 to the time at which the next Blocked state task_core2
 * will exit the Blocked state.
 */
static void prvResetNextTaskUnblockTime_core2( void ) PRIVILEGED_FUNCTION_core2;

#if ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 )

/*
 * Helper function used to pad task_core2 names with spaces when printing out
 * human readable tables of task_core2 information.
 */
    static char * prvWriteNameToBuffer_core2( char * pcBuffer_core2,
                                        const char * pcTaskName_core2 ) PRIVILEGED_FUNCTION_core2;

#endif

/*
 * Called after a Task_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 */
static void prvInitialiseNewTask_core2( TaskFunction_t_core2 pxTaskCode_core2,
                                  const char * const pcName_core2, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                  const uint32_t ulStackDepth_core2,
                                  void * const pvParameters_core2,
                                  UBaseType_t_core2 uxPriority_core2,
                                  TaskHandle_t_core2 * const pxCreatedTask_core2,
                                  TCB_t_core2 * pxNewTCB_core2,
                                  const MemoryRegion_t_core2 * const xRegions_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Called after a new task_core2 has been created and initialised to place the task_core2
 * under the control of the scheduler.
 */
static void prvAddNewTaskToReadyList_core2( TCB_t_core2 * pxNewTCB_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * freertos_tasks_c_additions_init_core2() should only be called if the user definable
 * macro FREERTOS_TASKS_C_ADDITIONS_INIT_core2() is defined, as that is the only macro
 * called by the function.
 */
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT_core2

    static void freertos_tasks_c_additions_init_core2( void ) PRIVILEGED_FUNCTION_core2;

#endif

/*-----------------------------------------------------------*/

#if ( configSUPPORT_STATIC_ALLOCATION_core2 == 1 )

    TaskHandle_t_core2 xTaskCreateStatic_core2( TaskFunction_t_core2 pxTaskCode_core2,
                                    const char * const pcName_core2, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const uint32_t ulStackDepth_core2,
                                    void * const pvParameters_core2,
                                    UBaseType_t_core2 uxPriority_core2,
                                    StackType_t_core2 * const puxStackBuffer_core2,
                                    StaticTask_t_core2 * const pxTaskBuffer_core2 )
    {
        TCB_t_core2 * pxNewTCB_core2;
        TaskHandle_t_core2 xReturn_core2;

        configASSERT_core2( puxStackBuffer_core2 != NULL );
        configASSERT_core2( pxTaskBuffer_core2 != NULL );

        #if ( configASSERT_DEFINED_core2 == 1 )
        {
            /* Sanity check that the size of the structure used to declare a
             * variable of type StaticTask_t_core2 equals the size of the real task_core2
             * structure. */
            volatile size_t xSize_core2 = sizeof( StaticTask_t_core2 );
            configASSERT_core2( xSize_core2 == sizeof( TCB_t_core2 ) );
            ( void ) xSize_core2; /* Prevent lint warning when configASSERT_core2() is not used. */
        }
        #endif /* configASSERT_DEFINED_core2 */

        if( ( pxTaskBuffer_core2 != NULL ) && ( puxStackBuffer_core2 != NULL ) )
        {
            /* The memory used for the task_core2's TCB and stack are passed into this
             * function - use them. */
            pxNewTCB_core2 = ( TCB_t_core2 * ) pxTaskBuffer_core2; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
            memset( ( void * ) pxNewTCB_core2, 0x00, sizeof( TCB_t_core2 ) );
            pxNewTCB_core2->pxStack_core2 = ( StackType_t_core2 * ) puxStackBuffer_core2;

            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
            {
                /* Tasks can be created statically or dynamically, so note this
                 * task_core2 was created statically in case the task_core2 is later deleted. */
                pxNewTCB_core2->ucStaticallyAllocated_core2 = tskSTATICALLY_ALLOCATED_STACK_AND_TCB_core2;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 */

            prvInitialiseNewTask_core2( pxTaskCode_core2, pcName_core2, ulStackDepth_core2, pvParameters_core2, uxPriority_core2, &xReturn_core2, pxNewTCB_core2, NULL );
            prvAddNewTaskToReadyList_core2( pxNewTCB_core2 );
        }
        else
        {
            xReturn_core2 = NULL;
        }

        return xReturn_core2;
    }

#endif /* SUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

#if ( ( portUSING_MPU_WRAPPERS_core2 == 1 ) && ( configSUPPORT_STATIC_ALLOCATION_core2 == 1 ) )

    BaseType_t_core2 xTaskCreateRestrictedStatic_core2( const TaskParameters_t_core2 * const pxTaskDefinition_core2,
                                            TaskHandle_t_core2 * pxCreatedTask_core2 )
    {
        TCB_t_core2 * pxNewTCB_core2;
        BaseType_t_core2 xReturn_core2 = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY_core2;

        configASSERT_core2( pxTaskDefinition_core2->puxStackBuffer_core2 != NULL );
        configASSERT_core2( pxTaskDefinition_core2->pxTaskBuffer_core2 != NULL );

        if( ( pxTaskDefinition_core2->puxStackBuffer_core2 != NULL ) && ( pxTaskDefinition_core2->pxTaskBuffer_core2 != NULL ) )
        {
            /* Allocate space for the TCB.  Where the memory comes from depends
             * on the implementation of the port malloc function and whether or
             * not static allocation is being used. */
            pxNewTCB_core2 = ( TCB_t_core2 * ) pxTaskDefinition_core2->pxTaskBuffer_core2;
            memset( ( void * ) pxNewTCB_core2, 0x00, sizeof( TCB_t_core2 ) );

            /* Store the stack location in the TCB. */
            pxNewTCB_core2->pxStack_core2 = pxTaskDefinition_core2->puxStackBuffer_core2;

            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 != 0 )
            {
                /* Tasks can be created statically or dynamically, so note this
                 * task_core2 was created statically in case the task_core2 is later deleted. */
                pxNewTCB_core2->ucStaticallyAllocated_core2 = tskSTATICALLY_ALLOCATED_STACK_AND_TCB_core2;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 */

            prvInitialiseNewTask_core2( pxTaskDefinition_core2->pvTaskCode_core2,
                                  pxTaskDefinition_core2->pcName_core2,
                                  ( uint32_t ) pxTaskDefinition_core2->usStackDepth_core2,
                                  pxTaskDefinition_core2->pvParameters_core2,
                                  pxTaskDefinition_core2->uxPriority_core2,
                                  pxCreatedTask_core2, pxNewTCB_core2,
                                  pxTaskDefinition_core2->xRegions_core2 );

            prvAddNewTaskToReadyList_core2( pxNewTCB_core2 );
            xReturn_core2 = pdPASS_core2;
        }

        return xReturn_core2;
    }

#endif /* ( portUSING_MPU_WRAPPERS_core2 == 1 ) && ( configSUPPORT_STATIC_ALLOCATION_core2 == 1 ) */
/*-----------------------------------------------------------*/

#if ( ( portUSING_MPU_WRAPPERS_core2 == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION_core2 == 1 ) )

    BaseType_t_core2 xTaskCreateRestricted_core2( const TaskParameters_t_core2 * const pxTaskDefinition_core2,
                                      TaskHandle_t_core2 * pxCreatedTask_core2 )
    {
        TCB_t_core2 * pxNewTCB_core2;
        BaseType_t_core2 xReturn_core2 = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY_core2;

        configASSERT_core2( pxTaskDefinition_core2->puxStackBuffer_core2 );

        if( pxTaskDefinition_core2->puxStackBuffer_core2 != NULL )
        {
            /* Allocate space for the TCB.  Where the memory comes from depends
             * on the implementation of the port malloc function and whether or
             * not static allocation is being used. */
            pxNewTCB_core2 = ( TCB_t_core2 * ) pvPortMalloc_core2( sizeof( TCB_t_core2 ) );

            if( pxNewTCB_core2 != NULL )
            {
                memset( ( void * ) pxNewTCB_core2, 0x00, sizeof( TCB_t_core2 ) );

                /* Store the stack location in the TCB. */
                pxNewTCB_core2->pxStack_core2 = pxTaskDefinition_core2->puxStackBuffer_core2;

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 != 0 )
                {
                    /* Tasks can be created statically or dynamically, so note
                     * this task_core2 had a statically allocated stack in case it is
                     * later deleted.  The TCB was allocated dynamically. */
                    pxNewTCB_core2->ucStaticallyAllocated_core2 = tskSTATICALLY_ALLOCATED_STACK_ONLY_core2;
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 */

                prvInitialiseNewTask_core2( pxTaskDefinition_core2->pvTaskCode_core2,
                                      pxTaskDefinition_core2->pcName_core2,
                                      ( uint32_t ) pxTaskDefinition_core2->usStackDepth_core2,
                                      pxTaskDefinition_core2->pvParameters_core2,
                                      pxTaskDefinition_core2->uxPriority_core2,
                                      pxCreatedTask_core2, pxNewTCB_core2,
                                      pxTaskDefinition_core2->xRegions_core2 );

                prvAddNewTaskToReadyList_core2( pxNewTCB_core2 );
                xReturn_core2 = pdPASS_core2;
            }
        }

        return xReturn_core2;
    }

#endif /* portUSING_MPU_WRAPPERS_core2 */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION_core2 == 1 )

    BaseType_t_core2 xTaskCreate_core2( TaskFunction_t_core2 pxTaskCode_core2,
                            const char * const pcName_core2, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE_core2 usStackDepth_core2,
                            void * const pvParameters_core2,
                            UBaseType_t_core2 uxPriority_core2,
                            TaskHandle_t_core2 * const pxCreatedTask_core2 )
    {
        TCB_t_core2 * pxNewTCB_core2;
        BaseType_t_core2 xReturn_core2;

        /* If the stack grows down then allocate the stack then the TCB so the stack
         * does not grow into the TCB.  Likewise if the stack grows up then allocate
         * the TCB then the stack. */
        #if ( portSTACK_GROWTH_core2 > 0 )
        {
            /* Allocate space for the TCB.  Where the memory comes from depends on
             * the implementation of the port malloc function and whether or not static
             * allocation is being used. */
            pxNewTCB_core2 = ( TCB_t_core2 * ) pvPortMalloc_core2( sizeof( TCB_t_core2 ) );

            if( pxNewTCB_core2 != NULL )
            {
                memset( ( void * ) pxNewTCB_core2, 0x00, sizeof( TCB_t_core2 ) );

                /* Allocate space for the stack used by the task_core2 being created.
                 * The base of the stack memory stored in the TCB so the task_core2 can
                 * be deleted later if required. */
                pxNewTCB_core2->pxStack_core2 = ( StackType_t_core2 * ) pvPortMallocStack_core2( ( ( ( size_t ) usStackDepth_core2 ) * sizeof( StackType_t_core2 ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

                if( pxNewTCB_core2->pxStack_core2 == NULL )
                {
                    /* Could not allocate the stack.  Delete the allocated TCB. */
                    vPortFree_core2( pxNewTCB_core2 );
                    pxNewTCB_core2 = NULL;
                }
            }
        }
        #else /* portSTACK_GROWTH_core2 */
        {
            StackType_t_core2 * pxStack_core2;

            /* Allocate space for the stack used by the task_core2 being created. */
            pxStack_core2 = pvPortMallocStack_core2( ( ( ( size_t ) usStackDepth_core2 ) * sizeof( StackType_t_core2 ) ) ); /*lint !e9079 All values returned by pvPortMalloc_core2() have at least the alignment required by the MCU's stack and this allocation is the stack. */

            if( pxStack_core2 != NULL )
            {
                /* Allocate space for the TCB. */
                pxNewTCB_core2 = ( TCB_t_core2 * ) pvPortMalloc_core2( sizeof( TCB_t_core2 ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc_core2() have at least the alignment required by the MCU's stack, and the first member of TCB_t_core2 is always a pointer to the task_core2's stack. */

                if( pxNewTCB_core2 != NULL )
                {
                    memset( ( void * ) pxNewTCB_core2, 0x00, sizeof( TCB_t_core2 ) );

                    /* Store the stack location in the TCB. */
                    pxNewTCB_core2->pxStack_core2 = pxStack_core2;
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack_core2( pxStack_core2 );
                }
            }
            else
            {
                pxNewTCB_core2 = NULL;
            }
        }
        #endif /* portSTACK_GROWTH_core2 */

        if( pxNewTCB_core2 != NULL )
        {
            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
            {
                /* Tasks can be created statically or dynamically, so note this
                 * task_core2 was created dynamically in case it is later deleted. */
                pxNewTCB_core2->ucStaticallyAllocated_core2 = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB_core2;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 */

            prvInitialiseNewTask_core2( pxTaskCode_core2, pcName_core2, ( uint32_t ) usStackDepth_core2, pvParameters_core2, uxPriority_core2, pxCreatedTask_core2, pxNewTCB_core2, NULL );
            prvAddNewTaskToReadyList_core2( pxNewTCB_core2 );
            xReturn_core2 = pdPASS_core2;
        }
        else
        {
            xReturn_core2 = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY_core2;
        }

        return xReturn_core2;
    }

#endif /* configSUPPORT_DYNAMIC_ALLOCATION_core2 */
/*-----------------------------------------------------------*/

static void prvInitialiseNewTask_core2( TaskFunction_t_core2 pxTaskCode_core2,
                                  const char * const pcName_core2, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                  const uint32_t ulStackDepth_core2,
                                  void * const pvParameters_core2,
                                  UBaseType_t_core2 uxPriority_core2,
                                  TaskHandle_t_core2 * const pxCreatedTask_core2,
                                  TCB_t_core2 * pxNewTCB_core2,
                                  const MemoryRegion_t_core2 * const xRegions_core2 )
{
    StackType_t_core2 * pxTopOfStack_core2;
    UBaseType_t_core2 x;

    #if ( portUSING_MPU_WRAPPERS_core2 == 1 )
        /* Should the task_core2 be created in privileged mode? */
        BaseType_t_core2 xRunPrivileged_core2;

        if( ( uxPriority_core2 & portPRIVILEGE_BIT_core2 ) != 0U )
        {
            xRunPrivileged_core2 = pdTRUE_core2;
        }
        else
        {
            xRunPrivileged_core2 = pdFALSE_core2;
        }
        uxPriority_core2 &= ~portPRIVILEGE_BIT_core2;
    #endif /* portUSING_MPU_WRAPPERS_core2 == 1 */

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE_core2 == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB_core2->pxStack_core2, ( int ) tskSTACK_FILL_BYTE_core2, ( size_t ) ulStackDepth_core2 * sizeof( StackType_t_core2 ) );
    }
    #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE_core2 */

    /* Calculate the top of stack address.  This depends on whether the stack
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH_core2 is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH_core2 < 0 )
    {
        pxTopOfStack_core2 = &( pxNewTCB_core2->pxStack_core2[ ulStackDepth_core2 - ( uint32_t ) 1 ] );
        pxTopOfStack_core2 = ( StackType_t_core2 * ) ( ( ( portPOINTER_SIZE_TYPE_core2 ) pxTopOfStack_core2 ) & ( ~( ( portPOINTER_SIZE_TYPE_core2 ) portBYTE_ALIGNMENT_MASK_core2 ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE_core2 type.  Checked by assert(). */

        /* Check the alignment of the calculated top of stack is correct. */
        configASSERT_core2( ( ( ( portPOINTER_SIZE_TYPE_core2 ) pxTopOfStack_core2 & ( portPOINTER_SIZE_TYPE_core2 ) portBYTE_ALIGNMENT_MASK_core2 ) == 0UL ) );

        #if ( configRECORD_STACK_HIGH_ADDRESS_core2 == 1 )
        {
            /* Also record the stack's high address, which may assist
             * debugging. */
            pxNewTCB_core2->pxEndOfStack_core2 = pxTopOfStack_core2;
        }
        #endif /* configRECORD_STACK_HIGH_ADDRESS_core2 */
    }
    #else /* portSTACK_GROWTH_core2 */
    {
        pxTopOfStack_core2 = pxNewTCB_core2->pxStack_core2;

        /* Check the alignment of the stack buffer is correct. */
        configASSERT_core2( ( ( ( portPOINTER_SIZE_TYPE_core2 ) pxNewTCB_core2->pxStack_core2 & ( portPOINTER_SIZE_TYPE_core2 ) portBYTE_ALIGNMENT_MASK_core2 ) == 0UL ) );

        /* The other extreme of the stack space is required if stack checking is
         * performed. */
        pxNewTCB_core2->pxEndOfStack_core2 = pxNewTCB_core2->pxStack_core2 + ( ulStackDepth_core2 - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH_core2 */

    /* Store the task_core2 name in the TCB. */
    if( pcName_core2 != NULL )
    {
        for( x = ( UBaseType_t_core2 ) 0; x < ( UBaseType_t_core2 ) configMAX_TASK_NAME_LEN_core2; x++ )
        {
            pxNewTCB_core2->pcTaskName_core2[ x ] = pcName_core2[ x ];

            /* Don't copy all configMAX_TASK_NAME_LEN_core2 if the string is shorter than
             * configMAX_TASK_NAME_LEN_core2 characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName_core2[ x ] == ( char ) 0x00 )
            {
                break;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN_core2. */
        pxNewTCB_core2->pcTaskName_core2[ configMAX_TASK_NAME_LEN_core2 - 1 ] = '\0';
    }
    else
    {
        mtCOVERAGE_TEST_MARKER_core2();
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT_core2( uxPriority_core2 < configMAX_PRIORITIES_core2 );

    if( uxPriority_core2 >= ( UBaseType_t_core2 ) configMAX_PRIORITIES_core2 )
    {
        uxPriority_core2 = ( UBaseType_t_core2 ) configMAX_PRIORITIES_core2 - ( UBaseType_t_core2 ) 1U;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER_core2();
    }

    pxNewTCB_core2->uxPriority_core2 = uxPriority_core2;
    #if ( configUSE_MUTEXES_core2 == 1 )
    {
        pxNewTCB_core2->uxBasePriority_core2 = uxPriority_core2;
    }
    #endif /* configUSE_MUTEXES_core2 */

    vListInitialiseItem_core2( &( pxNewTCB_core2->xStateListItem_core2 ) );
    vListInitialiseItem_core2( &( pxNewTCB_core2->xEventListItem_core2 ) );

    /* Set the pxNewTCB_core2 as a link back from the ListItem_t_core2.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER_core2( &( pxNewTCB_core2->xStateListItem_core2 ), pxNewTCB_core2 );

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE_core2( &( pxNewTCB_core2->xEventListItem_core2 ), ( TickType_t_core2 ) configMAX_PRIORITIES_core2 - ( TickType_t_core2 ) uxPriority_core2 ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    listSET_LIST_ITEM_OWNER_core2( &( pxNewTCB_core2->xEventListItem_core2 ), pxNewTCB_core2 );

    #if ( portUSING_MPU_WRAPPERS_core2 == 1 )
    {
        vPortStoreTaskMPUSettings_core2( &( pxNewTCB_core2->xMPUSettings_core2 ), xRegions_core2, pxNewTCB_core2->pxStack_core2, ulStackDepth_core2 );
    }
    #else
    {
        /* Avoid compiler warning about unreferenced parameter. */
        ( void ) xRegions_core2;
    }
    #endif

    #if ( ( configUSE_NEWLIB_REENTRANT_core2 == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT_core2 == 1 ) )
    {
        /* Allocate and initialize memory for the task_core2's TLS Block. */
        configINIT_TLS_BLOCK_core2( pxNewTCB_core2->xTLSBlock_core2 );
    }
    #endif

    /* Initialize the TCB stack to look as if the task_core2 was already running,
     * but had been interrupted by the scheduler.  The return address is set
     * to the start of the task_core2 function. Once the stack has been initialised
     * the top of stack variable is updated. */
    #if ( portUSING_MPU_WRAPPERS_core2 == 1 )
    {
        /* If the port has capability to detect stack overflow,
         * pass the stack end address to the stack initialization
         * function as well. */
        #if ( portHAS_STACK_OVERFLOW_CHECKING_core2 == 1 )
        {
            #if ( portSTACK_GROWTH_core2 < 0 )
            {
                pxNewTCB_core2->pxTopOfStack_core2 = pxPortInitialiseStack_core2( pxTopOfStack_core2, pxNewTCB_core2->pxStack_core2, pxTaskCode_core2, pvParameters_core2, xRunPrivileged_core2 );
            }
            #else /* portSTACK_GROWTH_core2 */
            {
                pxNewTCB_core2->pxTopOfStack_core2 = pxPortInitialiseStack_core2( pxTopOfStack_core2, pxNewTCB_core2->pxEndOfStack_core2, pxTaskCode_core2, pvParameters_core2, xRunPrivileged_core2 );
            }
            #endif /* portSTACK_GROWTH_core2 */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING_core2 */
        {
            pxNewTCB_core2->pxTopOfStack_core2 = pxPortInitialiseStack_core2( pxTopOfStack_core2, pxTaskCode_core2, pvParameters_core2, xRunPrivileged_core2 );
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING_core2 */
    }
    #else /* portUSING_MPU_WRAPPERS_core2 */
    {
        /* If the port has capability to detect stack overflow,
         * pass the stack end address to the stack initialization
         * function as well. */
        #if ( portHAS_STACK_OVERFLOW_CHECKING_core2 == 1 )
        {
            #if ( portSTACK_GROWTH_core2 < 0 )
            {
                pxNewTCB_core2->pxTopOfStack_core2 = pxPortInitialiseStack_core2( pxTopOfStack_core2, pxNewTCB_core2->pxStack_core2, pxTaskCode_core2, pvParameters_core2 );
            }
            #else /* portSTACK_GROWTH_core2 */
            {
                pxNewTCB_core2->pxTopOfStack_core2 = pxPortInitialiseStack_core2( pxTopOfStack_core2, pxNewTCB_core2->pxEndOfStack_core2, pxTaskCode_core2, pvParameters_core2 );
            }
            #endif /* portSTACK_GROWTH_core2 */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING_core2 */
        {
            pxNewTCB_core2->pxTopOfStack_core2 = pxPortInitialiseStack_core2( pxTopOfStack_core2, pxTaskCode_core2, pvParameters_core2 );
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING_core2 */
    }
    #endif /* portUSING_MPU_WRAPPERS_core2 */

    if( pxCreatedTask_core2 != NULL )
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task_core2's priority, delete the created task_core2, etc.*/
        *pxCreatedTask_core2 = ( TaskHandle_t_core2 ) pxNewTCB_core2;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER_core2();
    }
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList_core2( TCB_t_core2 * pxNewTCB_core2 )
{
    /* Ensure interrupts don't access the task_core2 lists while the lists are being
     * updated. */
    taskENTER_CRITICAL_core2();
    {
        uxCurrentNumberOfTasks_core2++;

        if( pxCurrentTCB_core2 == NULL )
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task_core2. */
            pxCurrentTCB_core2 = pxNewTCB_core2;

            if( uxCurrentNumberOfTasks_core2 == ( UBaseType_t_core2 ) 1 )
            {
                /* This is the first task_core2 to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists_core2();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        else
        {
            /* If the scheduler is not already running, make this task_core2 the
             * current task_core2 if it is the highest priority task_core2 to be created
             * so far. */
            if( xSchedulerRunning_core2 == pdFALSE_core2 )
            {
                if( pxCurrentTCB_core2->uxPriority_core2 <= pxNewTCB_core2->uxPriority_core2 )
                {
                    pxCurrentTCB_core2 = pxNewTCB_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }

        uxTaskNumber_core2++;

        #if ( configUSE_TRACE_FACILITY_core2 == 1 )
        {
            /* Add a counter into the TCB for tracing only. */
            pxNewTCB_core2->uxTCBNumber_core2 = uxTaskNumber_core2;
        }
        #endif /* configUSE_TRACE_FACILITY_core2 */
        traceTASK_CREATE_core2( pxNewTCB_core2 );

        prvAddTaskToReadyList_core2( pxNewTCB_core2 );

        portSETUP_TCB_core2( pxNewTCB_core2 );
    }
    taskEXIT_CRITICAL_core2();

    if( xSchedulerRunning_core2 != pdFALSE_core2 )
    {
        /* If the created task_core2 is of a higher priority than the current task_core2
         * then it should run now. */
        if( pxCurrentTCB_core2->uxPriority_core2 < pxNewTCB_core2->uxPriority_core2 )
        {
            taskYIELD_IF_USING_PREEMPTION_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER_core2();
    }
}
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete_core2 == 1 )

    void vTaskDelete_core2( TaskHandle_t_core2 xTaskToDelete_core2 )
    {
        TCB_t_core2 * pxTCB_core2;

        taskENTER_CRITICAL_core2();
        {
            /* If null is passed in here then it is the calling task_core2 that is
             * being deleted. */
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTaskToDelete_core2 );

            /* Remove task_core2 from the ready/delayed list. */
            if( uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
            {
                taskRESET_READY_PRIORITY_core2( pxTCB_core2->uxPriority_core2 );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            /* Is the task_core2 waiting on an event also? */
            if( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) != NULL )
            {
                ( void ) uxListRemove_core2( &( pxTCB_core2->xEventListItem_core2 ) );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            /* Increment the uxTaskNumber_core2 also so kernel aware debuggers can
             * detect that the task_core2 lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK_core2() as in the Windows port that macro will
             * not return. */
            uxTaskNumber_core2++;

            if( pxTCB_core2 == pxCurrentTCB_core2 )
            {
                /* A task_core2 is deleting itself.  This cannot complete within the
                 * task_core2 itself, as a context switch to another task_core2 is required.
                 * Place the task_core2 in the termination list.  The idle task_core2 will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task_core2. */
                vListInsertEnd_core2( &xTasksWaitingTermination_core2, &( pxTCB_core2->xStateListItem_core2 ) );

                /* Increment the ucTasksDeleted variable so the idle task_core2 knows
                 * there is a task_core2 that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination_core2 list. */
                ++uxDeletedTasksWaitingCleanUp_core2;

                /* Call the delete hook before portPRE_TASK_DELETE_HOOK_core2() as
                 * portPRE_TASK_DELETE_HOOK_core2() does not return in the Win32 port. */
                traceTASK_DELETE_core2( pxTCB_core2 );

                /* The pre-delete hook is primarily for the Windows simulator,
                 * in which Windows specific clean up operations are performed,
                 * after which it is not possible to yield away from this task_core2 -
                 * hence xYieldPending_core2 is used to latch that a context switch is
                 * required. */
                portPRE_TASK_DELETE_HOOK_core2( pxTCB_core2, &xYieldPending_core2 );
            }
            else
            {
                --uxCurrentNumberOfTasks_core2;
                traceTASK_DELETE_core2( pxTCB_core2 );

                /* Reset the next expected unblock time in case it referred to
                 * the task_core2 that has just been deleted. */
                prvResetNextTaskUnblockTime_core2();
            }
        }
        taskEXIT_CRITICAL_core2();

        /* If the task_core2 is not deleting itself, call prvDeleteTCB_core2 from outside of
         * critical section. If a task_core2 deletes itself, prvDeleteTCB_core2 is called
         * from prvCheckTasksWaitingTermination_core2 which is called from Idle task_core2. */
        if( pxTCB_core2 != pxCurrentTCB_core2 )
        {
            prvDeleteTCB_core2( pxTCB_core2 );
        }

        /* Force a reschedule if it is the currently running task_core2 that has just
         * been deleted. */
        if( xSchedulerRunning_core2 != pdFALSE_core2 )
        {
            if( pxTCB_core2 == pxCurrentTCB_core2 )
            {
                configASSERT_core2( uxSchedulerSuspended_core2 == 0 );
                portYIELD_WITHIN_API_core2();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
    }

#endif /* INCLUDE_vTaskDelete_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskDelayUntil_core2 == 1 )

    BaseType_t_core2 xTaskDelayUntil_core2( TickType_t_core2 * const pxPreviousWakeTime_core2,
                                const TickType_t_core2 xTimeIncrement_core2 )
    {
        TickType_t_core2 xTimeToWake_core2;
        BaseType_t_core2 xAlreadyYielded_core2, xShouldDelay_core2 = pdFALSE_core2;

        configASSERT_core2( pxPreviousWakeTime_core2 );
        configASSERT_core2( ( xTimeIncrement_core2 > 0U ) );
        configASSERT_core2( uxSchedulerSuspended_core2 == 0 );

        vTaskSuspendAll_core2();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t_core2 xConstTickCount_core2 = xTickCount_core2;

            /* Generate the tick time at which the task_core2 wants to wake. */
            xTimeToWake_core2 = *pxPreviousWakeTime_core2 + xTimeIncrement_core2;

            if( xConstTickCount_core2 < *pxPreviousWakeTime_core2 )
            {
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake_core2 < *pxPreviousWakeTime_core2 ) && ( xTimeToWake_core2 > xConstTickCount_core2 ) )
                {
                    xShouldDelay_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake_core2 < *pxPreviousWakeTime_core2 ) || ( xTimeToWake_core2 > xConstTickCount_core2 ) )
                {
                    xShouldDelay_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime_core2 = xTimeToWake_core2;

            if( xShouldDelay_core2 != pdFALSE_core2 )
            {
                traceTASK_DELAY_UNTIL_core2( xTimeToWake_core2 );

                /* prvAddCurrentTaskToDelayedList_core2() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList_core2( xTimeToWake_core2 - xConstTickCount_core2, pdFALSE_core2 );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        xAlreadyYielded_core2 = xTaskResumeAll_core2();

        /* Force a reschedule if xTaskResumeAll_core2 has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded_core2 == pdFALSE_core2 )
        {
            portYIELD_WITHIN_API_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return xShouldDelay_core2;
    }

#endif /* INCLUDE_xTaskDelayUntil_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay_core2 == 1 )

    void vTaskDelay_core2( const TickType_t_core2 xTicksToDelay_core2 )
    {
        BaseType_t_core2 xAlreadyYielded_core2 = pdFALSE_core2;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay_core2 > ( TickType_t_core2 ) 0U )
        {
            configASSERT_core2( uxSchedulerSuspended_core2 == 0 );
            vTaskSuspendAll_core2();
            {
                traceTASK_DELAY_core2();

                /* A task_core2 that is removed from the event list while the
                 * scheduler is suspended will not get placed in the ready
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task_core2 cannot be in an event list as it is the currently
                 * executing task_core2. */
                prvAddCurrentTaskToDelayedList_core2( xTicksToDelay_core2, pdFALSE_core2 );
            }
            xAlreadyYielded_core2 = xTaskResumeAll_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        /* Force a reschedule if xTaskResumeAll_core2 has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded_core2 == pdFALSE_core2 )
        {
            portYIELD_WITHIN_API_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* INCLUDE_vTaskDelay_core2 */
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_eTaskGetState_core2 == 1 ) || ( configUSE_TRACE_FACILITY_core2 == 1 ) || ( INCLUDE_xTaskAbortDelay_core2 == 1 ) )

    eTaskState_core2 eTaskGetState_core2( TaskHandle_t_core2 xTask_core2 )
    {
        eTaskState_core2 eReturn_core2;
        List_t_core2 const * pxStateList_core2;
        List_t_core2 const * pxDelayedList_core2;
        List_t_core2 const * pxOverflowedDelayedList_core2;
        const TCB_t_core2 * const pxTCB_core2 = xTask_core2;

        configASSERT_core2( pxTCB_core2 );

        if( pxTCB_core2 == pxCurrentTCB_core2 )
        {
            /* The task_core2 calling this function is querying its own state. */
            eReturn_core2 = eRunning_core2;
        }
        else
        {
            taskENTER_CRITICAL_core2();
            {
                pxStateList_core2 = listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                pxDelayedList_core2 = pxDelayedTaskList_core2;
                pxOverflowedDelayedList_core2 = pxOverflowDelayedTaskList_core2;
            }
            taskEXIT_CRITICAL_core2();

            if( ( pxStateList_core2 == pxDelayedList_core2 ) || ( pxStateList_core2 == pxOverflowedDelayedList_core2 ) )
            {
                /* The task_core2 being queried is referenced from one of the Blocked
                 * lists. */
                eReturn_core2 = eBlocked_core2;
            }

            #if ( INCLUDE_vTaskSuspend_core2 == 1 )
                else if( pxStateList_core2 == &xSuspendedTaskList_core2 )
                {
                    /* The task_core2 being queried is referenced from the suspended
                     * list.  Is it genuinely suspended or is it blocked
                     * indefinitely? */
                    if( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) == NULL )
                    {
                        #if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )
                        {
                            BaseType_t_core2 x;

                            /* The task_core2 does not appear on the event list item of
                             * and of the RTOS objects, but could still be in the
                             * blocked state if it is waiting on its notification
                             * rather than waiting on an object.  If not, is
                             * suspended. */
                            eReturn_core2 = eSuspended_core2;

                            for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2; x++ )
                            {
                                if( pxTCB_core2->ucNotifyState_core2[ x ] == taskWAITING_NOTIFICATION_core2 )
                                {
                                    eReturn_core2 = eBlocked_core2;
                                    break;
                                }
                            }
                        }
                        #else /* if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 ) */
                        {
                            eReturn_core2 = eSuspended_core2;
                        }
                        #endif /* if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 ) */
                    }
                    else
                    {
                        eReturn_core2 = eBlocked_core2;
                    }
                }
            #endif /* if ( INCLUDE_vTaskSuspend_core2 == 1 ) */

            #if ( INCLUDE_vTaskDelete_core2 == 1 )
                else if( ( pxStateList_core2 == &xTasksWaitingTermination_core2 ) || ( pxStateList_core2 == NULL ) )
                {
                    /* The task_core2 being queried is referenced from the deleted
                     * tasks list, or it is not referenced from any lists at
                     * all. */
                    eReturn_core2 = eDeleted_core2;
                }
            #endif

            else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
            {
                /* If the task_core2 is not in any other state, it must be in the
                 * Ready (including pending ready) state. */
                eReturn_core2 = eReady_core2;
            }
        }

        return eReturn_core2;
    } /*lint !e818 xTask_core2 cannot be a pointer to const because it is a typedef. */

#endif /* INCLUDE_eTaskGetState_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet_core2 == 1 )

    UBaseType_t_core2 uxTaskPriorityGet_core2( const TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 const * pxTCB_core2;
        UBaseType_t_core2 uxReturn_core2;

        taskENTER_CRITICAL_core2();
        {
            /* If null is passed in here then it is the priority of the task_core2
             * that called uxTaskPriorityGet_core2() that is being queried. */
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );
            uxReturn_core2 = pxTCB_core2->uxPriority_core2;
        }
        taskEXIT_CRITICAL_core2();

        return uxReturn_core2;
    }

#endif /* INCLUDE_uxTaskPriorityGet_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet_core2 == 1 )

    UBaseType_t_core2 uxTaskPriorityGetFromISR_core2( const TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 const * pxTCB_core2;
        UBaseType_t_core2 uxReturn_core2, uxSavedInterruptState_core2;

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS_core2 API functions.  If configASSERT_core2()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2() will result in an assertion
         * failure if a FreeRTOS_core2 API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS_core2 functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS_core2 maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS_core2.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2();

        uxSavedInterruptState_core2 = portSET_INTERRUPT_MASK_FROM_ISR_core2();
        {
            /* If null is passed in here then it is the priority of the calling
             * task_core2 that is being queried. */
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );
            uxReturn_core2 = pxTCB_core2->uxPriority_core2;
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR_core2( uxSavedInterruptState_core2 );

        return uxReturn_core2;
    }

#endif /* INCLUDE_uxTaskPriorityGet_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet_core2 == 1 )

    void vTaskPrioritySet_core2( TaskHandle_t_core2 xTask_core2,
                           UBaseType_t_core2 uxNewPriority_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        UBaseType_t_core2 uxCurrentBasePriority_core2, uxPriorityUsedOnEntry_core2;
        BaseType_t_core2 xYieldRequired_core2 = pdFALSE_core2;

        configASSERT_core2( uxNewPriority_core2 < configMAX_PRIORITIES_core2 );

        /* Ensure the new priority is valid. */
        if( uxNewPriority_core2 >= ( UBaseType_t_core2 ) configMAX_PRIORITIES_core2 )
        {
            uxNewPriority_core2 = ( UBaseType_t_core2 ) configMAX_PRIORITIES_core2 - ( UBaseType_t_core2 ) 1U;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        taskENTER_CRITICAL_core2();
        {
            /* If null is passed in here then it is the priority of the calling
             * task_core2 that is being changed. */
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

            traceTASK_PRIORITY_SET_core2( pxTCB_core2, uxNewPriority_core2 );

            #if ( configUSE_MUTEXES_core2 == 1 )
            {
                uxCurrentBasePriority_core2 = pxTCB_core2->uxBasePriority_core2;
            }
            #else
            {
                uxCurrentBasePriority_core2 = pxTCB_core2->uxPriority_core2;
            }
            #endif

            if( uxCurrentBasePriority_core2 != uxNewPriority_core2 )
            {
                /* The priority change may have readied a task_core2 of higher
                 * priority than the calling task_core2. */
                if( uxNewPriority_core2 > uxCurrentBasePriority_core2 )
                {
                    if( pxTCB_core2 != pxCurrentTCB_core2 )
                    {
                        /* The priority of a task_core2 other than the currently
                         * running task_core2 is being raised.  Is the priority being
                         * raised above that of the running task_core2? */
                        if( uxNewPriority_core2 >= pxCurrentTCB_core2->uxPriority_core2 )
                        {
                            xYieldRequired_core2 = pdTRUE_core2;
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER_core2();
                        }
                    }
                    else
                    {
                        /* The priority of the running task_core2 is being raised,
                         * but the running task_core2 must already be the highest
                         * priority task_core2 able to run so no yield is required. */
                    }
                }
                else if( pxTCB_core2 == pxCurrentTCB_core2 )
                {
                    /* Setting the priority of the running task_core2 down means
                     * there may now be another task_core2 of higher priority that
                     * is ready to execute. */
                    xYieldRequired_core2 = pdTRUE_core2;
                }
                else
                {
                    /* Setting the priority of any other task_core2 down does not
                     * require a yield as the running task_core2 must be above the
                     * new priority of the task_core2 being modified. */
                }

                /* Remember the ready list the task_core2 might be referenced from
                 * before its uxPriority_core2 member is changed so the
                 * taskRESET_READY_PRIORITY_core2() macro can function correctly. */
                uxPriorityUsedOnEntry_core2 = pxTCB_core2->uxPriority_core2;

                #if ( configUSE_MUTEXES_core2 == 1 )
                {
                    /* Only change the priority being used if the task_core2 is not
                     * currently using an inherited priority. */
                    if( pxTCB_core2->uxBasePriority_core2 == pxTCB_core2->uxPriority_core2 )
                    {
                        pxTCB_core2->uxPriority_core2 = uxNewPriority_core2;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    /* The base priority gets set whatever. */
                    pxTCB_core2->uxBasePriority_core2 = uxNewPriority_core2;
                }
                #else /* if ( configUSE_MUTEXES_core2 == 1 ) */
                {
                    pxTCB_core2->uxPriority_core2 = uxNewPriority_core2;
                }
                #endif /* if ( configUSE_MUTEXES_core2 == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE_core2( &( pxTCB_core2->xEventListItem_core2 ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE_core2 ) == 0UL )
                {
                    listSET_LIST_ITEM_VALUE_core2( &( pxTCB_core2->xEventListItem_core2 ), ( ( TickType_t_core2 ) configMAX_PRIORITIES_core2 - ( TickType_t_core2 ) uxNewPriority_core2 ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }

                /* If the task_core2 is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task_core2 is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN_core2( &( pxReadyTasksLists_core2[ uxPriorityUsedOnEntry_core2 ] ), &( pxTCB_core2->xStateListItem_core2 ) ) != pdFALSE_core2 )
                {
                    /* The task_core2 is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
                    {
                        /* It is known that the task_core2 is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. */
                        portRESET_READY_PRIORITY_core2( uxPriorityUsedOnEntry_core2, uxTopReadyPriority_core2 );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    prvAddTaskToReadyList_core2( pxTCB_core2 );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }

                if( xYieldRequired_core2 != pdFALSE_core2 )
                {
                    taskYIELD_IF_USING_PREEMPTION_core2();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }

                /* Remove compiler warning about unused variables when the port
                 * optimised task_core2 selection is not being used. */
                ( void ) uxPriorityUsedOnEntry_core2;
            }
        }
        taskEXIT_CRITICAL_core2();
    }

#endif /* INCLUDE_vTaskPrioritySet_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend_core2 == 1 )

    void vTaskSuspend_core2( TaskHandle_t_core2 xTaskToSuspend_core2 )
    {
        TCB_t_core2 * pxTCB_core2;

        taskENTER_CRITICAL_core2();
        {
            /* If null is passed in here then it is the running task_core2 that is
             * being suspended. */
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTaskToSuspend_core2 );

            traceTASK_SUSPEND_core2( pxTCB_core2 );

            /* Remove task_core2 from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
            {
                taskRESET_READY_PRIORITY_core2( pxTCB_core2->uxPriority_core2 );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            /* Is the task_core2 waiting on an event also? */
            if( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) != NULL )
            {
                ( void ) uxListRemove_core2( &( pxTCB_core2->xEventListItem_core2 ) );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            vListInsertEnd_core2( &xSuspendedTaskList_core2, &( pxTCB_core2->xStateListItem_core2 ) );

            #if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )
            {
                BaseType_t_core2 x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2; x++ )
                {
                    if( pxTCB_core2->ucNotifyState_core2[ x ] == taskWAITING_NOTIFICATION_core2 )
                    {
                        /* The task_core2 was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB_core2->ucNotifyState_core2[ x ] = taskNOT_WAITING_NOTIFICATION_core2;
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 ) */
        }
        taskEXIT_CRITICAL_core2();

        if( xSchedulerRunning_core2 != pdFALSE_core2 )
        {
            /* Reset the next expected unblock time in case it referred to the
             * task_core2 that is now in the Suspended state. */
            taskENTER_CRITICAL_core2();
            {
                prvResetNextTaskUnblockTime_core2();
            }
            taskEXIT_CRITICAL_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        if( pxTCB_core2 == pxCurrentTCB_core2 )
        {
            if( xSchedulerRunning_core2 != pdFALSE_core2 )
            {
                /* The current task_core2 has just been suspended. */
                configASSERT_core2( uxSchedulerSuspended_core2 == 0 );
                portYIELD_WITHIN_API_core2();
            }
            else
            {
                /* The scheduler is not running, but the task_core2 that was pointed
                 * to by pxCurrentTCB_core2 has just been suspended and pxCurrentTCB_core2
                 * must be adjusted to point to a different task_core2. */
                if( listCURRENT_LIST_LENGTH_core2( &xSuspendedTaskList_core2 ) == uxCurrentNumberOfTasks_core2 ) /*lint !e931 Right has no side effect, just volatile. */
                {
                    /* No other tasks are ready, so set pxCurrentTCB_core2 back to
                     * NULL so when the next task_core2 is created pxCurrentTCB_core2 will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB_core2 = NULL;
                }
                else
                {
                    vTaskSwitchContext_core2();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* INCLUDE_vTaskSuspend_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend_core2 == 1 )

    static BaseType_t_core2 prvTaskIsTaskSuspended_core2( const TaskHandle_t_core2 xTask_core2 )
    {
        BaseType_t_core2 xReturn_core2 = pdFALSE_core2;
        const TCB_t_core2 * const pxTCB_core2 = xTask_core2;

        /* Accesses xPendingReadyList_core2 so must be called from a critical
         * section. */

        /* It does not make sense to check if the calling task_core2 is suspended. */
        configASSERT_core2( xTask_core2 );

        /* Is the task_core2 being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN_core2( &xSuspendedTaskList_core2, &( pxTCB_core2->xStateListItem_core2 ) ) != pdFALSE_core2 )
        {
            /* Has the task_core2 already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN_core2( &xPendingReadyList_core2, &( pxTCB_core2->xEventListItem_core2 ) ) == pdFALSE_core2 )
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN_core2( NULL, &( pxTCB_core2->xEventListItem_core2 ) ) != pdFALSE_core2 ) /*lint !e961.  The cast is only redundant when NULL is used. */
                {
                    xReturn_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return xReturn_core2;
    } /*lint !e818 xTask_core2 cannot be a pointer to const because it is a typedef. */

#endif /* INCLUDE_vTaskSuspend_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend_core2 == 1 )

    void vTaskResume_core2( TaskHandle_t_core2 xTaskToResume_core2 )
    {
        TCB_t_core2 * const pxTCB_core2 = xTaskToResume_core2;

        /* It does not make sense to resume the calling task_core2. */
        configASSERT_core2( xTaskToResume_core2 );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task_core2. */
        if( ( pxTCB_core2 != pxCurrentTCB_core2 ) && ( pxTCB_core2 != NULL ) )
        {
            taskENTER_CRITICAL_core2();
            {
                if( prvTaskIsTaskSuspended_core2( pxTCB_core2 ) != pdFALSE_core2 )
                {
                    traceTASK_RESUME_core2( pxTCB_core2 );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                    prvAddTaskToReadyList_core2( pxTCB_core2 );

                    /* A higher priority task_core2 may have just been resumed. */
                    if( pxTCB_core2->uxPriority_core2 >= pxCurrentTCB_core2->uxPriority_core2 )
                    {
                        /* This yield may not cause the task_core2 just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION_core2();
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            taskEXIT_CRITICAL_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* INCLUDE_vTaskSuspend_core2 */

/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR_core2 == 1 ) && ( INCLUDE_vTaskSuspend_core2 == 1 ) )

    BaseType_t_core2 xTaskResumeFromISR_core2( TaskHandle_t_core2 xTaskToResume_core2 )
    {
        BaseType_t_core2 xYieldRequired_core2 = pdFALSE_core2;
        TCB_t_core2 * const pxTCB_core2 = xTaskToResume_core2;
        UBaseType_t_core2 uxSavedInterruptStatus_core2;

        configASSERT_core2( xTaskToResume_core2 );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS_core2 API functions.  If configASSERT_core2()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2() will result in an assertion
         * failure if a FreeRTOS_core2 API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS_core2 functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS_core2 maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS_core2.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2();

        uxSavedInterruptStatus_core2 = portSET_INTERRUPT_MASK_FROM_ISR_core2();
        {
            if( prvTaskIsTaskSuspended_core2( pxTCB_core2 ) != pdFALSE_core2 )
            {
                traceTASK_RESUME_FROM_ISR_core2( pxTCB_core2 );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
                {
                    /* Ready lists can be accessed so move the task_core2 from the
                     * suspended list to the ready list directly. */
                    if( pxTCB_core2->uxPriority_core2 >= pxCurrentTCB_core2->uxPriority_core2 )
                    {
                        xYieldRequired_core2 = pdTRUE_core2;

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR_core2. */
                        xYieldPending_core2 = pdTRUE_core2;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    ( void ) uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                    prvAddTaskToReadyList_core2( pxTCB_core2 );
                }
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task_core2
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd_core2( &( xPendingReadyList_core2 ), &( pxTCB_core2->xEventListItem_core2 ) );
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR_core2( uxSavedInterruptStatus_core2 );

        return xYieldRequired_core2;
    }

#endif /* ( ( INCLUDE_xTaskResumeFromISR_core2 == 1 ) && ( INCLUDE_vTaskSuspend_core2 == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler_core2( void )
{
    BaseType_t_core2 xReturn_core2;

    /* Add the idle task_core2 at the lowest priority. */
    #if ( configSUPPORT_STATIC_ALLOCATION_core2 == 1 )
    {
        StaticTask_t_core2 * pxIdleTaskTCBBuffer_core2 = NULL;
        StackType_t_core2 * pxIdleTaskStackBuffer_core2 = NULL;
        uint32_t ulIdleTaskStackSize_core2;

        /* The Idle task_core2 is created using user provided RAM - obtain the
         * address of the RAM then create the idle task_core2. */
        vApplicationGetIdleTaskMemory_core2( &pxIdleTaskTCBBuffer_core2, &pxIdleTaskStackBuffer_core2, &ulIdleTaskStackSize_core2 );
        xIdleTaskHandle_core2 = xTaskCreateStatic_core2( prvIdleTask_core2,
                                             configIDLE_TASK_NAME_core2,
                                             ulIdleTaskStackSize_core2,
                                             ( void * ) NULL,       /*lint !e961.  The cast is not redundant for all compilers. */
                                             portPRIVILEGE_BIT_core2,     /* In effect ( tskIDLE_PRIORITY_core2 | portPRIVILEGE_BIT_core2 ), but tskIDLE_PRIORITY_core2 is zero. */
                                             pxIdleTaskStackBuffer_core2,
                                             pxIdleTaskTCBBuffer_core2 ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

        if( xIdleTaskHandle_core2 != NULL )
        {
            xReturn_core2 = pdPASS_core2;
        }
        else
        {
            xReturn_core2 = pdFAIL_core2;
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION_core2 == 1 ) */
    {
        /* The Idle task_core2 is being created using dynamically allocated RAM. */
        xReturn_core2 = xTaskCreate_core2( prvIdleTask_core2,
                               configIDLE_TASK_NAME_core2,
                               configMINIMAL_STACK_SIZE_core2,
                               ( void * ) NULL,
                               portPRIVILEGE_BIT_core2,  /* In effect ( tskIDLE_PRIORITY_core2 | portPRIVILEGE_BIT_core2 ), but tskIDLE_PRIORITY_core2 is zero. */
                               &xIdleTaskHandle_core2 ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    }
    #endif /* configSUPPORT_STATIC_ALLOCATION_core2 */

    #if ( configUSE_TIMERS_core2 == 1 )
    {
        if( xReturn_core2 == pdPASS_core2 )
        {
            xReturn_core2 = xTimerCreateTimerTask_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }
    #endif /* configUSE_TIMERS_core2 */

    if( xReturn_core2 == pdPASS_core2 )
    {
        /* freertos_tasks_c_additions_init_core2() should only be called if the user
         * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT_core2() is defined, as that is
         * the only macro called by the function. */
        #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT_core2
        {
            freertos_tasks_c_additions_init_core2();
        }
        #endif

        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler_core2().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task_core2
         * starts to run. */
        portDISABLE_INTERRUPTS_core2();

        #if ( ( configUSE_NEWLIB_REENTRANT_core2 == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT_core2 == 1 ) )
        {
            /* Switch C-Runtime's TLS Block to point to the TLS
             * block specific to the task_core2 that will run first. */
            configSET_TLS_BLOCK_core2( pxCurrentTCB_core2->xTLSBlock_core2 );
        }
        #endif

        xNextTaskUnblockTime_core2 = portMAX_DELAY_core2;
        xSchedulerRunning_core2 = pdTRUE_core2;
        xTickCount_core2 = ( TickType_t_core2 ) configINITIAL_TICK_COUNT_core2;

        /* If configGENERATE_RUN_TIME_STATS_core2 is defined then the following
         * macro must be defined to configure the timer/counter used to generate
         * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS_core2
         * is set to 0 and the following line fails to build then ensure you do not
         * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS_core2() defined in your
         * FreeRTOSConfig.h file. */
        //portCONFIGURE_TIMER_FOR_RUN_TIME_STATS_core2();

        traceTASK_SWITCHED_IN_core2();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler_core2();

        /* In most cases, xPortStartScheduler_core2() will not return. If it
         * returns pdTRUE_core2 then there was not enough heap memory available
         * to create either the Idle or the Timer task_core2. If it returned
         * pdFALSE_core2, then the application called xTaskEndScheduler().
         * Most ports don't implement xTaskEndScheduler() as there is
         * nothing to return to. */
    }
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS_core2 heap to create the idle task_core2
         * or the timer task_core2. */
        configASSERT_core2( xReturn_core2 != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY_core2 );
    }

    /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle_core2 is set to 0,
     * meaning xIdleTaskHandle_core2 is not used anywhere else. */
    ( void ) xIdleTaskHandle_core2;

    /* OpenOCD makes use of uxTopUsedPriority_core2 for thread debugging. Prevent uxTopUsedPriority_core2
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority_core2;
}
/*-----------------------------------------------------------*/

void vTaskEndScheduler_core2( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS_core2();
    xSchedulerRunning_core2 = pdFALSE_core2;
    vPortEndScheduler_core2();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll_core2( void )
{
    /* A critical section is not required as the variable is of type
     * BaseType_t_core2.  Please read Richard Barry's reply in the following link to a
     * post in the FreeRTOS_core2 support forum before reporting this as a bug! -
     * https://goo.gl/wu4acr */

    /* portSOFTWARE_BARRIER_core2() is only implemented for emulated/simulated ports that
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER_core2();

    /* The scheduler is suspended if uxSchedulerSuspended_core2 is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll_core2() to nest. */
    ++uxSchedulerSuspended_core2;

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER_core2();
}
/*----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE_core2 != 0 )

    static TickType_t_core2 prvGetExpectedIdleTime_core2( void )
    {
        TickType_t_core2 xReturn_core2;
        UBaseType_t_core2 uxHigherPriorityReadyTasks_core2 = pdFALSE_core2;

        /* uxHigherPriorityReadyTasks_core2 takes care of the case where
         * configUSE_PREEMPTION_core2 is 0, so there may be tasks above the idle priority
         * task_core2 that are in the Ready state, even though the idle task_core2 is
         * running. */
        #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 == 0 )
        {
            if( uxTopReadyPriority_core2 > tskIDLE_PRIORITY_core2 )
            {
                uxHigherPriorityReadyTasks_core2 = pdTRUE_core2;
            }
        }
        #else
        {
            const UBaseType_t_core2 uxLeastSignificantBit_core2 = ( UBaseType_t_core2 ) 0x01;

            /* When port optimised task_core2 selection is used the uxTopReadyPriority_core2
             * variable is used as a bit map.  If bits other than the least
             * significant bit are set then there are tasks that have a priority
             * above the idle priority that are in the Ready state.  This takes
             * care of the case where the co-operative scheduler is in use. */
            if( uxTopReadyPriority_core2 > uxLeastSignificantBit_core2 )
            {
                uxHigherPriorityReadyTasks_core2 = pdTRUE_core2;
            }
        }
        #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 == 0 ) */

        if( pxCurrentTCB_core2->uxPriority_core2 > tskIDLE_PRIORITY_core2 )
        {
            xReturn_core2 = 0;
        }
        else if( listCURRENT_LIST_LENGTH_core2( &( pxReadyTasksLists_core2[ tskIDLE_PRIORITY_core2 ] ) ) > 1 )
        {
            /* There are other idle priority tasks in the ready state.  If
             * time slicing is used then the very next tick interrupt must be
             * processed. */
            xReturn_core2 = 0;
        }
        else if( uxHigherPriorityReadyTasks_core2 != pdFALSE_core2 )
        {
            /* There are tasks in the Ready state that have a priority above the
             * idle priority.  This path can only be reached if
             * configUSE_PREEMPTION_core2 is 0. */
            xReturn_core2 = 0;
        }
        else
        {
            xReturn_core2 = xNextTaskUnblockTime_core2 - xTickCount_core2;
        }

        return xReturn_core2;
    }

#endif /* configUSE_TICKLESS_IDLE_core2 */
/*----------------------------------------------------------*/

BaseType_t_core2 xTaskResumeAll_core2( void )
{
    TCB_t_core2 * pxTCB_core2 = NULL;
    BaseType_t_core2 xAlreadyYielded_core2 = pdFALSE_core2;

    /* If uxSchedulerSuspended_core2 is zero then this function does not match a
     * previous call to vTaskSuspendAll_core2(). */
    configASSERT_core2( uxSchedulerSuspended_core2 );

    /* It is possible that an ISR caused a task_core2 to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task_core2 will have been added to the xPendingReadyList_core2.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL_core2();
    {
        --uxSchedulerSuspended_core2;

        if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
        {
            if( uxCurrentNumberOfTasks_core2 > ( UBaseType_t_core2 ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY_core2( &xPendingReadyList_core2 ) == pdFALSE_core2 )
                {
                    pxTCB_core2 = listGET_OWNER_OF_HEAD_ENTRY_core2( ( &xPendingReadyList_core2 ) ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM_core2( &( pxTCB_core2->xEventListItem_core2 ) );
                    portMEMORY_BARRIER_core2();
                    listREMOVE_ITEM_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                    prvAddTaskToReadyList_core2( pxTCB_core2 );

                    /* If the moved task_core2 has a priority higher than or equal to
                     * the current task_core2 then a yield must be performed. */
                    if( pxTCB_core2->uxPriority_core2 >= pxCurrentTCB_core2->uxPriority_core2 )
                    {
                        xYieldPending_core2 = pdTRUE_core2;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }

                if( pxTCB_core2 != NULL )
                {
                    /* A task_core2 was unblocked while the scheduler was suspended,
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime_core2();
                }

                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t_core2 xPendedCounts_core2 = xPendedTicks_core2; /* Non-volatile copy. */

                    if( xPendedCounts_core2 > ( TickType_t_core2 ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick_core2() != pdFALSE_core2 )
                            {
                                xYieldPending_core2 = pdTRUE_core2;
                            }
                            else
                            {
                                mtCOVERAGE_TEST_MARKER_core2();
                            }

                            --xPendedCounts_core2;
                        } while( xPendedCounts_core2 > ( TickType_t_core2 ) 0U );

                        xPendedTicks_core2 = 0;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }

                if( xYieldPending_core2 != pdFALSE_core2 )
                {
                    #if ( configUSE_PREEMPTION_core2 != 0 )
                    {
                        xAlreadyYielded_core2 = pdTRUE_core2;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION_core2();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }
    taskEXIT_CRITICAL_core2();

    return xAlreadyYielded_core2;
}
/*-----------------------------------------------------------*/

TickType_t_core2 xTaskGetTickCount_core2( void )
{
    TickType_t_core2 xTicks_core2;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL_core2();
    {
        xTicks_core2 = xTickCount_core2;
    }
    portTICK_TYPE_EXIT_CRITICAL_core2();

    return xTicks_core2;
}
/*-----------------------------------------------------------*/

TickType_t_core2 xTaskGetTickCountFromISR_core2( void )
{
    TickType_t_core2 xReturn_core2;
    UBaseType_t_core2 uxSavedInterruptStatus_core2;

    /* RTOS ports that support interrupt nesting have the concept of a maximum
     * system call (or maximum API call) interrupt priority.  Interrupts that are
     * above the maximum system call priority are kept permanently enabled, even
     * when the RTOS kernel is in a critical section, but cannot make any calls to
     * FreeRTOS_core2 API functions.  If configASSERT_core2() is defined in FreeRTOSConfig.h
     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2() will result in an assertion
     * failure if a FreeRTOS_core2 API function is called from an interrupt that has been
     * assigned a priority above the configured maximum system call priority.
     * Only FreeRTOS_core2 functions that end in FromISR can be called from interrupts
     * that have been assigned a priority at or (logically) below the maximum
     * system call  interrupt priority.  FreeRTOS_core2 maintains a separate interrupt
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS_core2.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2();

    uxSavedInterruptStatus_core2 = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR_core2();
    {
        xReturn_core2 = xTickCount_core2;
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR_core2( uxSavedInterruptStatus_core2 );

    return xReturn_core2;
}
/*-----------------------------------------------------------*/

UBaseType_t_core2 uxTaskGetNumberOfTasks_core2( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t_core2. */
    return uxCurrentNumberOfTasks_core2;
}
/*-----------------------------------------------------------*/

char * pcTaskGetName_core2( TaskHandle_t_core2 xTaskToQuery_core2 ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    TCB_t_core2 * pxTCB_core2;

    /* If null is passed in here then the name of the calling task_core2 is being
     * queried. */
    pxTCB_core2 = prvGetTCBFromHandle_core2( xTaskToQuery_core2 );
    configASSERT_core2( pxTCB_core2 );
    return &( pxTCB_core2->pcTaskName_core2[ 0 ] );
}
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetHandle_core2 == 1 )

    static TCB_t_core2 * prvSearchForNameWithinSingleList_core2( List_t_core2 * pxList_core2,
                                                     const char pcNameToQuery_core2[] )
    {
        TCB_t_core2 * pxNextTCB_core2;
        TCB_t_core2 * pxFirstTCB_core2;
        TCB_t_core2 * pxReturn_core2 = NULL;
        UBaseType_t_core2 x;
        char cNextChar_core2;
        BaseType_t_core2 xBreakLoop_core2;

        /* This function is called with the scheduler suspended. */

        if( listCURRENT_LIST_LENGTH_core2( pxList_core2 ) > ( UBaseType_t_core2 ) 0 )
        {
            listGET_OWNER_OF_NEXT_ENTRY_core2( pxFirstTCB_core2, pxList_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */

            do
            {
                listGET_OWNER_OF_NEXT_ENTRY_core2( pxNextTCB_core2, pxList_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */

                /* Check each character in the name looking for a match or
                 * mismatch. */
                xBreakLoop_core2 = pdFALSE_core2;

                for( x = ( UBaseType_t_core2 ) 0; x < ( UBaseType_t_core2 ) configMAX_TASK_NAME_LEN_core2; x++ )
                {
                    cNextChar_core2 = pxNextTCB_core2->pcTaskName_core2[ x ];

                    if( cNextChar_core2 != pcNameToQuery_core2[ x ] )
                    {
                        /* Characters didn't match. */
                        xBreakLoop_core2 = pdTRUE_core2;
                    }
                    else if( cNextChar_core2 == ( char ) 0x00 )
                    {
                        /* Both strings terminated, a match must have been
                         * found. */
                        pxReturn_core2 = pxNextTCB_core2;
                        xBreakLoop_core2 = pdTRUE_core2;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    if( xBreakLoop_core2 != pdFALSE_core2 )
                    {
                        break;
                    }
                }

                if( pxReturn_core2 != NULL )
                {
                    /* The handle has been found. */
                    break;
                }
            } while( pxNextTCB_core2 != pxFirstTCB_core2 );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return pxReturn_core2;
    }

#endif /* INCLUDE_xTaskGetHandle_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetHandle_core2 == 1 )

    TaskHandle_t_core2 xTaskGetHandle_core2( const char * pcNameToQuery_core2 ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
        UBaseType_t_core2 uxQueue_core2 = configMAX_PRIORITIES_core2;
        TCB_t_core2 * pxTCB_core2;

        /* Task names will be truncated to configMAX_TASK_NAME_LEN_core2 - 1 bytes. */
        configASSERT_core2( strlen( pcNameToQuery_core2 ) < configMAX_TASK_NAME_LEN_core2 );

        vTaskSuspendAll_core2();
        {
            /* Search the ready lists. */
            do
            {
                uxQueue_core2--;
                pxTCB_core2 = prvSearchForNameWithinSingleList_core2( ( List_t_core2 * ) &( pxReadyTasksLists_core2[ uxQueue_core2 ] ), pcNameToQuery_core2 );

                if( pxTCB_core2 != NULL )
                {
                    /* Found the handle. */
                    break;
                }
            } while( uxQueue_core2 > ( UBaseType_t_core2 ) tskIDLE_PRIORITY_core2 ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

            /* Search the delayed lists. */
            if( pxTCB_core2 == NULL )
            {
                pxTCB_core2 = prvSearchForNameWithinSingleList_core2( ( List_t_core2 * ) pxDelayedTaskList_core2, pcNameToQuery_core2 );
            }

            if( pxTCB_core2 == NULL )
            {
                pxTCB_core2 = prvSearchForNameWithinSingleList_core2( ( List_t_core2 * ) pxOverflowDelayedTaskList_core2, pcNameToQuery_core2 );
            }

            #if ( INCLUDE_vTaskSuspend_core2 == 1 )
            {
                if( pxTCB_core2 == NULL )
                {
                    /* Search the suspended list. */
                    pxTCB_core2 = prvSearchForNameWithinSingleList_core2( &xSuspendedTaskList_core2, pcNameToQuery_core2 );
                }
            }
            #endif

            #if ( INCLUDE_vTaskDelete_core2 == 1 )
            {
                if( pxTCB_core2 == NULL )
                {
                    /* Search the deleted list. */
                    pxTCB_core2 = prvSearchForNameWithinSingleList_core2( &xTasksWaitingTermination_core2, pcNameToQuery_core2 );
                }
            }
            #endif
        }
        ( void ) xTaskResumeAll_core2();

        return pxTCB_core2;
    }

#endif /* INCLUDE_xTaskGetHandle_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY_core2 == 1 )

    UBaseType_t_core2 uxTaskGetSystemState_core2( TaskStatus_t_core2 * const pxTaskStatusArray_core2,
                                      const UBaseType_t_core2 uxArraySize_core2,
                                      configRUN_TIME_COUNTER_TYPE_core2 * const pulTotalRunTime_core2 )
    {
        UBaseType_t_core2 uxTask_core2 = 0, uxQueue_core2 = configMAX_PRIORITIES_core2;

        vTaskSuspendAll_core2();
        {
            /* Is there a space in the array for each task_core2 in the system? */
            if( uxArraySize_core2 >= uxCurrentNumberOfTasks_core2 )
            {
                /* Fill in an TaskStatus_t_core2 structure with information on each
                 * task_core2 in the Ready state. */
                do
                {
                    uxQueue_core2--;
                    uxTask_core2 += prvListTasksWithinSingleList_core2( &( pxTaskStatusArray_core2[ uxTask_core2 ] ), &( pxReadyTasksLists_core2[ uxQueue_core2 ] ), eReady_core2 );
                } while( uxQueue_core2 > ( UBaseType_t_core2 ) tskIDLE_PRIORITY_core2 ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

                /* Fill in an TaskStatus_t_core2 structure with information on each
                 * task_core2 in the Blocked state. */
                uxTask_core2 += prvListTasksWithinSingleList_core2( &( pxTaskStatusArray_core2[ uxTask_core2 ] ), ( List_t_core2 * ) pxDelayedTaskList_core2, eBlocked_core2 );
                uxTask_core2 += prvListTasksWithinSingleList_core2( &( pxTaskStatusArray_core2[ uxTask_core2 ] ), ( List_t_core2 * ) pxOverflowDelayedTaskList_core2, eBlocked_core2 );

                #if ( INCLUDE_vTaskDelete_core2 == 1 )
                {
                    /* Fill in an TaskStatus_t_core2 structure with information on
                     * each task_core2 that has been deleted but not yet cleaned up. */
                    uxTask_core2 += prvListTasksWithinSingleList_core2( &( pxTaskStatusArray_core2[ uxTask_core2 ] ), &xTasksWaitingTermination_core2, eDeleted_core2 );
                }
                #endif

                #if ( INCLUDE_vTaskSuspend_core2 == 1 )
                {
                    /* Fill in an TaskStatus_t_core2 structure with information on
                     * each task_core2 in the Suspended state. */
                    uxTask_core2 += prvListTasksWithinSingleList_core2( &( pxTaskStatusArray_core2[ uxTask_core2 ] ), &xSuspendedTaskList_core2, eSuspended_core2 );
                }
                #endif

                #if ( configGENERATE_RUN_TIME_STATS_core2 == 1 )
                {
                    if( pulTotalRunTime_core2 != NULL )
                    {
                        #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE_core2
                            portALT_GET_RUN_TIME_COUNTER_VALUE_core2( ( *pulTotalRunTime_core2 ) );
                        #else
                            *pulTotalRunTime_core2 = portGET_RUN_TIME_COUNTER_VALUE_core2();
                        #endif
                    }
                }
                #else /* if ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) */
                {
                    if( pulTotalRunTime_core2 != NULL )
                    {
                        *pulTotalRunTime_core2 = 0;
                    }
                }
                #endif /* if ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) */
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        ( void ) xTaskResumeAll_core2();

        return uxTask_core2;
    }

#endif /* configUSE_TRACE_FACILITY_core2 */
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle_core2 == 1 )

    TaskHandle_t_core2 xTaskGetIdleTaskHandle_core2( void )
    {
        /* If xTaskGetIdleTaskHandle_core2() is called before the scheduler has been
         * started, then xIdleTaskHandle_core2 will be NULL. */
        configASSERT_core2( ( xIdleTaskHandle_core2 != NULL ) );
        return xIdleTaskHandle_core2;
    }

#endif /* INCLUDE_xTaskGetIdleTaskHandle_core2 */
/*----------------------------------------------------------*/

/* This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure vTaskStepTick_core2() is available when user defined low power mode
 * implementations require configUSE_TICKLESS_IDLE_core2 to be set to a value other than
 * 1. */
#if ( configUSE_TICKLESS_IDLE_core2 != 0 )

    void vTaskStepTick_core2( TickType_t_core2 xTicksToJump_core2 )
    {
        /* Correct the tick count value after a period during which the tick
         * was suppressed.  Note this does *not* call the tick hook function for
         * each stepped tick. */
        configASSERT_core2( ( xTickCount_core2 + xTicksToJump_core2 ) <= xNextTaskUnblockTime_core2 );

        if( ( xTickCount_core2 + xTicksToJump_core2 ) == xNextTaskUnblockTime_core2 )
        {
            /* Arrange for xTickCount_core2 to reach xNextTaskUnblockTime_core2 in
             * xTaskIncrementTick_core2() when the scheduler resumes.  This ensures
             * that any delayed tasks are resumed at the correct time. */
            configASSERT_core2( uxSchedulerSuspended_core2 );
            configASSERT_core2( xTicksToJump_core2 != ( TickType_t_core2 ) 0 );

            /* Prevent the tick interrupt modifying xPendedTicks_core2 simultaneously. */
            taskENTER_CRITICAL_core2();
            {
                xPendedTicks_core2++;
            }
            taskEXIT_CRITICAL_core2();
            xTicksToJump_core2--;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        xTickCount_core2 += xTicksToJump_core2;
        traceINCREASE_TICK_COUNT_core2( xTicksToJump_core2 );
    }

#endif /* configUSE_TICKLESS_IDLE_core2 */
/*----------------------------------------------------------*/

BaseType_t_core2 xTaskCatchUpTicks_core2( TickType_t_core2 xTicksToCatchUp )
{
    BaseType_t_core2 xYieldOccurred;

    /* Must not be called with the scheduler suspended as the implementation
     * relies on xPendedTicks_core2 being wound down to 0 in xTaskResumeAll_core2(). */
    configASSERT_core2( uxSchedulerSuspended_core2 == 0 );

    /* Use xPendedTicks_core2 to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll_core2(). */
    vTaskSuspendAll_core2();

    /* Prevent the tick interrupt modifying xPendedTicks_core2 simultaneously. */
    taskENTER_CRITICAL_core2();
    {
        xPendedTicks_core2 += xTicksToCatchUp;
    }
    taskEXIT_CRITICAL_core2();
    xYieldOccurred = xTaskResumeAll_core2();

    return xYieldOccurred;
}
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskAbortDelay_core2 == 1 )

    BaseType_t_core2 xTaskAbortDelay_core2( TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 * pxTCB_core2 = xTask_core2;
        BaseType_t_core2 xReturn_core2;

        configASSERT_core2( pxTCB_core2 );

        vTaskSuspendAll_core2();
        {
            /* A task_core2 can only be prematurely removed from the Blocked state if
             * it is actually in the Blocked state. */
            if( eTaskGetState_core2( xTask_core2 ) == eBlocked_core2 )
            {
                xReturn_core2 = pdPASS_core2;

                /* Remove the reference to the task_core2 from the blocked list.  An
                 * interrupt won't touch the xStateListItem_core2 because the
                 * scheduler is suspended. */
                ( void ) uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) );

                /* Is the task_core2 waiting on an event also?  If so remove it from
                 * the event list too.  Interrupts can touch the event list item,
                 * even though the scheduler is suspended, so a critical section
                 * is used. */
                taskENTER_CRITICAL_core2();
                {
                    if( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) != NULL )
                    {
                        ( void ) uxListRemove_core2( &( pxTCB_core2->xEventListItem_core2 ) );

                        /* This lets the task_core2 know it was forcibly removed from the
                         * blocked state so it should not re-evaluate its block time and
                         * then block again. */
                        pxTCB_core2->ucDelayAborted_core2 = pdTRUE_core2;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }
                taskEXIT_CRITICAL_core2();

                /* Place the unblocked task_core2 into the appropriate ready list. */
                prvAddTaskToReadyList_core2( pxTCB_core2 );

                /* A task_core2 being unblocked cannot cause an immediate context
                 * switch if preemption is turned off. */
                #if ( configUSE_PREEMPTION_core2 == 1 )
                {
                    /* Preemption is on, but a context switch should only be
                     * performed if the unblocked task_core2 has a priority that is
                     * higher than the currently executing task_core2. */
                    if( pxTCB_core2->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
                    {
                        /* Pend the yield to be performed when the scheduler
                         * is unsuspended. */
                        xYieldPending_core2 = pdTRUE_core2;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }
                #endif /* configUSE_PREEMPTION_core2 */
            }
            else
            {
                xReturn_core2 = pdFAIL_core2;
            }
        }
        ( void ) xTaskResumeAll_core2();

        return xReturn_core2;
    }

#endif /* INCLUDE_xTaskAbortDelay_core2 */
/*----------------------------------------------------------*/

BaseType_t_core2 xTaskIncrementTick_core2( void )
{
    TCB_t_core2 * pxTCB_core2;
    TickType_t_core2 xItemValue_core2;
    BaseType_t_core2 xSwitchRequired = pdFALSE_core2;

    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK_core2( xTickCount_core2 );

    if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t_core2 xConstTickCount_core2 = xTickCount_core2 + ( TickType_t_core2 ) 1;

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount_core2 = xConstTickCount_core2;

        if( xConstTickCount_core2 == ( TickType_t_core2 ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
        {
            taskSWITCH_DELAYED_LISTS_core2();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task_core2
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount_core2 >= xNextTaskUnblockTime_core2 )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY_core2( pxDelayedTaskList_core2 ) != pdFALSE_core2 )
                {
                    /* The delayed list is empty.  Set xNextTaskUnblockTime_core2
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount_core2 >= xNextTaskUnblockTime_core2 ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime_core2 = portMAX_DELAY_core2; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                    break;
                }
                else
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task_core2 at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB_core2 = listGET_OWNER_OF_HEAD_ENTRY_core2( pxDelayedTaskList_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    xItemValue_core2 = listGET_LIST_ITEM_VALUE_core2( &( pxTCB_core2->xStateListItem_core2 ) );

                    if( xConstTickCount_core2 < xItemValue_core2 )
                    {
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task_core2 at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime_core2. */
                        xNextTaskUnblockTime_core2 = xItemValue_core2;
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM_core2( &( pxTCB_core2->xStateListItem_core2 ) );

                    /* Is the task_core2 waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) != NULL )
                    {
                        listREMOVE_ITEM_core2( &( pxTCB_core2->xEventListItem_core2 ) );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    /* Place the unblocked task_core2 into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList_core2( pxTCB_core2 );

                    /* A task_core2 being unblocked cannot cause an immediate
                     * context switch if preemption is turned off. */
                    #if ( configUSE_PREEMPTION_core2 == 1 )
                    {
                        /* Preemption is on, but a context switch should
                         * only be performed if the unblocked task_core2's
                         * priority is higher than the currently executing
                         * task_core2.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB_core2->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
                        {
                            xSwitchRequired = pdTRUE_core2;
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER_core2();
                        }
                    }
                    #endif /* configUSE_PREEMPTION_core2 */
                }
            }
        }

        /* Tasks of equal priority to the currently running task_core2 will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION_core2 == 1 ) && ( configUSE_TIME_SLICING_core2 == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH_core2( &( pxReadyTasksLists_core2[ pxCurrentTCB_core2->uxPriority_core2 ] ) ) > ( UBaseType_t_core2 ) 1 )
            {
                xSwitchRequired = pdTRUE_core2;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        #endif /* ( ( configUSE_PREEMPTION_core2 == 1 ) && ( configUSE_TIME_SLICING_core2 == 1 ) ) */

        #if ( configUSE_TICK_HOOK_core2 == 1 )
        {
            /* Guard against the tick hook being called when the pended tick
             * count is being unwound (when the scheduler is being unlocked). */
            if( xPendedTicks_core2 == ( TickType_t_core2 ) 0 )
            {
                vApplicationTickHook_core2();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        #endif /* configUSE_TICK_HOOK_core2 */

        #if ( configUSE_PREEMPTION_core2 == 1 )
        {
            if( xYieldPending_core2 != pdFALSE_core2 )
            {
                xSwitchRequired = pdTRUE_core2;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        #endif /* configUSE_PREEMPTION_core2 */
    }
    else
    {
        ++xPendedTicks_core2;

        /* The tick hook gets called at regular intervals, even if the
         * scheduler is locked. */
        #if ( configUSE_TICK_HOOK_core2 == 1 )
        {
            vApplicationTickHook_core2();
        }
        #endif
    }

    return xSwitchRequired;
}
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG_core2 == 1 )

    void vTaskSetApplicationTaskTag_core2( TaskHandle_t_core2 xTask_core2,
                                     TaskHookFunction_t_core2 pxHookFunction_core2 )
    {
        TCB_t_core2 * xTCB;

        /* If xTask_core2 is NULL then it is the task_core2 hook of the calling task_core2 that is
         * getting set. */
        if( xTask_core2 == NULL )
        {
            xTCB = ( TCB_t_core2 * ) pxCurrentTCB_core2;
        }
        else
        {
            xTCB = xTask_core2;
        }

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        taskENTER_CRITICAL_core2();
        {
            xTCB->pxTaskTag_core2 = pxHookFunction_core2;
        }
        taskEXIT_CRITICAL_core2();
    }

#endif /* configUSE_APPLICATION_TASK_TAG_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG_core2 == 1 )

    TaskHookFunction_t_core2 xTaskGetApplicationTaskTag_core2( TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        TaskHookFunction_t_core2 xReturn_core2;

        /* If xTask_core2 is NULL then set the calling task_core2's hook. */
        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        taskENTER_CRITICAL_core2();
        {
            xReturn_core2 = pxTCB_core2->pxTaskTag_core2;
        }
        taskEXIT_CRITICAL_core2();

        return xReturn_core2;
    }

#endif /* configUSE_APPLICATION_TASK_TAG_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG_core2 == 1 )

    TaskHookFunction_t_core2 xTaskGetApplicationTaskTagFromISR_core2( TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        TaskHookFunction_t_core2 xReturn_core2;
        UBaseType_t_core2 uxSavedInterruptStatus_core2;

        /* If xTask_core2 is NULL then set the calling task_core2's hook. */
        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        uxSavedInterruptStatus_core2 = portSET_INTERRUPT_MASK_FROM_ISR_core2();
        {
            xReturn_core2 = pxTCB_core2->pxTaskTag_core2;
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR_core2( uxSavedInterruptStatus_core2 );

        return xReturn_core2;
    }

#endif /* configUSE_APPLICATION_TASK_TAG_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG_core2 == 1 )

    BaseType_t_core2 xTaskCallApplicationTaskHook_core2( TaskHandle_t_core2 xTask_core2,
                                             void * pvParameter_core2 )
    {
        TCB_t_core2 * xTCB;
        BaseType_t_core2 xReturn_core2;

        /* If xTask_core2 is NULL then we are calling our own task_core2 hook. */
        if( xTask_core2 == NULL )
        {
            xTCB = pxCurrentTCB_core2;
        }
        else
        {
            xTCB = xTask_core2;
        }

        if( xTCB->pxTaskTag_core2 != NULL )
        {
            xReturn_core2 = xTCB->pxTaskTag_core2( pvParameter_core2 );
        }
        else
        {
            xReturn_core2 = pdFAIL_core2;
        }

        return xReturn_core2;
    }

#endif /* configUSE_APPLICATION_TASK_TAG_core2 */
/*-----------------------------------------------------------*/

void vTaskSwitchContext_core2( void )
{
    if( uxSchedulerSuspended_core2 != ( UBaseType_t_core2 ) pdFALSE_core2 )
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending_core2 = pdTRUE_core2;
    }
    else
    {
        xYieldPending_core2 = pdFALSE_core2;
        traceTASK_SWITCHED_OUT_core2();

        #if ( configGENERATE_RUN_TIME_STATS_core2 == 1 )
        {
            #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE_core2
                portALT_GET_RUN_TIME_COUNTER_VALUE_core2( ulTotalRunTime_core2 );
            #else
                ulTotalRunTime_core2 = portGET_RUN_TIME_COUNTER_VALUE_core2();
            #endif

            /* Add the amount of time the task_core2 has been running to the
             * accumulated time so far.  The time the task_core2 started running was
             * stored in ulTaskSwitchedInTime_core2.  Note that there is no overflow
             * protection here so count values are only valid until the timer
             * overflows.  The guard against negative values is to protect
             * against suspect run time stat counter implementations - which
             * are provided by the application, not the kernel. */
            if( ulTotalRunTime_core2 > ulTaskSwitchedInTime_core2 )
            {
                pxCurrentTCB_core2->ulRunTimeCounter_core2 += ( ulTotalRunTime_core2 - ulTaskSwitchedInTime_core2 );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            ulTaskSwitchedInTime_core2 = ulTotalRunTime_core2;
        }
        #endif /* configGENERATE_RUN_TIME_STATS_core2 */

        /* Check for stack overflow, if configured. */
        taskCHECK_FOR_STACK_OVERFLOW();

        /* Before the currently running task_core2 is switched out, save its errno. */
        #if ( configUSE_POSIX_ERRNO_core2 == 1 )
        {
            pxCurrentTCB_core2->iTaskErrno_core2 = FreeRTOS_errno_core2;
        }
        #endif

        /* Select a new task_core2 to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK_core2(); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
        traceTASK_SWITCHED_IN_core2();

        /* After the new task_core2 is switched in, update the global errno. */
        #if ( configUSE_POSIX_ERRNO_core2 == 1 )
        {
            FreeRTOS_errno_core2 = pxCurrentTCB_core2->iTaskErrno_core2;
        }
        #endif

        #if ( ( configUSE_NEWLIB_REENTRANT_core2 == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT_core2 == 1 ) )
        {
            /* Switch C-Runtime's TLS Block to point to the TLS
             * Block specific to this task_core2. */
            configSET_TLS_BLOCK_core2( pxCurrentTCB_core2->xTLSBlock_core2 );
        }
        #endif
    }
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList_core2( List_t_core2 * const pxEventList_core2,
                            const TickType_t_core2 xTicksToWait_core2 )
{
    configASSERT_core2( pxEventList_core2 );

    /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
     * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task_core2
     * is the first to be woken by the event.
     *
     * Note: Lists are sorted in ascending order by ListItem_t_core2.xItemValue_core2.
     * Normally, the xItemValue_core2 of a TCB's ListItem_t_core2 members is:
     *      xItemValue_core2 = ( configMAX_PRIORITIES_core2 - uxPriority_core2 )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert_core2( pxEventList_core2, &( pxCurrentTCB_core2->xEventListItem_core2 ) );

    prvAddCurrentTaskToDelayedList_core2( xTicksToWait_core2, pdTRUE_core2 );
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList_core2( List_t_core2 * pxEventList_core2,
                                     const TickType_t_core2 xItemValue_core2,
                                     const TickType_t_core2 xTicksToWait_core2 )
{
    configASSERT_core2( pxEventList_core2 );

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event groups implementation. */
    configASSERT_core2( uxSchedulerSuspended_core2 != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task_core2 that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE_core2( &( pxCurrentTCB_core2->xEventListItem_core2 ), xItemValue_core2 | taskEVENT_LIST_ITEM_VALUE_IN_USE_core2 );

    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task_core2 level). */
    listINSERT_END_core2( pxEventList_core2, &( pxCurrentTCB_core2->xEventListItem_core2 ) );

    prvAddCurrentTaskToDelayedList_core2( xTicksToWait_core2, pdTRUE_core2 );
}
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS_core2 == 1 )

    void vTaskPlaceOnEventListRestricted_core2( List_t_core2 * const pxEventList_core2,
                                          TickType_t_core2 xTicksToWait_core2,
                                          const BaseType_t_core2 xWaitIndefinitely_core2 )
    {
        configASSERT_core2( pxEventList_core2 );

        /* This function should not be called by application code hence the
         * 'Restricted' in its name.  It is not part of the public API.  It is
         * designed for use by kernel code, and has special calling requirements -
         * it should be called with the scheduler suspended. */


        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task_core2 that is going to
         * be waiting on this event list, so the faster vListInsertEnd_core2() function
         * can be used in place of vListInsert_core2. */
        listINSERT_END_core2( pxEventList_core2, &( pxCurrentTCB_core2->xEventListItem_core2 ) );

        /* If the task_core2 should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList_core2() function. */
        if( xWaitIndefinitely_core2 != pdFALSE_core2 )
        {
            xTicksToWait_core2 = portMAX_DELAY_core2;
        }

        traceTASK_DELAY_UNTIL_core2( ( xTickCount_core2 + xTicksToWait_core2 ) );
        prvAddCurrentTaskToDelayedList_core2( xTicksToWait_core2, xWaitIndefinitely_core2 );
    }

#endif /* configUSE_TIMERS_core2 */
/*-----------------------------------------------------------*/

BaseType_t_core2 xTaskRemoveFromEventList_core2( const List_t_core2 * const pxEventList_core2 )
{
    TCB_t_core2 * pxUnblockedTCB;
    BaseType_t_core2 xReturn_core2;

    /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
     * called from a critical section within an ISR. */

    /* The event list is sorted in priority order, so the first in the list can
     * be removed as it is known to be the highest priority.  Remove the TCB from
     * the delayed list, and add it to the ready list.
     *
     * If an event is for a queue that is locked then this function will never
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList_core2 is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY_core2( pxEventList_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    configASSERT_core2( pxUnblockedTCB );
    listREMOVE_ITEM_core2( &( pxUnblockedTCB->xEventListItem_core2 ) );

    if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
    {
        listREMOVE_ITEM_core2( &( pxUnblockedTCB->xStateListItem_core2 ) );
        prvAddTaskToReadyList_core2( pxUnblockedTCB );

        #if ( configUSE_TICKLESS_IDLE_core2 != 0 )
        {
            /* If a task_core2 is blocked on a kernel object then xNextTaskUnblockTime_core2
             * might be set to the blocked task_core2's time out time.  If the task_core2 is
             * unblocked for a reason other than a timeout xNextTaskUnblockTime_core2 is
             * normally left unchanged, because it is automatically reset to a new
             * value when the tick count equals xNextTaskUnblockTime_core2.  However if
             * tickless idling is used it might be more important to enter sleep mode
             * at the earliest possible time - so reset xNextTaskUnblockTime_core2 here to
             * ensure it is updated at the earliest possible time. */
            prvResetNextTaskUnblockTime_core2();
        }
        #endif
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task_core2
         * pending until the scheduler is resumed. */
        listINSERT_END_core2( &( xPendingReadyList_core2 ), &( pxUnblockedTCB->xEventListItem_core2 ) );
    }

    if( pxUnblockedTCB->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
    {
        /* Return true if the task_core2 removed from the event list has a higher
         * priority than the calling task_core2.  This allows the calling task_core2 to know if
         * it should force a context switch now. */
        xReturn_core2 = pdTRUE_core2;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken_core2" parameter to an ISR safe FreeRTOS_core2 function. */
        xYieldPending_core2 = pdTRUE_core2;
    }
    else
    {
        xReturn_core2 = pdFALSE_core2;
    }

    return xReturn_core2;
}
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList_core2( ListItem_t_core2 * pxEventListItem_core2,
                                        const TickType_t_core2 xItemValue_core2 )
{
    TCB_t_core2 * pxUnblockedTCB;

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT_core2( uxSchedulerSuspended_core2 != pdFALSE_core2 );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE_core2( pxEventListItem_core2, xItemValue_core2 | taskEVENT_LIST_ITEM_VALUE_IN_USE_core2 );

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER_core2( pxEventListItem_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    configASSERT_core2( pxUnblockedTCB );
    listREMOVE_ITEM_core2( pxEventListItem_core2 );

    #if ( configUSE_TICKLESS_IDLE_core2 != 0 )
    {
        /* If a task_core2 is blocked on a kernel object then xNextTaskUnblockTime_core2
         * might be set to the blocked task_core2's time out time.  If the task_core2 is
         * unblocked for a reason other than a timeout xNextTaskUnblockTime_core2 is
         * normally left unchanged, because it is automatically reset to a new
         * value when the tick count equals xNextTaskUnblockTime_core2.  However if
         * tickless idling is used it might be more important to enter sleep mode
         * at the earliest possible time - so reset xNextTaskUnblockTime_core2 here to
         * ensure it is updated at the earliest possible time. */
        prvResetNextTaskUnblockTime_core2();
    }
    #endif

    /* Remove the task_core2 from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM_core2( &( pxUnblockedTCB->xStateListItem_core2 ) );
    prvAddTaskToReadyList_core2( pxUnblockedTCB );

    if( pxUnblockedTCB->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
    {
        /* The unblocked task_core2 has a priority above that of the calling task_core2, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending_core2 is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending_core2 = pdTRUE_core2;
    }
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState_core2( TimeOut_t_core2 * const pxTimeOut_core2 )
{
    configASSERT_core2( pxTimeOut_core2 );
    taskENTER_CRITICAL_core2();
    {
        pxTimeOut_core2->xOverflowCount_core2 = xNumOfOverflows_core2;
        pxTimeOut_core2->xTimeOnEntering_core2 = xTickCount_core2;
    }
    taskEXIT_CRITICAL_core2();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState_core2( TimeOut_t_core2 * const pxTimeOut_core2 )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut_core2->xOverflowCount_core2 = xNumOfOverflows_core2;
    pxTimeOut_core2->xTimeOnEntering_core2 = xTickCount_core2;
}
/*-----------------------------------------------------------*/

BaseType_t_core2 xTaskCheckForTimeOut_core2( TimeOut_t_core2 * const pxTimeOut_core2,
                                 TickType_t_core2 * const pxTicksToWait_core2 )
{
    BaseType_t_core2 xReturn_core2;

    configASSERT_core2( pxTimeOut_core2 );
    configASSERT_core2( pxTicksToWait_core2 );

    taskENTER_CRITICAL_core2();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t_core2 xConstTickCount_core2 = xTickCount_core2;
        const TickType_t_core2 xElapsedTime = xConstTickCount_core2 - pxTimeOut_core2->xTimeOnEntering_core2;

        #if ( INCLUDE_xTaskAbortDelay_core2 == 1 )
            if( pxCurrentTCB_core2->ucDelayAborted_core2 != ( uint8_t ) pdFALSE_core2 )
            {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB_core2->ucDelayAborted_core2 = pdFALSE_core2;
                xReturn_core2 = pdTRUE_core2;
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend_core2 == 1 )
            if( *pxTicksToWait_core2 == portMAX_DELAY_core2 )
            {
                /* If INCLUDE_vTaskSuspend_core2 is set to 1 and the block time
                 * specified is the maximum block time then the task_core2 should block
                 * indefinitely, and therefore never time out. */
                xReturn_core2 = pdFALSE_core2;
            }
            else
        #endif

        if( ( xNumOfOverflows_core2 != pxTimeOut_core2->xOverflowCount_core2 ) && ( xConstTickCount_core2 >= pxTimeOut_core2->xTimeOnEntering_core2 ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
        {
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn_core2 = pdTRUE_core2;
            *pxTicksToWait_core2 = ( TickType_t_core2 ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait_core2 ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait_core2 -= xElapsedTime;
            vTaskInternalSetTimeOutState_core2( pxTimeOut_core2 );
            xReturn_core2 = pdFALSE_core2;
        }
        else
        {
            *pxTicksToWait_core2 = ( TickType_t_core2 ) 0;
            xReturn_core2 = pdTRUE_core2;
        }
    }
    taskEXIT_CRITICAL_core2();

    return xReturn_core2;
}
/*-----------------------------------------------------------*/

void vTaskMissedYield_core2( void )
{
    xYieldPending_core2 = pdTRUE_core2;
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY_core2 == 1 )

    UBaseType_t_core2 uxTaskGetTaskNumber_core2( TaskHandle_t_core2 xTask_core2 )
    {
        UBaseType_t_core2 uxReturn_core2;
        TCB_t_core2 const * pxTCB_core2;

        if( xTask_core2 != NULL )
        {
            pxTCB_core2 = xTask_core2;
            uxReturn_core2 = pxTCB_core2->uxTaskNumber_core2;
        }
        else
        {
            uxReturn_core2 = 0U;
        }

        return uxReturn_core2;
    }

#endif /* configUSE_TRACE_FACILITY_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY_core2 == 1 )

    void vTaskSetTaskNumber_core2( TaskHandle_t_core2 xTask_core2,
                             const UBaseType_t_core2 uxHandle_core2 )
    {
        TCB_t_core2 * pxTCB_core2;

        if( xTask_core2 != NULL )
        {
            pxTCB_core2 = xTask_core2;
            pxTCB_core2->uxTaskNumber_core2 = uxHandle_core2;
        }
    }

#endif /* configUSE_TRACE_FACILITY_core2 */

/*
 * -----------------------------------------------------------
 * The Idle task_core2.
 * ----------------------------------------------------------
 *
 * The portTASK_FUNCTION_core2() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask_core2( void *pvParameters_core2 );
 *
 */
static portTASK_FUNCTION_core2( prvIdleTask_core2, pvParameters_core2 )
{
    /* Stop warnings. */
    ( void ) pvParameters_core2;

    /** THIS IS THE RTOS IDLE_core2 TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
     * SCHEDULER IS STARTED. **/

    /* In case a task_core2 that has a secure context deletes itself, in which case
     * the idle task_core2 is responsible for deleting the task_core2's secure context, if
     * any. */
    portALLOCATE_SECURE_CONTEXT_core2( configMINIMAL_SECURE_STACK_SIZE );

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task_core2
         * is responsible for freeing the deleted task_core2's TCB and stack. */
        prvCheckTasksWaitingTermination_core2();

        #if ( configUSE_PREEMPTION_core2 == 0 )
        {
            /* If we are not using preemption we keep forcing a task_core2 switch to
             * see if any other task_core2 has become available.  If we are using
             * preemption we don't need to do this as any task_core2 becoming available
             * will automatically get the processor anyway. */
            taskYIELD_core2();
        }
        #endif /* configUSE_PREEMPTION_core2 */

        #if ( ( configUSE_PREEMPTION_core2 == 1 ) && ( configIDLE_SHOULD_YIELD_core2 == 1 ) )
        {
            /* When using preemption tasks of equal priority will be
             * timesliced.  If a task_core2 that is sharing the idle priority is ready
             * to run then the idle task_core2 should yield before the end of the
             * timeslice.
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task_core2
             * then a task_core2 other than the idle task_core2 is ready to execute. */
            if( listCURRENT_LIST_LENGTH_core2( &( pxReadyTasksLists_core2[ tskIDLE_PRIORITY_core2 ] ) ) > ( UBaseType_t_core2 ) 1 )
            {
                taskYIELD_core2();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        #endif /* ( ( configUSE_PREEMPTION_core2 == 1 ) && ( configIDLE_SHOULD_YIELD_core2 == 1 ) ) */

        #if ( configUSE_IDLE_HOOK_core2 == 1 )
        {
            extern void vApplicationIdleHook_core2( void );

            /* Call the user defined function from within the idle task_core2.  This
             * allows the application designer to add background functionality
             * without the overhead of a separate task_core2.
             * NOTE: vApplicationIdleHook_core2() MUST NOT, UNDER ANY CIRCUMSTANCES,
             * CALL A FUNCTION THAT MIGHT BLOCK. */
            vApplicationIdleHook_core2();
        }
        #endif /* configUSE_IDLE_HOOK_core2 */

        /* This conditional compilation should use inequality to 0, not equality
         * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP_core2() is called when
         * user defined low power mode  implementations require
         * configUSE_TICKLESS_IDLE_core2 to be set to a value other than 1. */
        #if ( configUSE_TICKLESS_IDLE_core2 != 0 )
        {
            TickType_t_core2 xExpectedIdleTime_core2;

            /* It is not desirable to suspend then resume the scheduler on
             * each iteration of the idle task_core2.  Therefore, a preliminary
             * test of the expected idle time is performed without the
             * scheduler suspended.  The result here is not necessarily
             * valid. */
            xExpectedIdleTime_core2 = prvGetExpectedIdleTime_core2();

            if( xExpectedIdleTime_core2 >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP_core2 )
            {
                vTaskSuspendAll_core2();
                {
                    /* Now the scheduler is suspended, the expected idle
                     * time can be sampled again, and this time its value can
                     * be used. */
                    configASSERT_core2( xNextTaskUnblockTime_core2 >= xTickCount_core2 );
                    xExpectedIdleTime_core2 = prvGetExpectedIdleTime_core2();

                    /* Define the following macro to set xExpectedIdleTime_core2 to 0
                     * if the application does not want
                     * portSUPPRESS_TICKS_AND_SLEEP_core2() to be called. */
                    configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING_core2( xExpectedIdleTime_core2 );

                    if( xExpectedIdleTime_core2 >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP_core2 )
                    {
                        traceLOW_POWER_IDLE_BEGIN_core2();
                        portSUPPRESS_TICKS_AND_SLEEP_core2( xExpectedIdleTime_core2 );
                        traceLOW_POWER_IDLE_END_core2();
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }
                ( void ) xTaskResumeAll_core2();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        #endif /* configUSE_TICKLESS_IDLE_core2 */
    }
}
/*-----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE_core2 != 0 )

    eSleepModeStatus_core2 eTaskConfirmSleepModeStatus_core2( void )
    {
        #if ( INCLUDE_vTaskSuspend_core2 == 1 )
            /* The idle task_core2 exists in addition to the application tasks. */
            const UBaseType_t_core2 uxNonApplicationTasks = 1;
        #endif /* INCLUDE_vTaskSuspend_core2 */

        eSleepModeStatus_core2 eReturn_core2 = eStandardSleep_core2;

        /* This function must be called from a critical section. */

        if( listCURRENT_LIST_LENGTH_core2( &xPendingReadyList_core2 ) != 0 )
        {
            /* A task_core2 was made ready while the scheduler was suspended. */
            eReturn_core2 = eAbortSleep_core2;
        }
        else if( xYieldPending_core2 != pdFALSE_core2 )
        {
            /* A yield was pended while the scheduler was suspended. */
            eReturn_core2 = eAbortSleep_core2;
        }
        else if( xPendedTicks_core2 != 0 )
        {
            /* A tick interrupt has already occurred but was held pending
             * because the scheduler is suspended. */
            eReturn_core2 = eAbortSleep_core2;
        }

        #if ( INCLUDE_vTaskSuspend_core2 == 1 )
            else if( listCURRENT_LIST_LENGTH_core2( &xSuspendedTaskList_core2 ) == ( uxCurrentNumberOfTasks_core2 - uxNonApplicationTasks ) )
            {
                /* If all the tasks are in the suspended list (which might mean they
                 * have an infinite block time rather than actually being suspended)
                 * then it is safe to turn all clocks off and just wait for external
                 * interrupts. */
                eReturn_core2 = eNoTasksWaitingTimeout_core2;
            }
        #endif /* INCLUDE_vTaskSuspend_core2 */
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return eReturn_core2;
    }

#endif /* configUSE_TICKLESS_IDLE_core2 */
/*-----------------------------------------------------------*/

#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 != 0 )

    void vTaskSetThreadLocalStoragePointer_core2( TaskHandle_t_core2 xTaskToSet_core2,
                                            BaseType_t_core2 xIndex_core2,
                                            void * pvValue_core2 )
    {
        TCB_t_core2 * pxTCB_core2;

        if( ( xIndex_core2 >= 0 ) &&
            ( xIndex_core2 < configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 ) )
        {
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTaskToSet_core2 );
            configASSERT_core2( pxTCB_core2 != NULL );
            pxTCB_core2->pvThreadLocalStoragePointers_core2[ xIndex_core2 ] = pvValue_core2;
        }
    }

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 */
/*-----------------------------------------------------------*/

#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 != 0 )

    void * pvTaskGetThreadLocalStoragePointer_core2( TaskHandle_t_core2 xTaskToQuery_core2,
                                               BaseType_t_core2 xIndex_core2 )
    {
        void * pvReturn_core2 = NULL;
        TCB_t_core2 * pxTCB_core2;

        if( ( xIndex_core2 >= 0 ) &&
            ( xIndex_core2 < configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 ) )
        {
            pxTCB_core2 = prvGetTCBFromHandle_core2( xTaskToQuery_core2 );
            pvReturn_core2 = pxTCB_core2->pvThreadLocalStoragePointers_core2[ xIndex_core2 ];
        }
        else
        {
            pvReturn_core2 = NULL;
        }

        return pvReturn_core2;
    }

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS_core2 */
/*-----------------------------------------------------------*/

#if ( portUSING_MPU_WRAPPERS_core2 == 1 )

    void vTaskAllocateMPURegions_core2( TaskHandle_t_core2 xTaskToModify,
                                  const MemoryRegion_t_core2 * const xRegions_core2 )
    {
        TCB_t_core2 * pxTCB_core2;

        /* If null is passed in here then we are modifying the MPU settings of
         * the calling task_core2. */
        pxTCB_core2 = prvGetTCBFromHandle_core2( xTaskToModify );

        vPortStoreTaskMPUSettings_core2( &( pxTCB_core2->xMPUSettings_core2 ), xRegions_core2, NULL, 0 );
    }

#endif /* portUSING_MPU_WRAPPERS_core2 */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists_core2( void )
{
    UBaseType_t_core2 uxPriority_core2;

    for( uxPriority_core2 = ( UBaseType_t_core2 ) 0U; uxPriority_core2 < ( UBaseType_t_core2 ) configMAX_PRIORITIES_core2; uxPriority_core2++ )
    {
        vListInitialise_core2( &( pxReadyTasksLists_core2[ uxPriority_core2 ] ) );
    }

    vListInitialise_core2( &xDelayedTaskList1_core2 );
    vListInitialise_core2( &xDelayedTaskList2_core2 );
    vListInitialise_core2( &xPendingReadyList_core2 );

    #if ( INCLUDE_vTaskDelete_core2 == 1 )
    {
        vListInitialise_core2( &xTasksWaitingTermination_core2 );
    }
    #endif /* INCLUDE_vTaskDelete_core2 */

    #if ( INCLUDE_vTaskSuspend_core2 == 1 )
    {
        vListInitialise_core2( &xSuspendedTaskList_core2 );
    }
    #endif /* INCLUDE_vTaskSuspend_core2 */

    /* Start with pxDelayedTaskList_core2 using list1 and the pxOverflowDelayedTaskList_core2
     * using list2. */
    pxDelayedTaskList_core2 = &xDelayedTaskList1_core2;
    pxOverflowDelayedTaskList_core2 = &xDelayedTaskList2_core2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination_core2( void )
{
    /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE_core2 TASK **/

    #if ( INCLUDE_vTaskDelete_core2 == 1 )
    {
        TCB_t_core2 * pxTCB_core2;

        /* uxDeletedTasksWaitingCleanUp_core2 is used to prevent taskENTER_CRITICAL_core2()
         * being called too often in the idle task_core2. */
        while( uxDeletedTasksWaitingCleanUp_core2 > ( UBaseType_t_core2 ) 0U )
        {
            taskENTER_CRITICAL_core2();
            {
                pxTCB_core2 = listGET_OWNER_OF_HEAD_ENTRY_core2( ( &xTasksWaitingTermination_core2 ) ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                ( void ) uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                --uxCurrentNumberOfTasks_core2;
                --uxDeletedTasksWaitingCleanUp_core2;
            }
            taskEXIT_CRITICAL_core2();

            prvDeleteTCB_core2( pxTCB_core2 );
        }
    }
    #endif /* INCLUDE_vTaskDelete_core2 */
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY_core2 == 1 )

    void vTaskGetInfo_core2( TaskHandle_t_core2 xTask_core2,
                       TaskStatus_t_core2 * pxTaskStatus_core2,
                       BaseType_t_core2 xGetFreeStackSpace_core2,
                       eTaskState_core2 eState_core2 )
    {
        TCB_t_core2 * pxTCB_core2;

        /* xTask_core2 is NULL then get the state of the calling task_core2. */
        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        pxTaskStatus_core2->xHandle_core2 = ( TaskHandle_t_core2 ) pxTCB_core2;
        pxTaskStatus_core2->pcTaskName_core2 = ( const char * ) &( pxTCB_core2->pcTaskName_core2[ 0 ] );
        pxTaskStatus_core2->uxCurrentPriority_core2 = pxTCB_core2->uxPriority_core2;
        pxTaskStatus_core2->pxStackBase_core2 = pxTCB_core2->pxStack_core2;
        #if ( ( portSTACK_GROWTH_core2 > 0 ) && ( configRECORD_STACK_HIGH_ADDRESS_core2 == 1 ) )
            pxTaskStatus_core2->pxTopOfStack_core2 = pxTCB_core2->pxTopOfStack_core2;
            pxTaskStatus_core2->pxEndOfStack_core2 = pxTCB_core2->pxEndOfStack_core2;
        #endif
        pxTaskStatus_core2->xTaskNumber_core2 = pxTCB_core2->uxTCBNumber_core2;

        #if ( configUSE_MUTEXES_core2 == 1 )
        {
            pxTaskStatus_core2->uxBasePriority_core2 = pxTCB_core2->uxBasePriority_core2;
        }
        #else
        {
            pxTaskStatus_core2->uxBasePriority_core2 = 0;
        }
        #endif

        #if ( configGENERATE_RUN_TIME_STATS_core2 == 1 )
        {
            pxTaskStatus_core2->ulRunTimeCounter_core2 = pxTCB_core2->ulRunTimeCounter_core2;
        }
        #else
        {
            pxTaskStatus_core2->ulRunTimeCounter_core2 = ( configRUN_TIME_COUNTER_TYPE_core2 ) 0;
        }
        #endif

        /* Obtaining the task_core2 state is a little fiddly, so is only done if the
         * value of eState_core2 passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. */
        if( eState_core2 != eInvalid )
        {
            if( pxTCB_core2 == pxCurrentTCB_core2 )
            {
                pxTaskStatus_core2->eCurrentState_core2 = eRunning_core2;
            }
            else
            {
                pxTaskStatus_core2->eCurrentState_core2 = eState_core2;

                #if ( INCLUDE_vTaskSuspend_core2 == 1 )
                {
                    /* If the task_core2 is in the suspended list then there is a
                     *  chance it is actually just blocked indefinitely - so really
                     *  it should be reported as being in the Blocked state. */
                    if( eState_core2 == eSuspended_core2 )
                    {
                        vTaskSuspendAll_core2();
                        {
                            if( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) != NULL )
                            {
                                pxTaskStatus_core2->eCurrentState_core2 = eBlocked_core2;
                            }
                        }
                        ( void ) xTaskResumeAll_core2();
                    }
                }
                #endif /* INCLUDE_vTaskSuspend_core2 */
            }
        }
        else
        {
            pxTaskStatus_core2->eCurrentState_core2 = eTaskGetState_core2( pxTCB_core2 );
        }

        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace_core2
         * parameter is provided to allow it to be skipped. */
        if( xGetFreeStackSpace_core2 != pdFALSE_core2 )
        {
            #if ( portSTACK_GROWTH_core2 > 0 )
            {
                pxTaskStatus_core2->usStackHighWaterMark_core2 = prvTaskCheckFreeStackSpace_core2( ( uint8_t * ) pxTCB_core2->pxEndOfStack_core2 );
            }
            #else
            {
                pxTaskStatus_core2->usStackHighWaterMark_core2 = prvTaskCheckFreeStackSpace_core2( ( uint8_t * ) pxTCB_core2->pxStack_core2 );
            }
            #endif
        }
        else
        {
            pxTaskStatus_core2->usStackHighWaterMark_core2 = 0;
        }
    }

#endif /* configUSE_TRACE_FACILITY_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY_core2 == 1 )

    static UBaseType_t_core2 prvListTasksWithinSingleList_core2( TaskStatus_t_core2 * pxTaskStatusArray_core2,
                                                     List_t_core2 * pxList_core2,
                                                     eTaskState_core2 eState_core2 )
    {
        configLIST_VOLATILE_core2 TCB_t_core2 * pxNextTCB_core2;
        configLIST_VOLATILE_core2 TCB_t_core2 * pxFirstTCB_core2;
        UBaseType_t_core2 uxTask_core2 = 0;

        if( listCURRENT_LIST_LENGTH_core2( pxList_core2 ) > ( UBaseType_t_core2 ) 0 )
        {
            listGET_OWNER_OF_NEXT_ENTRY_core2( pxFirstTCB_core2, pxList_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */

            /* Populate an TaskStatus_t_core2 structure within the
             * pxTaskStatusArray_core2 array for each task_core2 that is referenced from
             * pxList_core2.  See the definition of TaskStatus_t_core2 in task_core2.h for the
             * meaning of each TaskStatus_t_core2 structure member. */
            do
            {
                listGET_OWNER_OF_NEXT_ENTRY_core2( pxNextTCB_core2, pxList_core2 ); /*lint !e9079 void * is used as this macro is used with timers_core2 and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                vTaskGetInfo_core2( ( TaskHandle_t_core2 ) pxNextTCB_core2, &( pxTaskStatusArray_core2[ uxTask_core2 ] ), pdTRUE_core2, eState_core2 );
                uxTask_core2++;
            } while( pxNextTCB_core2 != pxFirstTCB_core2 );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return uxTask_core2;
    }

#endif /* configUSE_TRACE_FACILITY_core2 */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2_core2 == 1 ) )

    static configSTACK_DEPTH_TYPE_core2 prvTaskCheckFreeStackSpace_core2( const uint8_t * pucStackByte_core2 )
    {
        uint32_t ulCount_core2 = 0U;

        while( *pucStackByte_core2 == ( uint8_t ) tskSTACK_FILL_BYTE_core2 )
        {
            pucStackByte_core2 -= portSTACK_GROWTH_core2;
            ulCount_core2++;
        }

        ulCount_core2 /= ( uint32_t ) sizeof( StackType_t_core2 ); /*lint !e961 Casting is not redundant on smaller architectures. */

        return ( configSTACK_DEPTH_TYPE_core2 ) ulCount_core2;
    }

#endif /* ( ( configUSE_TRACE_FACILITY_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark_core2 == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2_core2 == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark2_core2 == 1 )

/* uxTaskGetStackHighWaterMark_core2() and uxTaskGetStackHighWaterMark2_core2() are the
 * same except for their return type.  Using configSTACK_DEPTH_TYPE_core2 allows the
 * user to determine the return type.  It gets around the problem of the value
 * overflowing on 8-bit types without breaking backward compatibility for
 * applications that expect an 8-bit return type. */
    configSTACK_DEPTH_TYPE_core2 uxTaskGetStackHighWaterMark2_core2( TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        uint8_t * pucEndOfStack;
        configSTACK_DEPTH_TYPE_core2 uxReturn_core2;

        /* uxTaskGetStackHighWaterMark_core2() and uxTaskGetStackHighWaterMark2_core2() are
         * the same except for their return type.  Using configSTACK_DEPTH_TYPE_core2
         * allows the user to determine the return type.  It gets around the
         * problem of the value overflowing on 8-bit types without breaking
         * backward compatibility for applications that expect an 8-bit return
         * type. */

        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        #if portSTACK_GROWTH_core2 < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB_core2->pxStack_core2;
        }
        #else
        {
            pucEndOfStack = ( uint8_t * ) pxTCB_core2->pxEndOfStack_core2;
        }
        #endif

        uxReturn_core2 = prvTaskCheckFreeStackSpace_core2( pucEndOfStack );

        return uxReturn_core2;
    }

#endif /* INCLUDE_uxTaskGetStackHighWaterMark2_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark_core2 == 1 )

    UBaseType_t_core2 uxTaskGetStackHighWaterMark_core2( TaskHandle_t_core2 xTask_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        uint8_t * pucEndOfStack;
        UBaseType_t_core2 uxReturn_core2;

        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        #if portSTACK_GROWTH_core2 < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB_core2->pxStack_core2;
        }
        #else
        {
            pucEndOfStack = ( uint8_t * ) pxTCB_core2->pxEndOfStack_core2;
        }
        #endif

        uxReturn_core2 = ( UBaseType_t_core2 ) prvTaskCheckFreeStackSpace_core2( pucEndOfStack );

        return uxReturn_core2;
    }

#endif /* INCLUDE_uxTaskGetStackHighWaterMark_core2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete_core2 == 1 )

    static void prvDeleteTCB_core2( TCB_t_core2 * pxTCB_core2 )
    {
        /* This call is required specifically for the TriCore port.  It must be
         * above the vPortFree_core2() calls.  The call is also used by ports/demos that
         * want to allocate and clean RAM statically. */
        portCLEAN_UP_TCB_core2( pxTCB_core2 );

        #if ( ( configUSE_NEWLIB_REENTRANT_core2 == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT_core2 == 1 ) )
        {
            /* Free up the memory allocated for the task_core2's TLS Block. */
            configDEINIT_TLS_BLOCK_core2( pxCurrentTCB_core2->xTLSBlock_core2 );
        }
        #endif

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION_core2 == 1 ) && ( configSUPPORT_STATIC_ALLOCATION_core2 == 0 ) && ( portUSING_MPU_WRAPPERS_core2 == 0 ) )
        {
            /* The task_core2 can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack_core2( pxTCB_core2->pxStack_core2 );
            vPortFree_core2( pxTCB_core2 );
        }
        #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE_core2 != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
        {
            /* The task_core2 could have been allocated statically or dynamically, so
             * check what was statically allocated before trying to free the
             * memory. */
            if( pxTCB_core2->ucStaticallyAllocated_core2 == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB_core2 )
            {
                /* Both the stack and TCB were allocated dynamically, so both
                 * must be freed. */
                vPortFreeStack_core2( pxTCB_core2->pxStack_core2 );
                vPortFree_core2( pxTCB_core2 );
            }
            else if( pxTCB_core2->ucStaticallyAllocated_core2 == tskSTATICALLY_ALLOCATED_STACK_ONLY_core2 )
            {
                /* Only the stack was statically allocated, so the TCB is the
                 * only memory that must be freed. */
                vPortFree_core2( pxTCB_core2 );
            }
            else
            {
                /* Neither the stack nor the TCB were allocated dynamically, so
                 * nothing needs to be freed. */
                configASSERT_core2( pxTCB_core2->ucStaticallyAllocated_core2 == tskSTATICALLY_ALLOCATED_STACK_AND_TCB_core2 );
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION_core2 */
    }

#endif /* INCLUDE_vTaskDelete_core2 */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime_core2( void )
{
    if( listLIST_IS_EMPTY_core2( pxDelayedTaskList_core2 ) != pdFALSE_core2 )
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime_core2 to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount_core2 >= xNextTaskUnblockTime_core2 ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime_core2 = portMAX_DELAY_core2;
    }
    else
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task_core2 at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime_core2 = listGET_ITEM_VALUE_OF_HEAD_ENTRY_core2( pxDelayedTaskList_core2 );
    }
}
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle_core2 == 1 ) || ( configUSE_MUTEXES_core2 == 1 ) )

    TaskHandle_t_core2 xTaskGetCurrentTaskHandle_core2( void )
    {
        TaskHandle_t_core2 xReturn_core2;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn_core2 = pxCurrentTCB_core2;

        return xReturn_core2;
    }

#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle_core2 == 1 ) || ( configUSE_MUTEXES_core2 == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState_core2 == 1 ) || ( configUSE_TIMERS_core2 == 1 ) )

    BaseType_t_core2 xTaskGetSchedulerState_core2( void )
    {
        BaseType_t_core2 xReturn_core2;

        if( xSchedulerRunning_core2 == pdFALSE_core2 )
        {
            xReturn_core2 = taskSCHEDULER_NOT_STARTED_core2;
        }
        else
        {
            if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
            {
                xReturn_core2 = taskSCHEDULER_RUNNING_core2;
            }
            else
            {
                xReturn_core2 = taskSCHEDULER_SUSPENDED_core2;
            }
        }

        return xReturn_core2;
    }

#endif /* ( ( INCLUDE_xTaskGetSchedulerState_core2 == 1 ) || ( configUSE_TIMERS_core2 == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES_core2 == 1 )

    BaseType_t_core2 xTaskPriorityInherit_core2( TaskHandle_t_core2 const pxMutexHolder_core2 )
    {
        TCB_t_core2 * const pxMutexHolderTCB = pxMutexHolder_core2;
        BaseType_t_core2 xReturn_core2 = pdFALSE_core2;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder_core2 != NULL )
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task_core2 attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task_core2 attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority_core2 < pxCurrentTCB_core2->uxPriority_core2 )
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE_core2( &( pxMutexHolderTCB->xEventListItem_core2 ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE_core2 ) == 0UL )
                {
                    listSET_LIST_ITEM_VALUE_core2( &( pxMutexHolderTCB->xEventListItem_core2 ), ( TickType_t_core2 ) configMAX_PRIORITIES_core2 - ( TickType_t_core2 ) pxCurrentTCB_core2->uxPriority_core2 ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }

                /* If the task_core2 being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN_core2( &( pxReadyTasksLists_core2[ pxMutexHolderTCB->uxPriority_core2 ] ), &( pxMutexHolderTCB->xStateListItem_core2 ) ) != pdFALSE_core2 )
                {
                    if( uxListRemove_core2( &( pxMutexHolderTCB->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
                    {
                        /* It is known that the task_core2 is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. */
                        portRESET_READY_PRIORITY_core2( pxMutexHolderTCB->uxPriority_core2, uxTopReadyPriority_core2 );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority_core2 = pxCurrentTCB_core2->uxPriority_core2;
                    prvAddTaskToReadyList_core2( pxMutexHolderTCB );
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority_core2 = pxCurrentTCB_core2->uxPriority_core2;
                }

                traceTASK_PRIORITY_INHERIT_core2( pxMutexHolderTCB, pxCurrentTCB_core2->uxPriority_core2 );

                /* Inheritance occurred. */
                xReturn_core2 = pdTRUE_core2;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority_core2 < pxCurrentTCB_core2->uxPriority_core2 )
                {
                    /* The base priority of the mutex holder is lower than the
                     * priority of the task_core2 attempting to take the mutex, but the
                     * current priority of the mutex holder is not lower than the
                     * priority of the task_core2 attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return xReturn_core2;
    }

#endif /* configUSE_MUTEXES_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES_core2 == 1 )

    BaseType_t_core2 xTaskPriorityDisinherit_core2( TaskHandle_t_core2 const pxMutexHolder_core2 )
    {
        TCB_t_core2 * const pxTCB_core2 = pxMutexHolder_core2;
        BaseType_t_core2 xReturn_core2 = pdFALSE_core2;

        if( pxMutexHolder_core2 != NULL )
        {
            /* A task_core2 can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task_core2 then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task_core2 then it must
             * be the running state task_core2. */
            configASSERT_core2( pxTCB_core2 == pxCurrentTCB_core2 );
            configASSERT_core2( pxTCB_core2->uxMutexesHeld_core2 );
            ( pxTCB_core2->uxMutexesHeld_core2 )--;

            /* Has the holder of the mutex inherited the priority of another
             * task_core2? */
            if( pxTCB_core2->uxPriority_core2 != pxTCB_core2->uxBasePriority_core2 )
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB_core2->uxMutexesHeld_core2 == ( UBaseType_t_core2 ) 0 )
                {
                    /* A task_core2 can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task_core2 then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task_core2 then it must be the running state task_core2.  Remove
                     * the holding task_core2 from the ready list. */
                    if( uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
                    {
                        portRESET_READY_PRIORITY_core2( pxTCB_core2->uxPriority_core2, uxTopReadyPriority_core2 );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    /* Disinherit the priority before adding the task_core2 into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT_core2( pxTCB_core2, pxTCB_core2->uxBasePriority_core2 );
                    pxTCB_core2->uxPriority_core2 = pxTCB_core2->uxBasePriority_core2;

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task_core2 is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE_core2( &( pxTCB_core2->xEventListItem_core2 ), ( TickType_t_core2 ) configMAX_PRIORITIES_core2 - ( TickType_t_core2 ) pxTCB_core2->uxPriority_core2 ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                    prvAddTaskToReadyList_core2( pxTCB_core2 );

                    /* Return true to indicate that a context switch is required.
                     * This is only actually required in the corner case whereby
                     * multiple mutexes were held and the mutexes were given back
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task_core2 was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task_core2 is waiting on it or not. */
                    xReturn_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }

        return xReturn_core2;
    }

#endif /* configUSE_MUTEXES_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES_core2 == 1 )

    void vTaskPriorityDisinheritAfterTimeout_core2( TaskHandle_t_core2 const pxMutexHolder_core2,
                                              UBaseType_t_core2 uxHighestPriorityWaitingTask_core2 )
    {
        TCB_t_core2 * const pxTCB_core2 = pxMutexHolder_core2;
        UBaseType_t_core2 uxPriorityUsedOnEntry_core2, uxPriorityToUse;
        const UBaseType_t_core2 uxOnlyOneMutexHeld = ( UBaseType_t_core2 ) 1;

        if( pxMutexHolder_core2 != NULL )
        {
            /* If pxMutexHolder_core2 is not NULL then the holder must hold at least
             * one mutex. */
            configASSERT_core2( pxTCB_core2->uxMutexesHeld_core2 );

            /* Determine the priority to which the priority of the task_core2 that
             * holds the mutex should be set.  This will be the greater of the
             * holding task_core2's base priority and the priority of the highest
             * priority task_core2 that is waiting to obtain the mutex. */
            if( pxTCB_core2->uxBasePriority_core2 < uxHighestPriorityWaitingTask_core2 )
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask_core2;
            }
            else
            {
                uxPriorityToUse = pxTCB_core2->uxBasePriority_core2;
            }

            /* Does the priority need to change? */
            if( pxTCB_core2->uxPriority_core2 != uxPriorityToUse )
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task_core2 that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB_core2->uxMutexesHeld_core2 == uxOnlyOneMutexHeld )
                {
                    /* If a task_core2 has timed out because it already holds the
                     * mutex it was trying to obtain then it cannot of inherited
                     * its own priority. */
                    configASSERT_core2( pxTCB_core2 != pxCurrentTCB_core2 );

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task_core2's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT_core2( pxTCB_core2, uxPriorityToUse );
                    uxPriorityUsedOnEntry_core2 = pxTCB_core2->uxPriority_core2;
                    pxTCB_core2->uxPriority_core2 = uxPriorityToUse;

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE_core2( &( pxTCB_core2->xEventListItem_core2 ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE_core2 ) == 0UL )
                    {
                        listSET_LIST_ITEM_VALUE_core2( &( pxTCB_core2->xEventListItem_core2 ), ( TickType_t_core2 ) configMAX_PRIORITIES_core2 - ( TickType_t_core2 ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }

                    /* If the running task_core2 is not the task_core2 that holds the mutex
                     * then the task_core2 that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task_core2
                     * from its current state list if it is in the Ready state as
                     * the task_core2's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN_core2( &( pxReadyTasksLists_core2[ uxPriorityUsedOnEntry_core2 ] ), &( pxTCB_core2->xStateListItem_core2 ) ) != pdFALSE_core2 )
                    {
                        if( uxListRemove_core2( &( pxTCB_core2->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
                        {
                            /* It is known that the task_core2 is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. */
                            portRESET_READY_PRIORITY_core2( pxTCB_core2->uxPriority_core2, uxTopReadyPriority_core2 );
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER_core2();
                        }

                        prvAddTaskToReadyList_core2( pxTCB_core2 );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER_core2();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* configUSE_MUTEXES_core2 */
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB_core2 == 1 )

    void vTaskEnterCritical( void )
    {
        portDISABLE_INTERRUPTS_core2();

        if( xSchedulerRunning_core2 != pdFALSE_core2 )
        {
            ( pxCurrentTCB_core2->uxCriticalNesting_core2 )++;

            /* This is not the interrupt safe version of the enter critical
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB_core2->uxCriticalNesting_core2 == 1 )
            {
                portASSERT_IF_IN_ISR_core2();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* portCRITICAL_NESTING_IN_TCB_core2 */
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB_core2 == 1 )

    void vTaskExitCritical( void )
    {
        if( xSchedulerRunning_core2 != pdFALSE_core2 )
        {
            if( pxCurrentTCB_core2->uxCriticalNesting_core2 > 0U )
            {
                ( pxCurrentTCB_core2->uxCriticalNesting_core2 )--;

                if( pxCurrentTCB_core2->uxCriticalNesting_core2 == 0U )
                {
                    portENABLE_INTERRUPTS_core2();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* portCRITICAL_NESTING_IN_TCB_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 )

    static char * prvWriteNameToBuffer_core2( char * pcBuffer_core2,
                                        const char * pcTaskName_core2 )
    {
        size_t x;

        /* Start by copying the entire string. */
        strcpy( pcBuffer_core2, pcTaskName_core2 );

        /* Pad the end of the string with spaces to ensure columns line up when
         * printed out. */
        for( x = strlen( pcBuffer_core2 ); x < ( size_t ) ( configMAX_TASK_NAME_LEN_core2 - 1 ); x++ )
        {
            pcBuffer_core2[ x ] = ' ';
        }

        /* Terminate. */
        pcBuffer_core2[ x ] = ( char ) 0x00;

        /* Return the new end of string. */
        return &( pcBuffer_core2[ x ] );
    }

#endif /* ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 ) */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY_core2 == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 ) )

    void vTaskList_core2( char * pcWriteBuffer_core2 )
    {
        TaskStatus_t_core2 * pxTaskStatusArray_core2;
        UBaseType_t_core2 uxArraySize_core2, x;
        char cStatus;

        /*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskList_core2() calls uxTaskGetSystemState_core2(), then formats part of the
         * uxTaskGetSystemState_core2() output into a human readable table that
         * displays task_core2: names, states, priority, stack usage and task_core2 number.
         * Stack usage specified as the number of unused StackType_t_core2 words stack can hold
         * on top of stack - not the number of bytes.
         *
         * vTaskList_core2() has a dependency on the sprintf() C library function that
         * might bloat the code size, use a lot of stack, and provide different
         * results on different platforms.  An alternative, tiny, third party,
         * and limited functionality implementation of sprintf() is provided in
         * many of the FreeRTOS_core2/Demo sub-directories in a file called
         * printf-stdarg.c (note printf-stdarg.c does not provide a full
         * snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState_core2()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskList_core2().
         */


        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer_core2 = ( char ) 0x00;

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize_core2 = uxCurrentNumberOfTasks_core2;

        /* Allocate an array index for each task_core2.  NOTE!  if
         * configSUPPORT_DYNAMIC_ALLOCATION_core2 is set to 0 then pvPortMalloc_core2() will
         * equate to NULL. */
        pxTaskStatusArray_core2 = pvPortMalloc_core2( uxCurrentNumberOfTasks_core2 * sizeof( TaskStatus_t_core2 ) ); /*lint !e9079 All values returned by pvPortMalloc_core2() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */

        if( pxTaskStatusArray_core2 != NULL )
        {
            /* Generate the (binary) data. */
            uxArraySize_core2 = uxTaskGetSystemState_core2( pxTaskStatusArray_core2, uxArraySize_core2, NULL );

            /* Create a human readable table from the binary data. */
            for( x = 0; x < uxArraySize_core2; x++ )
            {
                switch( pxTaskStatusArray_core2[ x ].eCurrentState_core2 )
                {
                    case eRunning_core2:
                        cStatus = tskRUNNING_CHAR_core2;
                        break;

                    case eReady_core2:
                        cStatus = tskREADY_CHAR_core2;
                        break;

                    case eBlocked_core2:
                        cStatus = tskBLOCKED_CHAR_core2;
                        break;

                    case eSuspended_core2:
                        cStatus = tskSUSPENDED_CHAR_core2;
                        break;

                    case eDeleted_core2:
                        cStatus = tskDELETED_CHAR_core2;
                        break;

                    case eInvalid: /* Fall through. */
                    default:       /* Should not get here, but it is included
                                    * to prevent static checking errors. */
                        cStatus = ( char ) 0x00;
                        break;
                }

                /* Write the task_core2 name to the string, padding with spaces so it
                 * can be printed in tabular form more easily. */
                pcWriteBuffer_core2 = prvWriteNameToBuffer_core2( pcWriteBuffer_core2, pxTaskStatusArray_core2[ x ].pcTaskName_core2 );

                /* Write the rest of the string. */
                sprintf( pcWriteBuffer_core2, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray_core2[ x ].uxCurrentPriority_core2, ( unsigned int ) pxTaskStatusArray_core2[ x ].usStackHighWaterMark_core2, ( unsigned int ) pxTaskStatusArray_core2[ x ].xTaskNumber_core2 ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
                pcWriteBuffer_core2 += strlen( pcWriteBuffer_core2 );                                                                                                                                                                                                /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION_core2
             * is 0 then vPortFree_core2() will be #defined to nothing. */
            vPortFree_core2( pxTaskStatusArray_core2 );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* ( ( configUSE_TRACE_FACILITY_core2 == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 ) ) */
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 ) && ( configUSE_TRACE_FACILITY_core2 == 1 ) )

    void vTaskGetRunTimeStats_core2( char * pcWriteBuffer_core2 )
    {
        TaskStatus_t_core2 * pxTaskStatusArray_core2;
        UBaseType_t_core2 uxArraySize_core2, x;
        configRUN_TIME_COUNTER_TYPE_core2 ulTotalTime, ulStatsAsPercentage;

        /*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskGetRunTimeStats_core2() calls uxTaskGetSystemState_core2(), then formats part
         * of the uxTaskGetSystemState_core2() output into a human readable table that
         * displays the amount of time each task_core2 has spent in the Running state
         * in both absolute and percentage terms.
         *
         * vTaskGetRunTimeStats_core2() has a dependency on the sprintf() C library
         * function that might bloat the code size, use a lot of stack, and
         * provide different results on different platforms.  An alternative,
         * tiny, third party, and limited functionality implementation of
         * sprintf() is provided in many of the FreeRTOS_core2/Demo sub-directories in
         * a file called printf-stdarg.c (note printf-stdarg.c does not provide
         * a full snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState_core2()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskGetRunTimeStats_core2().
         */

        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer_core2 = ( char ) 0x00;

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize_core2 = uxCurrentNumberOfTasks_core2;

        /* Allocate an array index for each task_core2.  NOTE!  If
         * configSUPPORT_DYNAMIC_ALLOCATION_core2 is set to 0 then pvPortMalloc_core2() will
         * equate to NULL. */
        pxTaskStatusArray_core2 = pvPortMalloc_core2( uxCurrentNumberOfTasks_core2 * sizeof( TaskStatus_t_core2 ) ); /*lint !e9079 All values returned by pvPortMalloc_core2() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */

        if( pxTaskStatusArray_core2 != NULL )
        {
            /* Generate the (binary) data. */
            uxArraySize_core2 = uxTaskGetSystemState_core2( pxTaskStatusArray_core2, uxArraySize_core2, &ulTotalTime );

            /* For percentage calculations. */
            ulTotalTime /= 100UL;

            /* Avoid divide by zero errors. */
            if( ulTotalTime > 0UL )
            {
                /* Create a human readable table from the binary data. */
                for( x = 0; x < uxArraySize_core2; x++ )
                {
                    /* What percentage of the total run time has the task_core2 used?
                     * This will always be rounded down to the nearest integer.
                     * ulTotalRunTime_core2 has already been divided by 100. */
                    ulStatsAsPercentage = pxTaskStatusArray_core2[ x ].ulRunTimeCounter_core2 / ulTotalTime;

                    /* Write the task_core2 name to the string, padding with
                     * spaces so it can be printed in tabular form more
                     * easily. */
                    pcWriteBuffer_core2 = prvWriteNameToBuffer_core2( pcWriteBuffer_core2, pxTaskStatusArray_core2[ x ].pcTaskName_core2 );

                    if( ulStatsAsPercentage > 0UL )
                    {
                        #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                        {
                            sprintf( pcWriteBuffer_core2, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray_core2[ x ].ulRunTimeCounter_core2, ulStatsAsPercentage );
                        }
                        #else
                        {
                            /* sizeof( int ) == sizeof( long ) so a smaller
                             * printf() library can be used. */
                            sprintf( pcWriteBuffer_core2, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray_core2[ x ].ulRunTimeCounter_core2, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
                        }
                        #endif
                    }
                    else
                    {
                        /* If the percentage is zero here then the task_core2 has
                         * consumed less than 1% of the total run time. */
                        #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                        {
                            sprintf( pcWriteBuffer_core2, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray_core2[ x ].ulRunTimeCounter_core2 );
                        }
                        #else
                        {
                            /* sizeof( int ) == sizeof( long ) so a smaller
                             * printf() library can be used. */
                            sprintf( pcWriteBuffer_core2, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray_core2[ x ].ulRunTimeCounter_core2 ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
                        }
                        #endif
                    }

                    pcWriteBuffer_core2 += strlen( pcWriteBuffer_core2 ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION_core2
             * is 0 then vPortFree_core2() will be #defined to nothing. */
            vPortFree_core2( pxTaskStatusArray_core2 );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER_core2();
        }
    }

#endif /* ( ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS_core2 > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t_core2 uxTaskResetEventItemValue_core2( void )
{
    TickType_t_core2 uxReturn_core2;

    uxReturn_core2 = listGET_LIST_ITEM_VALUE_core2( &( pxCurrentTCB_core2->xEventListItem_core2 ) );

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE_core2( &( pxCurrentTCB_core2->xEventListItem_core2 ), ( ( TickType_t_core2 ) configMAX_PRIORITIES_core2 - ( TickType_t_core2 ) pxCurrentTCB_core2->uxPriority_core2 ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn_core2;
}
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES_core2 == 1 )

    TaskHandle_t_core2 pvTaskIncrementMutexHeldCount_core2( void )
    {
        /* If xSemaphoreCreateMutex_core2() is called before any tasks have been created
         * then pxCurrentTCB_core2 will be NULL. */
        if( pxCurrentTCB_core2 != NULL )
        {
            ( pxCurrentTCB_core2->uxMutexesHeld_core2 )++;
        }

        return pxCurrentTCB_core2;
    }

#endif /* configUSE_MUTEXES_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    uint32_t ulTaskGenericNotifyTake_core2( UBaseType_t_core2 uxIndexToWait_core2,
                                      BaseType_t_core2 xClearCountOnExit_core2,
                                      TickType_t_core2 xTicksToWait_core2 )
    {
        uint32_t ulReturn;

        configASSERT_core2( uxIndexToWait_core2 < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 );

        taskENTER_CRITICAL_core2();
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ] == 0UL )
            {
                /* Mark this task_core2 as waiting for a notification. */
                pxCurrentTCB_core2->ucNotifyState_core2[ uxIndexToWait_core2 ] = taskWAITING_NOTIFICATION_core2;

                if( xTicksToWait_core2 > ( TickType_t_core2 ) 0 )
                {
                    prvAddCurrentTaskToDelayedList_core2( xTicksToWait_core2, pdTRUE_core2 );
                    traceTASK_NOTIFY_TAKE_BLOCK_core2( uxIndexToWait_core2 );

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API_core2();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        taskEXIT_CRITICAL_core2();

        taskENTER_CRITICAL_core2();
        {
            traceTASK_NOTIFY_TAKE_core2( uxIndexToWait_core2 );
            ulReturn = pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ];

            if( ulReturn != 0UL )
            {
                if( xClearCountOnExit_core2 != pdFALSE_core2 )
                {
                    pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ] = 0UL;
                }
                else
                {
                    pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ] = ulReturn - ( uint32_t ) 1;
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }

            pxCurrentTCB_core2->ucNotifyState_core2[ uxIndexToWait_core2 ] = taskNOT_WAITING_NOTIFICATION_core2;
        }
        taskEXIT_CRITICAL_core2();

        return ulReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    BaseType_t_core2 xTaskGenericNotifyWait_core2( UBaseType_t_core2 uxIndexToWait_core2,
                                       uint32_t ulBitsToClearOnEntry_core2,
                                       uint32_t ulBitsToClearOnExit_core2,
                                       uint32_t * pulNotificationValue_core2,
                                       TickType_t_core2 xTicksToWait_core2 )
    {
        BaseType_t_core2 xReturn_core2;

        configASSERT_core2( uxIndexToWait_core2 < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 );

        taskENTER_CRITICAL_core2();
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB_core2->ucNotifyState_core2[ uxIndexToWait_core2 ] != taskNOTIFICATION_RECEIVED_core2 )
            {
                /* Clear bits in the task_core2's notification value as bits may get
                 * set  by the notifying task_core2 or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ] &= ~ulBitsToClearOnEntry_core2;

                /* Mark this task_core2 as waiting for a notification. */
                pxCurrentTCB_core2->ucNotifyState_core2[ uxIndexToWait_core2 ] = taskWAITING_NOTIFICATION_core2;

                if( xTicksToWait_core2 > ( TickType_t_core2 ) 0 )
                {
                    prvAddCurrentTaskToDelayedList_core2( xTicksToWait_core2, pdTRUE_core2 );
                    traceTASK_NOTIFY_WAIT_BLOCK_core2( uxIndexToWait_core2 );

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API_core2();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        taskEXIT_CRITICAL_core2();

        taskENTER_CRITICAL_core2();
        {
            traceTASK_NOTIFY_WAIT_core2( uxIndexToWait_core2 );

            if( pulNotificationValue_core2 != NULL )
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue_core2 = pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ];
            }

            /* If ucNotifyValue is set then either the task_core2 never entered the
             * blocked state (because a notification was already pending) or the
             * task_core2 unblocked because of a notification.  Otherwise the task_core2
             * unblocked because of a timeout. */
            if( pxCurrentTCB_core2->ucNotifyState_core2[ uxIndexToWait_core2 ] != taskNOTIFICATION_RECEIVED_core2 )
            {
                /* A notification was not received. */
                xReturn_core2 = pdFALSE_core2;
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task_core2 was waiting. */
                pxCurrentTCB_core2->ulNotifiedValue_core2[ uxIndexToWait_core2 ] &= ~ulBitsToClearOnExit_core2;
                xReturn_core2 = pdTRUE_core2;
            }

            pxCurrentTCB_core2->ucNotifyState_core2[ uxIndexToWait_core2 ] = taskNOT_WAITING_NOTIFICATION_core2;
        }
        taskEXIT_CRITICAL_core2();

        return xReturn_core2;
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    BaseType_t_core2 xTaskGenericNotify_core2( TaskHandle_t_core2 xTaskToNotify_core2,
                                   UBaseType_t_core2 uxIndexToNotify_core2,
                                   uint32_t ulValue_core2,
                                   eNotifyAction_core2 eAction_core2,
                                   uint32_t * pulPreviousNotificationValue_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        BaseType_t_core2 xReturn_core2 = pdPASS_core2;
        uint8_t ucOriginalNotifyState;

        configASSERT_core2( uxIndexToNotify_core2 < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 );
        configASSERT_core2( xTaskToNotify_core2 );
        pxTCB_core2 = xTaskToNotify_core2;

        taskENTER_CRITICAL_core2();
        {
            if( pulPreviousNotificationValue_core2 != NULL )
            {
                *pulPreviousNotificationValue_core2 = pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ];
            }

            ucOriginalNotifyState = pxTCB_core2->ucNotifyState_core2[ uxIndexToNotify_core2 ];

            pxTCB_core2->ucNotifyState_core2[ uxIndexToNotify_core2 ] = taskNOTIFICATION_RECEIVED_core2;

            switch( eAction_core2 )
            {
                case eSetBits_core2:
                    pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] |= ulValue_core2;
                    break;

                case eIncrement_core2:
                    ( pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] )++;
                    break;

                case eSetValueWithOverwrite_core2:
                    pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] = ulValue_core2;
                    break;

                case eSetValueWithoutOverwrite_core2:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED_core2 )
                    {
                        pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] = ulValue_core2;
                    }
                    else
                    {
                        /* The value could not be written to the task_core2. */
                        xReturn_core2 = pdFAIL_core2;
                    }

                    break;

                case eNoAction_core2:

                    /* The task_core2 is being notified without its notify value being
                     * updated. */
                    break;

                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT_core2( xTickCount_core2 == ( TickType_t_core2 ) 0 );

                    break;
            }

            traceTASK_NOTIFY_core2( uxIndexToNotify_core2 );

            /* If the task_core2 is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION_core2 )
            {
                listREMOVE_ITEM_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                prvAddTaskToReadyList_core2( pxTCB_core2 );

                /* The task_core2 should not have been on an event list. */
                configASSERT_core2( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) == NULL );

                #if ( configUSE_TICKLESS_IDLE_core2 != 0 )
                {
                    /* If a task_core2 is blocked waiting for a notification then
                     * xNextTaskUnblockTime_core2 might be set to the blocked task_core2's time
                     * out time.  If the task_core2 is unblocked for a reason other than
                     * a timeout xNextTaskUnblockTime_core2 is normally left unchanged,
                     * because it will automatically get reset to a new value when
                     * the tick count equals xNextTaskUnblockTime_core2.  However if
                     * tickless idling is used it might be more important to enter
                     * sleep mode at the earliest possible time - so reset
                     * xNextTaskUnblockTime_core2 here to ensure it is updated at the
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime_core2();
                }
                #endif

                if( pxTCB_core2->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
                {
                    /* The notified task_core2 has a priority above the currently
                     * executing task_core2 so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION_core2();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }
        taskEXIT_CRITICAL_core2();

        return xReturn_core2;
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    BaseType_t_core2 xTaskGenericNotifyFromISR_core2( TaskHandle_t_core2 xTaskToNotify_core2,
                                          UBaseType_t_core2 uxIndexToNotify_core2,
                                          uint32_t ulValue_core2,
                                          eNotifyAction_core2 eAction_core2,
                                          uint32_t * pulPreviousNotificationValue_core2,
                                          BaseType_t_core2 * pxHigherPriorityTaskWoken_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        uint8_t ucOriginalNotifyState;
        BaseType_t_core2 xReturn_core2 = pdPASS_core2;
        UBaseType_t_core2 uxSavedInterruptStatus_core2;

        configASSERT_core2( xTaskToNotify_core2 );
        configASSERT_core2( uxIndexToNotify_core2 < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS_core2 API functions.  If configASSERT_core2()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2() will result in an assertion
         * failure if a FreeRTOS_core2 API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS_core2 functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS_core2 maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS_core2.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2();

        pxTCB_core2 = xTaskToNotify_core2;

        uxSavedInterruptStatus_core2 = portSET_INTERRUPT_MASK_FROM_ISR_core2();
        {
            if( pulPreviousNotificationValue_core2 != NULL )
            {
                *pulPreviousNotificationValue_core2 = pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ];
            }

            ucOriginalNotifyState = pxTCB_core2->ucNotifyState_core2[ uxIndexToNotify_core2 ];
            pxTCB_core2->ucNotifyState_core2[ uxIndexToNotify_core2 ] = taskNOTIFICATION_RECEIVED_core2;

            switch( eAction_core2 )
            {
                case eSetBits_core2:
                    pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] |= ulValue_core2;
                    break;

                case eIncrement_core2:
                    ( pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] )++;
                    break;

                case eSetValueWithOverwrite_core2:
                    pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] = ulValue_core2;
                    break;

                case eSetValueWithoutOverwrite_core2:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED_core2 )
                    {
                        pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] = ulValue_core2;
                    }
                    else
                    {
                        /* The value could not be written to the task_core2. */
                        xReturn_core2 = pdFAIL_core2;
                    }

                    break;

                case eNoAction_core2:

                    /* The task_core2 is being notified without its notify value being
                     * updated. */
                    break;

                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT_core2( xTickCount_core2 == ( TickType_t_core2 ) 0 );
                    break;
            }

            traceTASK_NOTIFY_FROM_ISR_core2( uxIndexToNotify_core2 );

            /* If the task_core2 is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION_core2 )
            {
                /* The task_core2 should not have been on an event list. */
                configASSERT_core2( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) == NULL );

                if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
                {
                    listREMOVE_ITEM_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                    prvAddTaskToReadyList_core2( pxTCB_core2 );
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task_core2 pending until the scheduler is resumed. */
                    listINSERT_END_core2( &( xPendingReadyList_core2 ), &( pxTCB_core2->xEventListItem_core2 ) );
                }

                if( pxTCB_core2->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
                {
                    /* The notified task_core2 has a priority above the currently
                     * executing task_core2 so a yield is required. */
                    if( pxHigherPriorityTaskWoken_core2 != NULL )
                    {
                        *pxHigherPriorityTaskWoken_core2 = pdTRUE_core2;
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken_core2" parameter to an ISR
                     * safe FreeRTOS_core2 function. */
                    xYieldPending_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR_core2( uxSavedInterruptStatus_core2 );

        return xReturn_core2;
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    void vTaskGenericNotifyGiveFromISR_core2( TaskHandle_t_core2 xTaskToNotify_core2,
                                        UBaseType_t_core2 uxIndexToNotify_core2,
                                        BaseType_t_core2 * pxHigherPriorityTaskWoken_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        uint8_t ucOriginalNotifyState;
        UBaseType_t_core2 uxSavedInterruptStatus_core2;

        configASSERT_core2( xTaskToNotify_core2 );
        configASSERT_core2( uxIndexToNotify_core2 < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS_core2 API functions.  If configASSERT_core2()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2() will result in an assertion
         * failure if a FreeRTOS_core2 API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS_core2 functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS_core2 maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS_core2.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID_core2();

        pxTCB_core2 = xTaskToNotify_core2;

        uxSavedInterruptStatus_core2 = portSET_INTERRUPT_MASK_FROM_ISR_core2();
        {
            ucOriginalNotifyState = pxTCB_core2->ucNotifyState_core2[ uxIndexToNotify_core2 ];
            pxTCB_core2->ucNotifyState_core2[ uxIndexToNotify_core2 ] = taskNOTIFICATION_RECEIVED_core2;

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB_core2->ulNotifiedValue_core2[ uxIndexToNotify_core2 ] )++;

            traceTASK_NOTIFY_GIVE_FROM_ISR_core2( uxIndexToNotify_core2 );

            /* If the task_core2 is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION_core2 )
            {
                /* The task_core2 should not have been on an event list. */
                configASSERT_core2( listLIST_ITEM_CONTAINER_core2( &( pxTCB_core2->xEventListItem_core2 ) ) == NULL );

                if( uxSchedulerSuspended_core2 == ( UBaseType_t_core2 ) pdFALSE_core2 )
                {
                    listREMOVE_ITEM_core2( &( pxTCB_core2->xStateListItem_core2 ) );
                    prvAddTaskToReadyList_core2( pxTCB_core2 );
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task_core2 pending until the scheduler is resumed. */
                    listINSERT_END_core2( &( xPendingReadyList_core2 ), &( pxTCB_core2->xEventListItem_core2 ) );
                }

                if( pxTCB_core2->uxPriority_core2 > pxCurrentTCB_core2->uxPriority_core2 )
                {
                    /* The notified task_core2 has a priority above the currently
                     * executing task_core2 so a yield is required. */
                    if( pxHigherPriorityTaskWoken_core2 != NULL )
                    {
                        *pxHigherPriorityTaskWoken_core2 = pdTRUE_core2;
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken_core2" parameter in an ISR
                     * safe FreeRTOS_core2 function. */
                    xYieldPending_core2 = pdTRUE_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR_core2( uxSavedInterruptStatus_core2 );
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    BaseType_t_core2 xTaskGenericNotifyStateClear_core2( TaskHandle_t_core2 xTask_core2,
                                             UBaseType_t_core2 uxIndexToClear_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        BaseType_t_core2 xReturn_core2;

        configASSERT_core2( uxIndexToClear_core2 < configTASK_NOTIFICATION_ARRAY_ENTRIES_core2 );

        /* If null is passed in here then it is the calling task_core2 that is having
         * its notification state cleared. */
        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        taskENTER_CRITICAL_core2();
        {
            if( pxTCB_core2->ucNotifyState_core2[ uxIndexToClear_core2 ] == taskNOTIFICATION_RECEIVED_core2 )
            {
                pxTCB_core2->ucNotifyState_core2[ uxIndexToClear_core2 ] = taskNOT_WAITING_NOTIFICATION_core2;
                xReturn_core2 = pdPASS_core2;
            }
            else
            {
                xReturn_core2 = pdFAIL_core2;
            }
        }
        taskEXIT_CRITICAL_core2();

        return xReturn_core2;
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS_core2 == 1 )

    uint32_t ulTaskGenericNotifyValueClear_core2( TaskHandle_t_core2 xTask_core2,
                                            UBaseType_t_core2 uxIndexToClear_core2,
                                            uint32_t ulBitsToClear_core2 )
    {
        TCB_t_core2 * pxTCB_core2;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task_core2 that is having
         * its notification state cleared. */
        pxTCB_core2 = prvGetTCBFromHandle_core2( xTask_core2 );

        taskENTER_CRITICAL_core2();
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB_core2->ulNotifiedValue_core2[ uxIndexToClear_core2 ];
            pxTCB_core2->ulNotifiedValue_core2[ uxIndexToClear_core2 ] &= ~ulBitsToClear_core2;
        }
        taskEXIT_CRITICAL_core2();

        return ulReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS_core2 */
/*-----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle_core2 == 1 ) )

    configRUN_TIME_COUNTER_TYPE_core2 ulTaskGetIdleRunTimeCounter_core2( void )
    {
        return xIdleTaskHandle_core2->ulRunTimeCounter_core2;
    }

#endif
/*-----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle_core2 == 1 ) )

    configRUN_TIME_COUNTER_TYPE_core2 ulTaskGetIdleRunTimePercent_core2( void )
    {
        configRUN_TIME_COUNTER_TYPE_core2 ulTotalTime, ulReturn;

        ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE_core2();

        /* For percentage calculations. */
        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE_core2 ) 100;

        /* Avoid divide by zero errors. */
        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE_core2 ) 0 )
        {
            ulReturn = xIdleTaskHandle_core2->ulRunTimeCounter_core2 / ulTotalTime;
        }
        else
        {
            ulReturn = 0;
        }

        return ulReturn;
    }

#endif /* if ( ( configGENERATE_RUN_TIME_STATS_core2 == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle_core2 == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList_core2( TickType_t_core2 xTicksToWait_core2,
                                            const BaseType_t_core2 xCanBlockIndefinitely_core2 )
{
    TickType_t_core2 xTimeToWake_core2;
    const TickType_t_core2 xConstTickCount_core2 = xTickCount_core2;

    #if ( INCLUDE_xTaskAbortDelay_core2 == 1 )
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted_core2 flag is
         * reset to pdFALSE_core2 so it can be detected as having been set to pdTRUE_core2
         * when the task_core2 leaves the Blocked state. */
        pxCurrentTCB_core2->ucDelayAborted_core2 = pdFALSE_core2;
    }
    #endif

    /* Remove the task_core2 from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove_core2( &( pxCurrentTCB_core2->xStateListItem_core2 ) ) == ( UBaseType_t_core2 ) 0 )
    {
        /* The current task_core2 must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY_core2( pxCurrentTCB_core2->uxPriority_core2, uxTopReadyPriority_core2 ); /*lint !e931 pxCurrentTCB_core2 cannot change as it is the calling task_core2.  pxCurrentTCB_core2->uxPriority_core2 and uxTopReadyPriority_core2 cannot change as called with scheduler suspended or in a critical section. */
    }
    else
    {
        mtCOVERAGE_TEST_MARKER_core2();
    }

    #if ( INCLUDE_vTaskSuspend_core2 == 1 )
    {
        if( ( xTicksToWait_core2 == portMAX_DELAY_core2 ) && ( xCanBlockIndefinitely_core2 != pdFALSE_core2 ) )
        {
            /* Add the task_core2 to the suspended task_core2 list instead of a delayed task_core2
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END_core2( &xSuspendedTaskList_core2, &( pxCurrentTCB_core2->xStateListItem_core2 ) );
        }
        else
        {
            /* Calculate the time at which the task_core2 should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake_core2 = xConstTickCount_core2 + xTicksToWait_core2;

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE_core2( &( pxCurrentTCB_core2->xStateListItem_core2 ), xTimeToWake_core2 );

            if( xTimeToWake_core2 < xConstTickCount_core2 )
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert_core2( pxOverflowDelayedTaskList_core2, &( pxCurrentTCB_core2->xStateListItem_core2 ) );
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert_core2( pxDelayedTaskList_core2, &( pxCurrentTCB_core2->xStateListItem_core2 ) );

                /* If the task_core2 entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime_core2
                 * needs to be updated too. */
                if( xTimeToWake_core2 < xNextTaskUnblockTime_core2 )
                {
                    xNextTaskUnblockTime_core2 = xTimeToWake_core2;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER_core2();
                }
            }
        }
    }
    #else /* INCLUDE_vTaskSuspend_core2 */
    {
        /* Calculate the time at which the task_core2 should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake_core2 = xConstTickCount_core2 + xTicksToWait_core2;

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE_core2( &( pxCurrentTCB_core2->xStateListItem_core2 ), xTimeToWake_core2 );

        if( xTimeToWake_core2 < xConstTickCount_core2 )
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert_core2( pxOverflowDelayedTaskList_core2, &( pxCurrentTCB_core2->xStateListItem_core2 ) );
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert_core2( pxDelayedTaskList_core2, &( pxCurrentTCB_core2->xStateListItem_core2 ) );

            /* If the task_core2 entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime_core2 needs to be updated
             * too. */
            if( xTimeToWake_core2 < xNextTaskUnblockTime_core2 )
            {
                xNextTaskUnblockTime_core2 = xTimeToWake_core2;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER_core2();
            }
        }

        /* Avoid compiler warning when INCLUDE_vTaskSuspend_core2 is not 1. */
        ( void ) xCanBlockIndefinitely_core2;
    }
    #endif /* INCLUDE_vTaskSuspend_core2 */
}

/* Code below here allows additional code to be inserted into this source file,
 * especially where access to file scope functions and data is needed (for example
 * when performing module tests). */

#ifdef FREERTOS_MODULE_TEST
    #include "tasks_test_access_functions.h"
#endif


#if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )

    #include "freertos_tasks_c_additions.h"

    #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT_core2
        static void freertos_tasks_c_additions_init_core2( void )
        {
            FREERTOS_TASKS_C_ADDITIONS_INIT_core2();
        }
    #endif

#endif /* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) */
