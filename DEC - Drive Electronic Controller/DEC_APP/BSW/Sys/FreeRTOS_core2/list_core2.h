/*
 * FreeRTOS_core2 Kernel V10.5.1
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS_core2.org
 * https://github.com/FreeRTOS_core2
 *
 */

/*
 * This is the list implementation used by the scheduler.  While it is tailored
 * heavily for the schedulers needs, it is also available for use by
 * application code.
 *
 * list_ts can only store pointers to list_item_ts.  Each ListItem_t_core2 contains a
 * numeric value (xItemValue_core2).  Most of the time the lists are sorted in
 * ascending item value order.
 *
 * Lists are created already containing one list item.  The value of this
 * item is the maximum possible that can be stored, it is therefore always at
 * the end of the list and acts as a marker.  The list member pxHead always
 * points to this marker - even though it is at the tail of the list.  This
 * is because the tail contains a wrap back pointer to the true head of
 * the list.
 *
 * In addition to it's value, each list item contains a pointer to the next
 * item in the list (pxNext_core2), a pointer to the list it is in (pxContainer_core2)
 * and a pointer to back to the object that contains it.  These later two
 * pointers are included for efficiency of list manipulation.  There is
 * effectively a two way link between the object containing the list item and
 * the list item itself.
 *
 *
 * \page ListIntroduction List Implementation
 * \ingroup FreeRTOSIntro
 */


#ifndef LIST_CORE2_H
#define LIST_CORE2_H

#ifndef INC_FREERTOS_CORE2_H
    #error "FreeRTOS_core2.h must be included before list.h"
#endif

/*
 * The list structure members are modified from within interrupts, and therefore
 * by rights should be declared volatile.  However, they are only modified in a
 * functionally atomic way (within critical sections of with the scheduler
 * suspended) and are either passed by reference into a function or indexed via
 * a volatile variable.  Therefore, in all use cases tested so far, the volatile
 * qualifier can be omitted in order to provide a moderate performance
 * improvement without adversely affecting functional behaviour.  The assembly
 * instructions generated by the IAR, ARM and GCC compilers when the respective
 * compiler's options were set for maximum optimisation has been inspected and
 * deemed to be as intended.  That said, as compiler technology advances, and
 * especially if aggressive cross module optimisation is used (a use case that
 * has not been exercised to any great extend) then it is feasible that the
 * volatile qualifier will be needed for correct optimisation.  It is expected
 * that a compiler removing essential code because, without the volatile
 * qualifier on the list structure members and with aggressive cross module
 * optimisation, the compiler deemed the code unnecessary will result in
 * complete and obvious failure of the scheduler.  If this is ever experienced
 * then the volatile qualifier can be inserted in the relevant places within the
 * list structures by simply defining configLIST_VOLATILE_core2 to volatile in
 * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
 * If configLIST_VOLATILE_core2 is not defined then the preprocessor directives below
 * will simply #define configLIST_VOLATILE_core2 away completely.
 *
 * To use volatile list structure members then add the following line to
 * FreeRTOSConfig.h (without the quotes):
 * "#define configLIST_VOLATILE_core2 volatile"
 */
#ifndef configLIST_VOLATILE_core2
    #define configLIST_VOLATILE_core2
#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */

/* *INDENT-OFF* */
#ifdef __cplusplus
    extern "C" {
#endif
/* *INDENT-ON* */

/* Macros that can be used to place known values within the list structures,
 * then check that the known values do not get corrupted during the execution of
 * the application.   These may catch the list data structures being overwritten in
 * memory.  They will not catch data errors caused by incorrect configuration or
 * use of FreeRTOS_core2.*/
#if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 == 0 )
    /* Define the macros to do nothing. */
    #define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2
    #define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2
    #define listFIRST_LIST_INTEGRITY_CHECK_VALUE_core2
    #define listSECOND_LIST_INTEGRITY_CHECK_VALUE_core2
    #define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2( pxItem_core2 )
    #define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2( pxItem_core2 )
    #define listSET_LIST_INTEGRITY_CHECK_1_VALUE_core2( pxList_core2 )
    #define listSET_LIST_INTEGRITY_CHECK_2_VALUE_core2( pxList_core2 )
    #define listTEST_LIST_ITEM_INTEGRITY_core2( pxItem_core2 )
    #define listTEST_LIST_INTEGRITY_core2( pxList_core2 )
#else /* if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 == 0 ) */
    /* Define macros that add new members into the list structures. */
    #define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2     TickType_t_core2 xListItemIntegrityValue1_core2;
    #define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2    TickType_t_core2 xListItemIntegrityValue2_core2;
    #define listFIRST_LIST_INTEGRITY_CHECK_VALUE_core2          TickType_t_core2 xListIntegrityValue1_core2;
    #define listSECOND_LIST_INTEGRITY_CHECK_VALUE_core2         TickType_t_core2 xListIntegrityValue2_core2;

/* Define macros that set the new structure members to known values. */
    #define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2( pxItem_core2 )     ( pxItem_core2 )->xListItemIntegrityValue1_core2 = pdINTEGRITY_CHECK_VALUE_core2
    #define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2( pxItem_core2 )    ( pxItem_core2 )->xListItemIntegrityValue2_core2 = pdINTEGRITY_CHECK_VALUE_core2
    #define listSET_LIST_INTEGRITY_CHECK_1_VALUE_core2( pxList_core2 )              ( pxList_core2 )->xListIntegrityValue1_core2 = pdINTEGRITY_CHECK_VALUE_core2
    #define listSET_LIST_INTEGRITY_CHECK_2_VALUE_core2( pxList_core2 )              ( pxList_core2 )->xListIntegrityValue2_core2 = pdINTEGRITY_CHECK_VALUE_core2

/* Define macros that will assert if one of the structure members does not
 * contain its expected value. */
    #define listTEST_LIST_ITEM_INTEGRITY_core2( pxItem_core2 )                      configASSERT_core2( ( ( pxItem_core2 )->xListItemIntegrityValue1_core2 == pdINTEGRITY_CHECK_VALUE_core2 ) && ( ( pxItem_core2 )->xListItemIntegrityValue2_core2 == pdINTEGRITY_CHECK_VALUE_core2 ) )
    #define listTEST_LIST_INTEGRITY_core2( pxList_core2 )                           configASSERT_core2( ( ( pxList_core2 )->xListIntegrityValue1_core2 == pdINTEGRITY_CHECK_VALUE_core2 ) && ( ( pxList_core2 )->xListIntegrityValue2_core2 == pdINTEGRITY_CHECK_VALUE_core2 ) )
#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 */


/*
 * Definition of the only type of object that a list can contain.
 */
struct xLIST_core2;
struct xLIST_ITEM_core2
{
    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2           /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 is set to 1. */
    configLIST_VOLATILE_core2 TickType_t_core2 xItemValue_core2;          /*< The value being listed.  In most cases this is used to sort the list in ascending order. */
    struct xLIST_ITEM_core2 * configLIST_VOLATILE_core2 pxNext_core2;     /*< Pointer to the next ListItem_t_core2 in the list. */
    struct xLIST_ITEM_core2 * configLIST_VOLATILE_core2 pxPrevious_core2; /*< Pointer to the previous ListItem_t_core2 in the list. */
    void * pvOwner_core2;                                     /*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
    struct xLIST_core2 * configLIST_VOLATILE_core2 pxContainer_core2;     /*< Pointer to the list in which this list item is placed (if any). */
    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2          /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 is set to 1. */
};
typedef struct xLIST_ITEM_core2 ListItem_t_core2;                   /* For some reason lint wants this as two separate definitions. */

#if ( configUSE_MINI_LIST_ITEM_core2 == 1 )
    struct xMINI_LIST_ITEM_core2
    {
        listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core2 /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 is set to 1. */
        configLIST_VOLATILE_core2 TickType_t_core2 xItemValue_core2;
        struct xLIST_ITEM_core2 * configLIST_VOLATILE_core2 pxNext_core2;
        struct xLIST_ITEM_core2 * configLIST_VOLATILE_core2 pxPrevious_core2;
    };
    typedef struct xMINI_LIST_ITEM_core2 MiniListItem_t_core2;
#else
    typedef struct xLIST_ITEM_core2      MiniListItem_t_core2;
#endif

/*
 * Definition of the type of queue used by the scheduler.
 */
typedef struct xLIST_core2
{
    listFIRST_LIST_INTEGRITY_CHECK_VALUE_core2      /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 is set to 1. */
    volatile UBaseType_t_core2 uxNumberOfItems_core2;
    ListItem_t_core2 * configLIST_VOLATILE_core2 pxIndex_core2; /*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY_core2 (). */
    MiniListItem_t_core2 xListEnd_core2;                  /*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
    listSECOND_LIST_INTEGRITY_CHECK_VALUE_core2     /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core2 is set to 1. */
} List_t_core2;

/*
 * Access macro to set the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listSET_LIST_ITEM_OWNER_core2 listSET_LIST_ITEM_OWNER_core2
 * \ingroup LinkedList
 */
#define listSET_LIST_ITEM_OWNER_core2( pxListItem_core2, pxOwner_core2 )    ( ( pxListItem_core2 )->pvOwner_core2 = ( void * ) ( pxOwner_core2 ) )

/*
 * Access macro to get the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listGET_LIST_ITEM_OWNER_core2 listSET_LIST_ITEM_OWNER_core2
 * \ingroup LinkedList
 */
#define listGET_LIST_ITEM_OWNER_core2( pxListItem_core2 )             ( ( pxListItem_core2 )->pvOwner_core2 )

/*
 * Access macro to set the value of the list item.  In most cases the value is
 * used to sort the list in ascending order.
 *
 * \page listSET_LIST_ITEM_VALUE_core2 listSET_LIST_ITEM_VALUE_core2
 * \ingroup LinkedList
 */
#define listSET_LIST_ITEM_VALUE_core2( pxListItem_core2, xValue )     ( ( pxListItem_core2 )->xItemValue_core2 = ( xValue ) )

/*
 * Access macro to retrieve the value of the list item.  The value can
 * represent anything - for example the priority of a task_core2, or the time at
 * which a task_core2 should be unblocked.
 *
 * \page listGET_LIST_ITEM_VALUE_core2 listGET_LIST_ITEM_VALUE_core2
 * \ingroup LinkedList
 */
#define listGET_LIST_ITEM_VALUE_core2( pxListItem_core2 )             ( ( pxListItem_core2 )->xItemValue_core2 )

/*
 * Access macro to retrieve the value of the list item at the head of a given
 * list.
 *
 * \page listGET_LIST_ITEM_VALUE_core2 listGET_LIST_ITEM_VALUE_core2
 * \ingroup LinkedList
 */
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY_core2( pxList_core2 )        ( ( ( pxList_core2 )->xListEnd_core2 ).pxNext_core2->xItemValue_core2 )

/*
 * Return the list item at the head of the list.
 *
 * \page listGET_HEAD_ENTRY_core2 listGET_HEAD_ENTRY_core2
 * \ingroup LinkedList
 */
#define listGET_HEAD_ENTRY_core2( pxList_core2 )                      ( ( ( pxList_core2 )->xListEnd_core2 ).pxNext_core2 )

/*
 * Return the next list item.
 *
 * \page listGET_NEXT_core2 listGET_NEXT_core2
 * \ingroup LinkedList
 */
#define listGET_NEXT_core2( pxListItem_core2 )                        ( ( pxListItem_core2 )->pxNext_core2 )

/*
 * Return the list item that marks the end of the list
 *
 * \page listGET_END_MARKER_core2 listGET_END_MARKER_core2
 * \ingroup LinkedList
 */
#define listGET_END_MARKER_core2( pxList_core2 )                      ( ( ListItem_t_core2 const * ) ( &( ( pxList_core2 )->xListEnd_core2 ) ) )

/*
 * Access macro to determine if a list contains any items.  The macro will
 * only have the value true if the list is empty.
 *
 * \page listLIST_IS_EMPTY_core2 listLIST_IS_EMPTY_core2
 * \ingroup LinkedList
 */
#define listLIST_IS_EMPTY_core2( pxList_core2 )                       ( ( ( pxList_core2 )->uxNumberOfItems_core2 == ( UBaseType_t_core2 ) 0 ) ? pdTRUE_core2 : pdFALSE_core2 )

/*
 * Access macro to return the number of items in the list.
 */
#define listCURRENT_LIST_LENGTH_core2( pxList_core2 )                 ( ( pxList_core2 )->uxNumberOfItems_core2 )

/*
 * Access function to obtain the owner of the next entry in a list.
 *
 * The list member pxIndex_core2 is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY_core2 increments pxIndex_core2 to the next item in the list
 * and returns that entry's pxOwner_core2 parameter.  Using multiple calls to this
 * function it is therefore possible to move through every item contained in
 * a list.
 *
 * The pxOwner_core2 parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task_core2 control block.
 * The pxOwner_core2 parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxTCB_core2 pxTCB_core2 is set to the address of the owner of the next list item.
 * @param pxList_core2 The list from which the next item owner is to be returned.
 *
 * \page listGET_OWNER_OF_NEXT_ENTRY_core2 listGET_OWNER_OF_NEXT_ENTRY_core2
 * \ingroup LinkedList
 */
#define listGET_OWNER_OF_NEXT_ENTRY_core2( pxTCB_core2, pxList_core2 )                                           \
    {                                                                                          \
        List_t_core2 * const pxConstList_core2 = ( pxList_core2 );                                               \
        /* Increment the index to the next item and return the item, ensuring */               \
        /* we don't return the marker used at the end of the list.  */                         \
        ( pxConstList_core2 )->pxIndex_core2 = ( pxConstList_core2 )->pxIndex_core2->pxNext_core2;                           \
        if( ( void * ) ( pxConstList_core2 )->pxIndex_core2 == ( void * ) &( ( pxConstList_core2 )->xListEnd_core2 ) ) \
        {                                                                                      \
            ( pxConstList_core2 )->pxIndex_core2 = ( pxConstList_core2 )->pxIndex_core2->pxNext_core2;                       \
        }                                                                                      \
        ( pxTCB_core2 ) = ( pxConstList_core2 )->pxIndex_core2->pvOwner_core2;                                         \
    }

/*
 * Version of uxListRemove_core2() that does not return a value.  Provided as a slight
 * optimisation for xTaskIncrementTick_core2() by being inline.
 *
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove_core2 The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer_core2 parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page listREMOVE_ITEM_core2 listREMOVE_ITEM_core2
 * \ingroup LinkedList
 */
#define listREMOVE_ITEM_core2( pxItemToRemove_core2 ) \
    {                                     \
        /* The list item knows which list it is in.  Obtain the list from the list \
         * item. */                                                              \
        List_t_core2 * const pxList_core2 = ( pxItemToRemove_core2 )->pxContainer_core2;                 \
                                                                                 \
        ( pxItemToRemove_core2 )->pxNext_core2->pxPrevious_core2 = ( pxItemToRemove_core2 )->pxPrevious_core2; \
        ( pxItemToRemove_core2 )->pxPrevious_core2->pxNext_core2 = ( pxItemToRemove_core2 )->pxNext_core2;     \
        /* Make sure the index is left pointing to a valid item. */              \
        if( pxList_core2->pxIndex_core2 == ( pxItemToRemove_core2 ) )                              \
        {                                                                        \
            pxList_core2->pxIndex_core2 = ( pxItemToRemove_core2 )->pxPrevious_core2;                    \
        }                                                                        \
                                                                                 \
        ( pxItemToRemove_core2 )->pxContainer_core2 = NULL;                                  \
        ( pxList_core2->uxNumberOfItems_core2 )--;                                           \
    }

/*
 * Inline version of vListInsertEnd_core2() to provide slight optimisation for
 * xTaskIncrementTick_core2().
 *
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY_core2.
 *
 * The list member pxIndex_core2 is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY_core2 increments pxIndex_core2 to the next item in the list.
 * Placing an item in a list using vListInsertEnd_core2 effectively places the item
 * in the list position pointed to by pxIndex_core2.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY_core2 before
 * the pxIndex_core2 parameter again points to the item being inserted.
 *
 * @param pxList_core2 The list into which the item is to be inserted.
 *
 * @param pxNewListItem_core2 The list item to be inserted into the list.
 *
 * \page listINSERT_END_core2 listINSERT_END_core2
 * \ingroup LinkedList
 */
#define listINSERT_END_core2( pxList_core2, pxNewListItem_core2 )           \
    {                                                     \
        ListItem_t_core2 * const pxIndex_core2 = ( pxList_core2 )->pxIndex_core2; \
                                                          \
        /* Only effective when configASSERT_core2() is also defined, these tests may catch \
         * the list data structures being overwritten in memory.  They will not catch \
         * data errors caused by incorrect configuration or use of FreeRTOS_core2. */ \
        listTEST_LIST_INTEGRITY_core2( ( pxList_core2 ) );                                  \
        listTEST_LIST_ITEM_INTEGRITY_core2( ( pxNewListItem_core2 ) );                      \
                                                                                \
        /* Insert a new list item into ( pxList_core2 ), but rather than sort the list, \
         * makes the new list item the last item to be removed by a call to \
         * listGET_OWNER_OF_NEXT_ENTRY_core2(). */                 \
        ( pxNewListItem_core2 )->pxNext_core2 = pxIndex_core2;                 \
        ( pxNewListItem_core2 )->pxPrevious_core2 = pxIndex_core2->pxPrevious_core2; \
                                                             \
        pxIndex_core2->pxPrevious_core2->pxNext_core2 = ( pxNewListItem_core2 );     \
        pxIndex_core2->pxPrevious_core2 = ( pxNewListItem_core2 );             \
                                                             \
        /* Remember which list the item is in. */            \
        ( pxNewListItem_core2 )->pxContainer_core2 = ( pxList_core2 );         \
                                                             \
        ( ( pxList_core2 )->uxNumberOfItems_core2 )++;                   \
    }

/*
 * Access function to obtain the owner of the first entry in a list.  Lists
 * are normally sorted in ascending item value order.
 *
 * This function returns the pxOwner_core2 member of the first item in the list.
 * The pxOwner_core2 parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task_core2 control block.
 * The pxOwner_core2 parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxList_core2 The list from which the owner of the head item is to be
 * returned.
 *
 * \page listGET_OWNER_OF_HEAD_ENTRY_core2 listGET_OWNER_OF_HEAD_ENTRY_core2
 * \ingroup LinkedList
 */
#define listGET_OWNER_OF_HEAD_ENTRY_core2( pxList_core2 )            ( ( &( ( pxList_core2 )->xListEnd_core2 ) )->pxNext_core2->pvOwner_core2 )

/*
 * Check to see if a list item is within a list.  The list item maintains a
 * "container" pointer that points to the list it is in.  All this macro does
 * is check to see if the container and the list match.
 *
 * @param pxList_core2 The list we want to know if the list item is within.
 * @param pxListItem_core2 The list item we want to know if is in the list.
 * @return pdTRUE_core2 if the list item is in the list, otherwise pdFALSE_core2.
 */
#define listIS_CONTAINED_WITHIN_core2( pxList_core2, pxListItem_core2 )    ( ( ( pxListItem_core2 )->pxContainer_core2 == ( pxList_core2 ) ) ? ( pdTRUE_core2 ) : ( pdFALSE_core2 ) )

/*
 * Return the list a list item is contained within (referenced from).
 *
 * @param pxListItem_core2 The list item being queried.
 * @return A pointer to the List_t_core2 object that references the pxListItem_core2
 */
#define listLIST_ITEM_CONTAINER_core2( pxListItem_core2 )            ( ( pxListItem_core2 )->pxContainer_core2 )

/*
 * This provides a crude means of knowing if a list has been initialised, as
 * pxList_core2->xListEnd_core2.xItemValue_core2 is set to portMAX_DELAY_core2 by the vListInitialise_core2()
 * function.
 */
#define listLIST_IS_INITIALISED_core2( pxList_core2 )                ( ( pxList_core2 )->xListEnd_core2.xItemValue_core2 == portMAX_DELAY_core2 )

/*
 * Must be called before a list is used!  This initialises all the members
 * of the list structure and inserts the xListEnd_core2 item into the list as a
 * marker to the back of the list.
 *
 * @param pxList_core2 Pointer to the list being initialised.
 *
 * \page vListInitialise_core2 vListInitialise_core2
 * \ingroup LinkedList
 */
void vListInitialise_core2( List_t_core2 * const pxList_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Must be called before a list item is used.  This sets the list container to
 * null so the item does not think that it is already contained in a list.
 *
 * @param pxItem_core2 Pointer to the list item being initialised.
 *
 * \page vListInitialiseItem_core2 vListInitialiseItem_core2
 * \ingroup LinkedList
 */
void vListInitialiseItem_core2( ListItem_t_core2 * const pxItem_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Insert a list item into a list.  The item will be inserted into the list in
 * a position determined by its item value (ascending item value order).
 *
 * @param pxList_core2 The list into which the item is to be inserted.
 *
 * @param pxNewListItem_core2 The item that is to be placed in the list.
 *
 * \page vListInsert_core2 vListInsert_core2
 * \ingroup LinkedList
 */
void vListInsert_core2( List_t_core2 * const pxList_core2,
                  ListItem_t_core2 * const pxNewListItem_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY_core2.
 *
 * The list member pxIndex_core2 is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY_core2 increments pxIndex_core2 to the next item in the list.
 * Placing an item in a list using vListInsertEnd_core2 effectively places the item
 * in the list position pointed to by pxIndex_core2.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY_core2 before
 * the pxIndex_core2 parameter again points to the item being inserted.
 *
 * @param pxList_core2 The list into which the item is to be inserted.
 *
 * @param pxNewListItem_core2 The list item to be inserted into the list.
 *
 * \page vListInsertEnd_core2 vListInsertEnd_core2
 * \ingroup LinkedList
 */
void vListInsertEnd_core2( List_t_core2 * const pxList_core2,
                     ListItem_t_core2 * const pxNewListItem_core2 ) PRIVILEGED_FUNCTION_core2;

/*
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove_core2 The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer_core2 parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page uxListRemove_core2 uxListRemove_core2
 * \ingroup LinkedList
 */
UBaseType_t_core2 uxListRemove_core2( ListItem_t_core2 * const pxItemToRemove_core2 ) PRIVILEGED_FUNCTION_core2;

/* *INDENT-OFF* */
#ifdef __cplusplus
    }
#endif
/* *INDENT-ON* */

#endif /* ifndef LIST_H */
