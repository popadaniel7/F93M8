/*
 * Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *                               IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * SPDX-License-Identifier: BSL-1.0
 */

#ifndef PORTMACRO_CORE1_H
#define PORTMACRO_CORE1_H

#ifdef __cplusplus
    extern "C"
#endif

#include "FreeRTOSConfig_core1.h"

#define portCPU_PSW_core1              0xFE04
#define portCPU_PSW_IS_OFF_core1       ( 9 )
#define portCPU_PSW_CSC_MSK_core1      ( 0x7F )
#define portCPU_ICR_core1              0xFE2C
#define portCPU_ICR_CCPN_OFF_core1     ( 0 )
#define portCPU_ICR_CCPN_MSK_core1     ( 0x000000FFUL )
#define portCPU_FCX_core1              0xFE38
#define portCPU_PCXI_core1             0xFE00
#define portCPU_CORE_ID_core1          0xFE1C

/* Register defintions */
#define portSRC_SRCR_SRPN_OFF_core1    0
#define portSRC_SRCR_SRE_OFF_core1     10
#define portSRC_SRCR_TOS_OFF_core1     11
#define portSRC_SRCR_SRR_OFF_core1     24
#define portSRC_SRCR_SETR_OFF_core1    26

/* Type definitions. */
#define portCHAR_core1                 char
#define portSHORT_core1                short
#define portLONG_core1                 long
#define portFLOAT_core1                float
#define portDOUBLE_core1               double
#define portSTACK_TYPE_core1           uint32_t
#define portBASE_TYPE_core1            long
#define portPOINTER_SIZE_TYPE_core1    uintptr_t

typedef portSTACK_TYPE_core1       StackType_t_core1;
typedef long                 BaseType_t_core1;
typedef unsigned long        UBaseType_t_core1;

#if ( configUSE_16_BIT_TICKS_core1 == 1 )
    typedef unsigned short   TickType_t_core1;
    #define portMAX_DELAY_core1    ( TickType_t_core1 ) 0xffff
#else
    typedef unsigned int     TickType_t_core1;
    #define portMAX_DELAY_core1    ( TickType_t_core1 ) 0xffffffffUL
#endif

/* FreeRTOS_core1 parameters */
#define portTICK_TYPE_IS_ATOMIC_core1        1
#define portSTACK_GROWTH_core1               ( -1 )
#define portTICK_PERIOD_MS_core1             ( ( TickType_t_core1 ) 1000 / configTICK_RATE_HZ_core1 )
#define portBYTE_ALIGNMENT_core1             8
#define portCRITICAL_NESTING_IN_TCB_core1    0

/* Attributes */
#define portDONT_DISCARD_core1               __attribute__( ( used ) )
#define portNORETURN_core1                   __attribute__( ( noreturn ) )

/* Instructions */
#define portNOP_core1()               __nop()
#define portMEMORY_BARRIER_core1()    __dsync()

/* Critical section management */
extern void vPortEnterCritical_core1( void );
extern void vPortExitCritical_core1( void );
#define portENTER_CRITICAL_core1()                                     vPortEnterCritical_core1()
#define portEXIT_CRITICAL_core1()                                      vPortExitCritical_core1()
#define portENABLE_INTERRUPTS_core1()                                  vPortSetCCPN_core1( 0 );
#define portDISABLE_INTERRUPTS_core1()                                 vPortSetCCPN_core1( configMAX_API_CALL_INTERRUPT_PRIORITY_core1 )
#define portASSERT_IF_IN_ISR_core1()                                   configASSERT_core1( ( __mfcr( portCPU_PSW_core1 ) & ( 1 << portCPU_PSW_IS_OFF_core1 ) ) == 0 )
#define portCLEAR_INTERRUPT_MASK_FROM_ISR_core1( ulSavedMaskValue_core1 )    vPortSetICR_core1( ulSavedMaskValue_core1 )
#define portSET_INTERRUPT_MASK_FROM_ISR_core1()                        xPortSetCCPN_core1( configMAX_API_CALL_INTERRUPT_PRIORITY_core1 )


#ifndef configYIELD_SYSCALL_ID_core1
    #define configYIELD_SYSCALL_ID_core1    0
#endif

#define portYIELD_core1()    __syscall( configYIELD_SYSCALL_ID_core1 )
#define portYIELD_FROM_ISR_core1( xHigherPriorityTaskWoken_core1 )                                                                                \
    {                                                                                                                                 \
        const uint32_t xTrigger_core1 = ( ( *configCONTEXT_SRC_core1 >> portSRC_SRCR_SRR_OFF_core1 ) & 0x1 ) != 1 && ( xHigherPriorityTaskWoken_core1 != 0 ); \
        *configCONTEXT_SRC_core1 |= ( xTrigger_core1 << portSRC_SRCR_SETR_OFF_core1 );                                                                  \
                                                                                                                                      \
        /* Wait until write request completes to trigger IRQ */                                                                       \
        __dsync();                                                                                                                    \
        __isync();                                                                                                                    \
    }


#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION_core1
    #define configUSE_PORT_OPTIMISED_TASK_SELECTION_core1    1
#endif

#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION_core1 == 1 )

/* Check the configuration. */
    #if ( configMAX_PRIORITIES_core1 > 32 )
        #error configUSE_PORT_OPTIMISED_TASK_SELECTION_core1 can only be set to 1 when configMAX_PRIORITIES_core1 is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
    #endif

/* Store/clear the ready priorities in a bit map. */
    #define portRECORD_READY_PRIORITY_core1( uxPriority_core1, uxReadyPriorities_core1 )      ( uxReadyPriorities_core1 ) |= ( 1UL << ( uxPriority_core1 ) )
    #define portRESET_READY_PRIORITY_core1( uxPriority_core1, uxReadyPriorities_core1 )       ( uxReadyPriorities_core1 ) &= ~( 1UL << ( uxPriority_core1 ) )

    #define portGET_HIGHEST_PRIORITY_core1( uxTopPriority_core1, uxReadyPriorities_core1 )    uxTopPriority_core1 = ( 31UL - ( ( uint32_t ) __clz( ( uxReadyPriorities_core1 ) ) ) )

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION_core1 */

/* Function prototypes */
#define portTASK_FUNCTION_PROTO_core1( vFunction_core1, pvParameters_core1 )    void vFunction_core1( void * pvParameters_core1 )
#define portTASK_FUNCTION_core1( vFunction_core1, pvParameters_core1 )          void vFunction_core1( void * pvParameters_core1 )

/* TCB handling */
extern void vPortReclaimCSA_core1( unsigned long ** pxTCB_core1 );
#define portCLEAN_UP_TCB_core1( pxTCB_core1 )    vPortReclaimCSA_core1( ( unsigned long ** ) ( pxTCB_core1 ) )


/* ICR & CCPN modifying functions to enable and disable interrupts.
 * Only interrupts with a priority lower than
 */
static void __attribute__( ( used, always_inline ) ) vPortSetCCPN_core1( unsigned char ucCCPN )
{
    __disable();
    __mtcr( portCPU_ICR_core1, ( __mfcr( portCPU_ICR_core1 ) & ~portCPU_ICR_CCPN_MSK_core1 ) | ( ucCCPN & portCPU_ICR_CCPN_MSK_core1 ) );
    __enable();
}

static void __attribute__( ( used, always_inline ) ) vPortSetICR_core1( portBASE_TYPE_core1 ulICR )
{
    __disable();
    __mtcr( portCPU_ICR_core1, ( unsigned int ) ulICR );
    __enable();
}

static portBASE_TYPE_core1 __attribute__( ( used, always_inline ) ) xPortSetCCPN_core1( unsigned char ucCCPN )
{
    uint32_t xICR;

    __disable();
    xICR = __mfcr( portCPU_ICR_core1 );
    __mtcr( portCPU_ICR_core1, ( xICR & ~portCPU_ICR_CCPN_MSK_core1 ) | ( ucCCPN & portCPU_ICR_CCPN_MSK_core1 ) );
    __enable();
    return ( portBASE_TYPE_core1 ) xICR;
}

#ifdef __cplusplus
}
#endif

#endif /* PORTMACRO_H */
