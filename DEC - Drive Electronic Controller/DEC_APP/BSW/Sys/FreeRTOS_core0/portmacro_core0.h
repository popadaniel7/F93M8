/*
 * Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *                               IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * SPDX-License-Identifier: BSL-1.0
 */

#ifndef PORTMACRO_CORE0_H
#define PORTMACRO_CORE0_H

#ifdef __cplusplus
    extern "C"
#endif

#include "FreeRTOSConfig_core0.h"

#define portCPU_PSW_core0              0xFE04
#define portCPU_PSW_IS_OFF_core0       ( 9 )
#define portCPU_PSW_CSC_MSK_core0      ( 0x7F )
#define portCPU_ICR_core0              0xFE2C
#define portCPU_ICR_CCPN_OFF_core0     ( 0 )
#define portCPU_ICR_CCPN_MSK_core0     ( 0x000000FFUL )
#define portCPU_FCX_core0              0xFE38
#define portCPU_PCXI_core0             0xFE00
#define portCPU_CORE_ID_core0          0xFE1C

/* Register defintions */
#define portSRC_SRCR_SRPN_OFF_core0    0
#define portSRC_SRCR_SRE_OFF_core0     10
#define portSRC_SRCR_TOS_OFF_core0     11
#define portSRC_SRCR_SRR_OFF_core0     24
#define portSRC_SRCR_SETR_OFF_core0    26

/* Type definitions. */
#define portCHAR_core0                 char
#define portSHORT_core0                short
#define portLONG_core0                 long
#define portFLOAT_core0                float
#define portDOUBLE_core0               double
#define portSTACK_TYPE_core0           uint32_t
#define portBASE_TYPE_core0            long
#define portPOINTER_SIZE_TYPE_core0    uintptr_t

typedef portSTACK_TYPE_core0       StackType_t_core0;
typedef long                 BaseType_t_core0;
typedef unsigned long        UBaseType_t_core0;

#if ( configUSE_16_BIT_TICKS_core0 == 1 )
    typedef unsigned short   TickType_t_core0;
    #define portMAX_DELAY_core0    ( TickType_t_core0 ) 0xffff
#else
    typedef unsigned int     TickType_t_core0;
    #define portMAX_DELAY_core0    ( TickType_t_core0 ) 0xffffffffUL
#endif

/* FreeRTOS_core0 parameters */
#define portTICK_TYPE_IS_ATOMIC_core0        1
#define portSTACK_GROWTH_core0               ( -1 )
#define portTICK_PERIOD_MS_core0             ( ( TickType_t_core0 ) 1000 / configTICK_RATE_HZ_core0 )
#define portBYTE_ALIGNMENT_core0             8
#define portCRITICAL_NESTING_IN_TCB_core0    0

/* Attributes */
#define portDONT_DISCARD_core0               __attribute__( ( used ) )
#define portNORETURN_core0                   __attribute__( ( noreturn ) )

/* Instructions */
#define portNOP_core0()               __nop()
#define portMEMORY_BARRIER_core0()    __dsync()

/* Critical section management */
extern void vPortEnterCritical_core0( void );
extern void vPortExitCritical_core0( void );
#define portENTER_CRITICAL_core0()                                     vPortEnterCritical_core0()
#define portEXIT_CRITICAL_core0()                                      vPortExitCritical_core0()
#define portENABLE_INTERRUPTS_core0()                                  vPortSetCCPN_core0( 0 );
#define portDISABLE_INTERRUPTS_core0()                                 vPortSetCCPN_core0( configMAX_API_CALL_INTERRUPT_PRIORITY_core0 )
#define portASSERT_IF_IN_ISR_core0()                                   configASSERT_core0( ( __mfcr( portCPU_PSW_core0 ) & ( 1 << portCPU_PSW_IS_OFF_core0 ) ) == 0 )
#define portCLEAR_INTERRUPT_MASK_FROM_ISR_core0( ulSavedMaskValue_core0 )    vPortSetICR_core0( ulSavedMaskValue_core0 )
#define portSET_INTERRUPT_MASK_FROM_ISR_core0()                        xPortSetCCPN_core0( configMAX_API_CALL_INTERRUPT_PRIORITY_core0 )


#ifndef configYIELD_SYSCALL_ID_core0
    #define configYIELD_SYSCALL_ID_core0    0
#endif

#define portYIELD_core0()    __syscall( configYIELD_SYSCALL_ID_core0 )
#define portYIELD_FROM_ISR_core0( xHigherPriorityTaskWoken_core0 )                                                                                \
    {                                                                                                                                 \
        const uint32_t xTrigger_core0 = ( ( *configCONTEXT_SRC_core0 >> portSRC_SRCR_SRR_OFF_core0 ) & 0x1 ) != 1 && ( xHigherPriorityTaskWoken_core0 != 0 ); \
        *configCONTEXT_SRC_core0 |= ( xTrigger_core0 << portSRC_SRCR_SETR_OFF_core0 );                                                                  \
                                                                                                                                      \
        /* Wait until write request completes to trigger IRQ */                                                                       \
        __dsync();                                                                                                                    \
        __isync();                                                                                                                    \
    }


#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION_core0
    #define configUSE_PORT_OPTIMISED_TASK_SELECTION_core0    1
#endif

#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION_core0 == 1 )

/* Check the configuration. */
    #if ( configMAX_PRIORITIES_core0 > 32 )
        #error configUSE_PORT_OPTIMISED_TASK_SELECTION_core0 can only be set to 1 when configMAX_PRIORITIES_core0 is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
    #endif

/* Store/clear the ready priorities in a bit map. */
    #define portRECORD_READY_PRIORITY_core0( uxPriority_core0, uxReadyPriorities_core0 )      ( uxReadyPriorities_core0 ) |= ( 1UL << ( uxPriority_core0 ) )
    #define portRESET_READY_PRIORITY_core0( uxPriority_core0, uxReadyPriorities_core0 )       ( uxReadyPriorities_core0 ) &= ~( 1UL << ( uxPriority_core0 ) )

    #define portGET_HIGHEST_PRIORITY_core0( uxTopPriority_core0, uxReadyPriorities_core0 )    uxTopPriority_core0 = ( 31UL - ( ( uint32_t ) __clz( ( uxReadyPriorities_core0 ) ) ) )

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION_core0 */

/* Function prototypes */
#define portTASK_FUNCTION_PROTO_core0( vFunction_core0, pvParameters_core0 )    void vFunction_core0( void * pvParameters_core0 )
#define portTASK_FUNCTION_core0( vFunction_core0, pvParameters_core0 )          void vFunction_core0( void * pvParameters_core0 )

/* TCB handling */
extern void vPortReclaimCSA_core0( unsigned long ** pxTCB_core0 );
#define portCLEAN_UP_TCB_core0( pxTCB_core0 )    vPortReclaimCSA_core0( ( unsigned long ** ) ( pxTCB_core0 ) )


/* ICR & CCPN modifying functions to enable and disable interrupts.
 * Only interrupts with a priority lower than
 */
static void __attribute__( ( used, always_inline ) ) vPortSetCCPN_core0( unsigned char ucCCPN )
{
    __disable();
    __mtcr( portCPU_ICR_core0, ( __mfcr( portCPU_ICR_core0 ) & ~portCPU_ICR_CCPN_MSK_core0 ) | ( ucCCPN & portCPU_ICR_CCPN_MSK_core0 ) );
    __enable();
}

static void __attribute__( ( used, always_inline ) ) vPortSetICR_core0( portBASE_TYPE_core0 ulICR )
{
    __disable();
    __mtcr( portCPU_ICR_core0, ( unsigned int ) ulICR );
    __enable();
}

static portBASE_TYPE_core0 __attribute__( ( used, always_inline ) ) xPortSetCCPN_core0( unsigned char ucCCPN )
{
    uint32_t xICR;

    __disable();
    xICR = __mfcr( portCPU_ICR_core0 );
    __mtcr( portCPU_ICR_core0, ( xICR & ~portCPU_ICR_CCPN_MSK_core0 ) | ( ucCCPN & portCPU_ICR_CCPN_MSK_core0 ) );
    __enable();
    return ( portBASE_TYPE_core0 ) xICR;
}

#ifdef __cplusplus
}
#endif

#endif /* PORTMACRO_H */
