/*
 * Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *                               IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * SPDX-License-Identifier: BSL-1.0
 */

#ifndef PORTMACRO_H
#define PORTMACRO_H

#ifdef __cplusplus
    extern "C"
#endif

#include "FreeRTOSConfig_core2.h"

#define portCPU_PSW_core2              0xFE04
#define portCPU_PSW_IS_OFF_core2       ( 9 )
#define portCPU_PSW_CSC_MSK_core2      ( 0x7F )
#define portCPU_ICR_core2              0xFE2C
#define portCPU_ICR_CCPN_OFF_core2     ( 0 )
#define portCPU_ICR_CCPN_MSK_core2     ( 0x000000FFUL )
#define portCPU_FCX_core2              0xFE38
#define portCPU_PCXI_core2             0xFE00
#define portCPU_CORE_ID_core2          0xFE1C

/* Register defintions */
#define portSRC_SRCR_SRPN_OFF_core2    0
#define portSRC_SRCR_SRE_OFF_core2     10
#define portSRC_SRCR_TOS_OFF_core2     11
#define portSRC_SRCR_SRR_OFF_core2     24
#define portSRC_SRCR_SETR_OFF_core2    26

/* Type definitions. */
#define portCHAR_core2                 char
#define portSHORT_core2                short
#define portLONG_core2                 long
#define portFLOAT_core2                float
#define portDOUBLE_core2               double
#define portSTACK_TYPE_core2           uint32_t
#define portBASE_TYPE_core2            long
#define portPOINTER_SIZE_TYPE_core2    uintptr_t

typedef portSTACK_TYPE_core2       StackType_t_core2;
typedef long                 BaseType_t_core2;
typedef unsigned long        UBaseType_t_core2;

#if ( configUSE_16_BIT_TICKS_core2 == 1 )
    typedef unsigned short   TickType_t_core2;
    #define portMAX_DELAY_core2    ( TickType_t_core2 ) 0xffff
#else
    typedef unsigned int     TickType_t_core2;
    #define portMAX_DELAY_core2    ( TickType_t_core2 ) 0xffffffffUL
#endif

/* FreeRTOS_core2 parameters */
#define portTICK_TYPE_IS_ATOMIC_core2        1
#define portSTACK_GROWTH_core2               ( -1 )
#define portTICK_PERIOD_MS_core2             ( ( TickType_t_core2 ) 1000 / configTICK_RATE_HZ_core2 )
#define portBYTE_ALIGNMENT_core2             8
#define portCRITICAL_NESTING_IN_TCB_core2    0

/* Attributes */
#define portDONT_DISCARD_core2               __attribute__( ( used ) )
#define portNORETURN_core2                   __attribute__( ( noreturn ) )

/* Instructions */
#define portNOP_core2()               __nop()
#define portMEMORY_BARRIER_core2()    __dsync()

/* Critical section management */
extern void vPortEnterCritical_core2( void );
extern void vPortExitCritical_core2( void );
#define portENTER_CRITICAL_core2()                                     vPortEnterCritical_core2()
#define portEXIT_CRITICAL_core2()                                      vPortExitCritical_core2()
#define portENABLE_INTERRUPTS_core2()                                  vPortSetCCPN_core2( 0 );
#define portDISABLE_INTERRUPTS_core2()                                 vPortSetCCPN_core2( configMAX_API_CALL_INTERRUPT_PRIORITY_core2 )
#define portASSERT_IF_IN_ISR_core2()                                   configASSERT_core2( ( __mfcr( portCPU_PSW_core2 ) & ( 1 << portCPU_PSW_IS_OFF_core2 ) ) == 0 )
#define portCLEAR_INTERRUPT_MASK_FROM_ISR_core2( ulSavedMaskValue_core2 )    vPortSetICR_core2( ulSavedMaskValue_core2 )
#define portSET_INTERRUPT_MASK_FROM_ISR_core2()                        xPortSetCCPN_core2( configMAX_API_CALL_INTERRUPT_PRIORITY_core2 )


#ifndef configYIELD_SYSCALL_ID_core2
    #define configYIELD_SYSCALL_ID_core2    0
#endif

#define portYIELD_core2()    __syscall( configYIELD_SYSCALL_ID_core2 )
#define portYIELD_FROM_ISR_core2( xHigherPriorityTaskWoken_core2 )                                                                                \
    {                                                                                                                                 \
        const uint32_t xTrigger_core2 = ( ( *configCONTEXT_SRC_core2 >> portSRC_SRCR_SRR_OFF_core2 ) & 0x1 ) != 1 && ( xHigherPriorityTaskWoken_core2 != 0 ); \
        *configCONTEXT_SRC_core2 |= ( xTrigger_core2 << portSRC_SRCR_SETR_OFF_core2 );                                                                  \
                                                                                                                                      \
        /* Wait until write request completes to trigger IRQ */                                                                       \
        __dsync();                                                                                                                    \
        __isync();                                                                                                                    \
    }


#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION_core2
    #define configUSE_PORT_OPTIMISED_TASK_SELECTION_core2    1
#endif

#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 == 1 )

/* Check the configuration. */
    #if ( configMAX_PRIORITIES_core2 > 32 )
        #error configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 can only be set to 1 when configMAX_PRIORITIES_core2 is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
    #endif

/* Store/clear the ready priorities in a bit map. */
    #define portRECORD_READY_PRIORITY_core2( uxPriority_core2, uxReadyPriorities_core2 )      ( uxReadyPriorities_core2 ) |= ( 1UL << ( uxPriority_core2 ) )
    #define portRESET_READY_PRIORITY_core2( uxPriority_core2, uxReadyPriorities_core2 )       ( uxReadyPriorities_core2 ) &= ~( 1UL << ( uxPriority_core2 ) )

    #define portGET_HIGHEST_PRIORITY_core2( uxTopPriority_core2, uxReadyPriorities_core2 )    uxTopPriority_core2 = ( 31UL - ( ( uint32_t ) __clz( ( uxReadyPriorities_core2 ) ) ) )

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION_core2 */

/* Function prototypes */
#define portTASK_FUNCTION_PROTO_core2( vFunction_core2, pvParameters_core2 )    void vFunction_core2( void * pvParameters_core2 )
#define portTASK_FUNCTION_core2( vFunction_core2, pvParameters_core2 )          void vFunction_core2( void * pvParameters_core2 )

/* TCB handling */
extern void vPortReclaimCSA_core2( unsigned long ** pxTCB_core2 );
#define portCLEAN_UP_TCB_core2( pxTCB_core2 )    vPortReclaimCSA_core2( ( unsigned long ** ) ( pxTCB_core2 ) )


/* ICR & CCPN modifying functions to enable and disable interrupts.
 * Only interrupts with a priority lower than
 */
static void __attribute__( ( used, always_inline ) ) vPortSetCCPN_core2( unsigned char ucCCPN )
{
    __disable();
    __mtcr( portCPU_ICR_core2, ( __mfcr( portCPU_ICR_core2 ) & ~portCPU_ICR_CCPN_MSK_core2 ) | ( ucCCPN & portCPU_ICR_CCPN_MSK_core2 ) );
    __enable();
}

static void __attribute__( ( used, always_inline ) ) vPortSetICR_core2( portBASE_TYPE_core2 ulICR )
{
    __disable();
    __mtcr( portCPU_ICR_core2, ( unsigned int ) ulICR );
    __enable();
}

static portBASE_TYPE_core2 __attribute__( ( used, always_inline ) ) xPortSetCCPN_core2( unsigned char ucCCPN )
{
    uint32_t xICR;

    __disable();
    xICR = __mfcr( portCPU_ICR_core2 );
    __mtcr( portCPU_ICR_core2, ( xICR & ~portCPU_ICR_CCPN_MSK_core2 ) | ( ucCCPN & portCPU_ICR_CCPN_MSK_core2 ) );
    __enable();
    return ( portBASE_TYPE_core2 ) xICR;
}

#ifdef __cplusplus
}
#endif

#endif /* PORTMACRO_H */
