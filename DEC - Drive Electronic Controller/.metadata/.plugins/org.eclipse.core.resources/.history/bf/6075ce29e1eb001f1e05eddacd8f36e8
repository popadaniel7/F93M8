/*
 * FreeRTOS_core0 Kernel V10.5.1
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS_core0.org
 * https://github.com/FreeRTOS_core0
 *
 */

/*
 * This is the list implementation used by the scheduler.  While it is tailored
 * heavily for the schedulers needs, it is also available for use by
 * application code.
 *
 * list_ts can only store pointers to list_item_ts.  Each ListItem_t_core0 contains a
 * numeric value (xItemValue_core0).  Most of the time the lists are sorted in
 * ascending item value order.
 *
 * Lists are created already containing one list item.  The value of this
 * item is the maximum possible that can be stored, it is therefore always at
 * the end of the list and acts as a marker.  The list member pxHead always
 * points to this marker - even though it is at the tail of the list.  This
 * is because the tail contains a wrap back pointer to the true head of
 * the list.
 *
 * In addition to it's value, each list item contains a pointer to the next
 * item in the list (pxNext_core0), a pointer to the list it is in (pxContainer_core0)
 * and a pointer to back to the object that contains it.  These later two
 * pointers are included for efficiency of list manipulation.  There is
 * effectively a two way link between the object containing the list item and
 * the list item itself.
 *
 *
 * \page ListIntroduction List Implementation
 * \ingroup FreeRTOSIntro
 */


#ifndef LIST_H
#define LIST_H

#ifndef INC_FREERTOS_H
    #error "FreeRTOS_core0.h must be included before list.h"
#endif

/*
 * The list structure members are modified from within interrupts, and therefore
 * by rights should be declared volatile.  However, they are only modified in a
 * functionally atomic way (within critical sections of with the scheduler
 * suspended) and are either passed by reference into a function or indexed via
 * a volatile variable.  Therefore, in all use cases tested so far, the volatile
 * qualifier can be omitted in order to provide a moderate performance
 * improvement without adversely affecting functional behaviour.  The assembly
 * instructions generated by the IAR, ARM and GCC compilers when the respective
 * compiler's options were set for maximum optimisation has been inspected and
 * deemed to be as intended.  That said, as compiler technology advances, and
 * especially if aggressive cross module optimisation is used (a use case that
 * has not been exercised to any great extend) then it is feasible that the
 * volatile qualifier will be needed for correct optimisation.  It is expected
 * that a compiler removing essential code because, without the volatile
 * qualifier on the list structure members and with aggressive cross module
 * optimisation, the compiler deemed the code unnecessary will result in
 * complete and obvious failure of the scheduler.  If this is ever experienced
 * then the volatile qualifier can be inserted in the relevant places within the
 * list structures by simply defining configLIST_VOLATILE_core0 to volatile in
 * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
 * If configLIST_VOLATILE_core0 is not defined then the preprocessor directives below
 * will simply #define configLIST_VOLATILE_core0 away completely.
 *
 * To use volatile list structure members then add the following line to
 * FreeRTOSConfig.h (without the quotes):
 * "#define configLIST_VOLATILE_core0 volatile"
 */
#ifndef configLIST_VOLATILE_core0
    #define configLIST_VOLATILE_core0
#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */

/* *INDENT-OFF* */
#ifdef __cplusplus
    extern "C" {
#endif
/* *INDENT-ON* */

/* Macros that can be used to place known values within the list structures,
 * then check that the known values do not get corrupted during the execution of
 * the application.   These may catch the list data structures being overwritten in
 * memory.  They will not catch data errors caused by incorrect configuration or
 * use of FreeRTOS_core0.*/
#if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 == 0 )
    /* Define the macros to do nothing. */
    #define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0
    #define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0
    #define listFIRST_LIST_INTEGRITY_CHECK_VALUE_core0
    #define listSECOND_LIST_INTEGRITY_CHECK_VALUE_core0
    #define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0( pxItem_core0 )
    #define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0( pxItem_core0 )
    #define listSET_LIST_INTEGRITY_CHECK_1_VALUE_core0( pxList_core0 )
    #define listSET_LIST_INTEGRITY_CHECK_2_VALUE_core0( pxList_core0 )
    #define listTEST_LIST_ITEM_INTEGRITY_core0( pxItem_core0 )
    #define listTEST_LIST_INTEGRITY_core0( pxList_core0 )
#else /* if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 == 0 ) */
    /* Define macros that add new members into the list structures. */
    #define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0     TickType_t_core0 xListItemIntegrityValue1_core0;
    #define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0    TickType_t_core0 xListItemIntegrityValue2_core0;
    #define listFIRST_LIST_INTEGRITY_CHECK_VALUE_core0          TickType_t_core0 xListIntegrityValue1_core0;
    #define listSECOND_LIST_INTEGRITY_CHECK_VALUE_core0         TickType_t_core0 xListIntegrityValue2_core0;

/* Define macros that set the new structure members to known values. */
    #define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0( pxItem_core0 )     ( pxItem_core0 )->xListItemIntegrityValue1_core0 = pdINTEGRITY_CHECK_VALUE_core0
    #define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0( pxItem_core0 )    ( pxItem_core0 )->xListItemIntegrityValue2_core0 = pdINTEGRITY_CHECK_VALUE_core0
    #define listSET_LIST_INTEGRITY_CHECK_1_VALUE_core0( pxList_core0 )              ( pxList_core0 )->xListIntegrityValue1_core0 = pdINTEGRITY_CHECK_VALUE_core0
    #define listSET_LIST_INTEGRITY_CHECK_2_VALUE_core0( pxList_core0 )              ( pxList_core0 )->xListIntegrityValue2_core0 = pdINTEGRITY_CHECK_VALUE_core0

/* Define macros that will assert if one of the structure members does not
 * contain its expected value. */
    #define listTEST_LIST_ITEM_INTEGRITY_core0( pxItem_core0 )                      configASSERT_core0( ( ( pxItem_core0 )->xListItemIntegrityValue1_core0 == pdINTEGRITY_CHECK_VALUE_core0 ) && ( ( pxItem_core0 )->xListItemIntegrityValue2_core0 == pdINTEGRITY_CHECK_VALUE_core0 ) )
    #define listTEST_LIST_INTEGRITY_core0( pxList_core0 )                           configASSERT_core0( ( ( pxList_core0 )->xListIntegrityValue1_core0 == pdINTEGRITY_CHECK_VALUE_core0 ) && ( ( pxList_core0 )->xListIntegrityValue2_core0 == pdINTEGRITY_CHECK_VALUE_core0 ) )
#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 */


/*
 * Definition of the only type of object that a list can contain.
 */
struct xLIST_core0;
struct xLIST_ITEM_core0
{
    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0           /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 is set to 1. */
    configLIST_VOLATILE_core0 TickType_t_core0 xItemValue_core0;          /*< The value being listed.  In most cases this is used to sort the list in ascending order. */
    struct xLIST_ITEM_core0 * configLIST_VOLATILE_core0 pxNext_core0;     /*< Pointer to the next ListItem_t_core0 in the list. */
    struct xLIST_ITEM_core0 * configLIST_VOLATILE_core0 pxPrevious_core0; /*< Pointer to the previous ListItem_t_core0 in the list. */
    void * pvOwner_core0;                                     /*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
    struct xLIST_core0 * configLIST_VOLATILE_core0 pxContainer_core0;     /*< Pointer to the list in which this list item is placed (if any). */
    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0          /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 is set to 1. */
};
typedef struct xLIST_ITEM_core0 ListItem_t_core0;                   /* For some reason lint wants this as two separate definitions. */

#if ( configUSE_MINI_LIST_ITEM_core0 == 1 )
    struct xMINI_LIST_ITEM_core0
    {
        listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE_core0 /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 is set to 1. */
        configLIST_VOLATILE_core0 TickType_t_core0 xItemValue_core0;
        struct xLIST_ITEM_core0 * configLIST_VOLATILE_core0 pxNext_core0;
        struct xLIST_ITEM_core0 * configLIST_VOLATILE_core0 pxPrevious_core0;
    };
    typedef struct xMINI_LIST_ITEM_core0 MiniListItem_t_core0;
#else
    typedef struct xLIST_ITEM_core0      MiniListItem_t_core0;
#endif

/*
 * Definition of the type of queue used by the scheduler.
 */
typedef struct xLIST_core0
{
    listFIRST_LIST_INTEGRITY_CHECK_VALUE_core0      /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 is set to 1. */
    volatile UBaseType_t_core0 uxNumberOfItems_core0;
    ListItem_t_core0 * configLIST_VOLATILE_core0 pxIndex_core0; /*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY_core0 (). */
    MiniListItem_t_core0 xListEnd_core0;                  /*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
    listSECOND_LIST_INTEGRITY_CHECK_VALUE_core0     /*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES_core0 is set to 1. */
} List_t_core0;

/*
 * Access macro to set the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listSET_LIST_ITEM_OWNER_core0 listSET_LIST_ITEM_OWNER_core0
 * \ingroup LinkedList
 */
#define listSET_LIST_ITEM_OWNER_core0( pxListItem_core0, pxOwner_core0 )    ( ( pxListItem_core0 )->pvOwner_core0 = ( void * ) ( pxOwner_core0 ) )

/*
 * Access macro to get the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listGET_LIST_ITEM_OWNER_core0 listSET_LIST_ITEM_OWNER_core0
 * \ingroup LinkedList
 */
#define listGET_LIST_ITEM_OWNER_core0( pxListItem_core0 )             ( ( pxListItem_core0 )->pvOwner_core0 )

/*
 * Access macro to set the value of the list item.  In most cases the value is
 * used to sort the list in ascending order.
 *
 * \page listSET_LIST_ITEM_VALUE_core0 listSET_LIST_ITEM_VALUE_core0
 * \ingroup LinkedList
 */
#define listSET_LIST_ITEM_VALUE_core0( pxListItem_core0, xValue )     ( ( pxListItem_core0 )->xItemValue_core0 = ( xValue ) )

/*
 * Access macro to retrieve the value of the list item.  The value can
 * represent anything - for example the priority of a task_core0, or the time at
 * which a task_core0 should be unblocked.
 *
 * \page listGET_LIST_ITEM_VALUE_core0 listGET_LIST_ITEM_VALUE_core0
 * \ingroup LinkedList
 */
#define listGET_LIST_ITEM_VALUE_core0( pxListItem_core0 )             ( ( pxListItem_core0 )->xItemValue_core0 )

/*
 * Access macro to retrieve the value of the list item at the head of a given
 * list.
 *
 * \page listGET_LIST_ITEM_VALUE_core0 listGET_LIST_ITEM_VALUE_core0
 * \ingroup LinkedList
 */
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY_core0( pxList_core0 )        ( ( ( pxList_core0 )->xListEnd_core0 ).pxNext_core0->xItemValue_core0 )

/*
 * Return the list item at the head of the list.
 *
 * \page listGET_HEAD_ENTRY_core0 listGET_HEAD_ENTRY_core0
 * \ingroup LinkedList
 */
#define listGET_HEAD_ENTRY_core0( pxList_core0 )                      ( ( ( pxList_core0 )->xListEnd_core0 ).pxNext_core0 )

/*
 * Return the next list item.
 *
 * \page listGET_NEXT_core0 listGET_NEXT_core0
 * \ingroup LinkedList
 */
#define listGET_NEXT_core0( pxListItem_core0 )                        ( ( pxListItem_core0 )->pxNext_core0 )

/*
 * Return the list item that marks the end of the list
 *
 * \page listGET_END_MARKER_core0 listGET_END_MARKER_core0
 * \ingroup LinkedList
 */
#define listGET_END_MARKER_core0( pxList_core0 )                      ( ( ListItem_t_core0 const * ) ( &( ( pxList_core0 )->xListEnd_core0 ) ) )

/*
 * Access macro to determine if a list contains any items.  The macro will
 * only have the value true if the list is empty.
 *
 * \page listLIST_IS_EMPTY_core0 listLIST_IS_EMPTY_core0
 * \ingroup LinkedList
 */
#define listLIST_IS_EMPTY_core0( pxList_core0 )                       ( ( ( pxList_core0 )->uxNumberOfItems_core0 == ( UBaseType_t_core0 ) 0 ) ? pdTRUE_core0 : pdFALSE_core0 )

/*
 * Access macro to return the number of items in the list.
 */
#define listCURRENT_LIST_LENGTH_core0( pxList_core0 )                 ( ( pxList_core0 )->uxNumberOfItems_core0 )

/*
 * Access function to obtain the owner of the next entry in a list.
 *
 * The list member pxIndex_core0 is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY_core0 increments pxIndex_core0 to the next item in the list
 * and returns that entry's pxOwner_core0 parameter.  Using multiple calls to this
 * function it is therefore possible to move through every item contained in
 * a list.
 *
 * The pxOwner_core0 parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task_core0 control block.
 * The pxOwner_core0 parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxTCB_core0 pxTCB_core0 is set to the address of the owner of the next list item.
 * @param pxList_core0 The list from which the next item owner is to be returned.
 *
 * \page listGET_OWNER_OF_NEXT_ENTRY_core0 listGET_OWNER_OF_NEXT_ENTRY_core0
 * \ingroup LinkedList
 */
#define listGET_OWNER_OF_NEXT_ENTRY_core0( pxTCB_core0, pxList_core0 )                                           \
    {                                                                                          \
        List_t_core0 * const pxConstList_core0 = ( pxList_core0 );                                               \
        /* Increment the index to the next item and return the item, ensuring */               \
        /* we don't return the marker used at the end of the list.  */                         \
        ( pxConstList_core0 )->pxIndex_core0 = ( pxConstList_core0 )->pxIndex_core0->pxNext_core0;                           \
        if( ( void * ) ( pxConstList_core0 )->pxIndex_core0 == ( void * ) &( ( pxConstList_core0 )->xListEnd_core0 ) ) \
        {                                                                                      \
            ( pxConstList_core0 )->pxIndex_core0 = ( pxConstList_core0 )->pxIndex_core0->pxNext_core0;                       \
        }                                                                                      \
        ( pxTCB_core0 ) = ( pxConstList_core0 )->pxIndex_core0->pvOwner_core0;                                         \
    }

/*
 * Version of uxListRemove_core0() that does not return a value.  Provided as a slight
 * optimisation for xTaskIncrementTick_core0() by being inline.
 *
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove_core0 The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer_core0 parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page listREMOVE_ITEM_core0 listREMOVE_ITEM_core0
 * \ingroup LinkedList
 */
#define listREMOVE_ITEM_core0( pxItemToRemove_core0 ) \
    {                                     \
        /* The list item knows which list it is in.  Obtain the list from the list \
         * item. */                                                              \
        List_t_core0 * const pxList_core0 = ( pxItemToRemove_core0 )->pxContainer_core0;                 \
                                                                                 \
        ( pxItemToRemove_core0 )->pxNext_core0->pxPrevious_core0 = ( pxItemToRemove_core0 )->pxPrevious_core0; \
        ( pxItemToRemove_core0 )->pxPrevious_core0->pxNext_core0 = ( pxItemToRemove_core0 )->pxNext_core0;     \
        /* Make sure the index is left pointing to a valid item. */              \
        if( pxList_core0->pxIndex_core0 == ( pxItemToRemove_core0 ) )                              \
        {                                                                        \
            pxList_core0->pxIndex_core0 = ( pxItemToRemove_core0 )->pxPrevious_core0;                    \
        }                                                                        \
                                                                                 \
        ( pxItemToRemove_core0 )->pxContainer_core0 = NULL;                                  \
        ( pxList_core0->uxNumberOfItems_core0 )--;                                           \
    }

/*
 * Inline version of vListInsertEnd_core0() to provide slight optimisation for
 * xTaskIncrementTick_core0().
 *
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY_core0.
 *
 * The list member pxIndex_core0 is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY_core0 increments pxIndex_core0 to the next item in the list.
 * Placing an item in a list using vListInsertEnd_core0 effectively places the item
 * in the list position pointed to by pxIndex_core0.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY_core0 before
 * the pxIndex_core0 parameter again points to the item being inserted.
 *
 * @param pxList_core0 The list into which the item is to be inserted.
 *
 * @param pxNewListItem_core0 The list item to be inserted into the list.
 *
 * \page listINSERT_END_core0 listINSERT_END_core0
 * \ingroup LinkedList
 */
#define listINSERT_END_core0( pxList_core0, pxNewListItem_core0 )           \
    {                                                     \
        ListItem_t_core0 * const pxIndex_core0 = ( pxList_core0 )->pxIndex_core0; \
                                                          \
        /* Only effective when configASSERT_core0() is also defined, these tests may catch \
         * the list data structures being overwritten in memory.  They will not catch \
         * data errors caused by incorrect configuration or use of FreeRTOS_core0. */ \
        listTEST_LIST_INTEGRITY_core0( ( pxList_core0 ) );                                  \
        listTEST_LIST_ITEM_INTEGRITY_core0( ( pxNewListItem_core0 ) );                      \
                                                                                \
        /* Insert a new list item into ( pxList_core0 ), but rather than sort the list, \
         * makes the new list item the last item to be removed by a call to \
         * listGET_OWNER_OF_NEXT_ENTRY_core0(). */                 \
        ( pxNewListItem_core0 )->pxNext_core0 = pxIndex_core0;                 \
        ( pxNewListItem_core0 )->pxPrevious_core0 = pxIndex_core0->pxPrevious_core0; \
                                                             \
        pxIndex_core0->pxPrevious_core0->pxNext_core0 = ( pxNewListItem_core0 );     \
        pxIndex_core0->pxPrevious_core0 = ( pxNewListItem_core0 );             \
                                                             \
        /* Remember which list the item is in. */            \
        ( pxNewListItem_core0 )->pxContainer_core0 = ( pxList_core0 );         \
                                                             \
        ( ( pxList_core0 )->uxNumberOfItems_core0 )++;                   \
    }

/*
 * Access function to obtain the owner of the first entry in a list.  Lists
 * are normally sorted in ascending item value order.
 *
 * This function returns the pxOwner_core0 member of the first item in the list.
 * The pxOwner_core0 parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task_core0 control block.
 * The pxOwner_core0 parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxList_core0 The list from which the owner of the head item is to be
 * returned.
 *
 * \page listGET_OWNER_OF_HEAD_ENTRY_core0 listGET_OWNER_OF_HEAD_ENTRY_core0
 * \ingroup LinkedList
 */
#define listGET_OWNER_OF_HEAD_ENTRY_core0( pxList_core0 )            ( ( &( ( pxList_core0 )->xListEnd_core0 ) )->pxNext_core0->pvOwner_core0 )

/*
 * Check to see if a list item is within a list.  The list item maintains a
 * "container" pointer that points to the list it is in.  All this macro does
 * is check to see if the container and the list match.
 *
 * @param pxList_core0 The list we want to know if the list item is within.
 * @param pxListItem_core0 The list item we want to know if is in the list.
 * @return pdTRUE_core0 if the list item is in the list, otherwise pdFALSE_core0.
 */
#define listIS_CONTAINED_WITHIN_core0( pxList_core0, pxListItem_core0 )    ( ( ( pxListItem_core0 )->pxContainer_core0 == ( pxList_core0 ) ) ? ( pdTRUE_core0 ) : ( pdFALSE_core0 ) )

/*
 * Return the list a list item is contained within (referenced from).
 *
 * @param pxListItem_core0 The list item being queried.
 * @return A pointer to the List_t_core0 object that references the pxListItem_core0
 */
#define listLIST_ITEM_CONTAINER_core0( pxListItem_core0 )            ( ( pxListItem_core0 )->pxContainer_core0 )

/*
 * This provides a crude means of knowing if a list has been initialised, as
 * pxList_core0->xListEnd_core0.xItemValue_core0 is set to portMAX_DELAY_core0 by the vListInitialise_core0()
 * function.
 */
#define listLIST_IS_INITIALISED_core0( pxList_core0 )                ( ( pxList_core0 )->xListEnd_core0.xItemValue_core0 == portMAX_DELAY_core0 )

/*
 * Must be called before a list is used!  This initialises all the members
 * of the list structure and inserts the xListEnd_core0 item into the list as a
 * marker to the back of the list.
 *
 * @param pxList_core0 Pointer to the list being initialised.
 *
 * \page vListInitialise_core0 vListInitialise_core0
 * \ingroup LinkedList
 */
void vListInitialise_core0( List_t_core0 * const pxList_core0 ) PRIVILEGED_FUNCTION_core0;

/*
 * Must be called before a list item is used.  This sets the list container to
 * null so the item does not think that it is already contained in a list.
 *
 * @param pxItem_core0 Pointer to the list item being initialised.
 *
 * \page vListInitialiseItem_core0 vListInitialiseItem_core0
 * \ingroup LinkedList
 */
void vListInitialiseItem_core0( ListItem_t_core0 * const pxItem_core0 ) PRIVILEGED_FUNCTION_core0;

/*
 * Insert a list item into a list.  The item will be inserted into the list in
 * a position determined by its item value (ascending item value order).
 *
 * @param pxList_core0 The list into which the item is to be inserted.
 *
 * @param pxNewListItem_core0 The item that is to be placed in the list.
 *
 * \page vListInsert_core0 vListInsert_core0
 * \ingroup LinkedList
 */
void vListInsert_core0( List_t_core0 * const pxList_core0,
                  ListItem_t_core0 * const pxNewListItem_core0 ) PRIVILEGED_FUNCTION_core0;

/*
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY_core0.
 *
 * The list member pxIndex_core0 is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY_core0 increments pxIndex_core0 to the next item in the list.
 * Placing an item in a list using vListInsertEnd_core0 effectively places the item
 * in the list position pointed to by pxIndex_core0.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY_core0 before
 * the pxIndex_core0 parameter again points to the item being inserted.
 *
 * @param pxList_core0 The list into which the item is to be inserted.
 *
 * @param pxNewListItem_core0 The list item to be inserted into the list.
 *
 * \page vListInsertEnd_core0 vListInsertEnd_core0
 * \ingroup LinkedList
 */
void vListInsertEnd_core0( List_t_core0 * const pxList_core0,
                     ListItem_t_core0 * const pxNewListItem_core0 ) PRIVILEGED_FUNCTION_core0;

/*
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove_core0 The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer_core0 parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page uxListRemove_core0 uxListRemove_core0
 * \ingroup LinkedList
 */
UBaseType_t_core0 uxListRemove_core0( ListItem_t_core0 * const pxItemToRemove_core0 ) PRIVILEGED_FUNCTION_core0;

/* *INDENT-OFF* */
#ifdef __cplusplus
    }
#endif
/* *INDENT-ON* */

#endif /* ifndef LIST_H */
