#include "Dcm.h"
#include "DiagMaster.h"
#include "ComMaster.h"
#include "string.h"
#include "EncCal.h"
#include "McuSm.h"
#include "Dem.h"
#include "DcyHandler.h"
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

void Dcm_MainFunction(void);

void Dcm_DSC_DefaultSession(uint8* data);
void Dcm_DSC_ProgrammingSession(uint8* data);
void Dcm_DSC_ExtendedSession(uint8* data);
void Dcm_DSC_CodingSession(uint8* data);
void Dcm_DSC_CalibrationSession(uint8* data);
void Dcm_ER_HardReset(uint8* data);
void Dcm_ER_SoftReset(uint8* data);
void Dcm_TP_TesterPresent(uint8* data);
void Dcm_RDTCI_ReadSupportDTCInformation(uint8* data);
void Dcm_CDTCI_ClearDTCInformation(uint8* data);
void Dcm_CC_CommunicationControl(uint8* data);
void Dcm_CDTCS_ControlDTCSetting(uint8* data);
void Dcm_RC_WriteCoding(uint8* data);
void Dcm_RC_ReadCoding(uint8* data);
void Dcm_RC_WriteCalibration(uint8* data);
void Dcm_RC_ReadCalibration(uint8* data);
void Dcm_RC_WriteVOData(uint8* data);
void Dcm_RC_ReadVOData(uint8* data);
void Dcm_RC_RequestDiagnosticModeActive(uint8* data);
void Dcm_RDBI_AliveTime(uint8* data);
void Dcm_RDBI_SWVersion(uint8* data);
void Dcm_RDBI_ActiveDiagnosticSession(uint8* data);
void Dcm_RC_Request701Active(uint8* data);
void Dcm_RC_Request703Active(uint8* data);
void Dcm_RC_RequestMasterActive(uint8* data);
void Dcm_RC_ResetDcy(uint8* data);
// Called when a complete ISO-TP diagnostic message has been reassembled.
void Dcm_ProcessDiagnosticRequest(const uint8 *data, uint16 length);

typedef struct
{
        Can_RxMsg_t diagnosticMessage;
        uint8 isAllowed;
        uint8 msgType;
        uint8 masterDiagReqId;
}Dcm_DiagReq_t;

uint8 Dcm_SwVersion[4u] = {1u,1u,1u,1u};
uint8 Dcm_GlobalIndex = 0u;
uint8 Dcm_GlobalMasterIdReq = 0u;
Dcm_DiagReq_t Dcm_Receive_DiagnosticMessageBuffer[50u];
uint32 Dcm_Rx_DiagBufCnt = 0u;
uint32 Dcm_MainCounter = 0u;

typedef void (*FuncPtr_t)(uint8*);
FuncPtr_t Dcm_FuncPtr[26u] =
{
        Dcm_DSC_DefaultSession,
        Dcm_DSC_ProgrammingSession,
        Dcm_DSC_ExtendedSession,
        Dcm_DSC_CodingSession,
        Dcm_DSC_CalibrationSession,
        Dcm_ER_HardReset,
        Dcm_ER_SoftReset,
        Dcm_TP_TesterPresent,
        Dcm_RDTCI_ReadSupportDTCInformation,
        Dcm_CDTCI_ClearDTCInformation,
        Dcm_CC_CommunicationControl,
        Dcm_CDTCS_ControlDTCSetting,
        Dcm_RC_WriteCoding,
        Dcm_RC_ReadCoding,
        Dcm_RC_WriteCalibration,
        Dcm_RC_ReadCalibration,
        Dcm_RC_WriteVOData,
        Dcm_RC_ReadVOData,
        Dcm_RC_RequestDiagnosticModeActive,
        Dcm_RDBI_SWVersion,
        Dcm_RDBI_ActiveDiagnosticSession,
        Dcm_RDBI_AliveTime,
        Dcm_RC_Request701Active,
        Dcm_RC_Request703Active,
        Dcm_RC_RequestMasterActive,
        Dcm_RC_ResetDcy
};

void Dcm_MainFunction(void)
{
    static uint8 localData = 0u;
    static uint32* localArr;
    /* Copy data in exclusive area. */
    IfxCpu_disableInterrupts();
    memcpy(&Dcm_Receive_DiagnosticMessageBuffer,
            &DiagMaster_Transmit_DiagnosticMessageBuffer,
            sizeof(DiagMaster_Transmit_DiagnosticMessageBuffer));
    memset(&DiagMaster_Transmit_DiagnosticMessageBuffer,
            0u,
            sizeof(DiagMaster_Transmit_DiagnosticMessageBuffer));
    IfxCpu_enableInterrupts();
    IfxCpu_disableInterrupts();
    /* Process the queue. */
    for(uint8 i = 0u; i < Dcm_Rx_DiagBufCnt; i++)
    {
        /* Check if the request is for master only. */
        if(0x6FFu == Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId)
        {
            /* Process master response. */
            if(1u == Dcm_Receive_DiagnosticMessageBuffer[i].isAllowed)
            {
                if(DIAGMASTER_ISOTPRXTX_TYPE == Dcm_Receive_DiagnosticMessageBuffer[i].msgType)
                {
                    switch(Dcm_GlobalMasterIdReq)
                    {
                        case 0x08u:
                        {
                            /* Get ISO-TP message in ISO-TP buffer. */
                            Can_IsoTp_Transmit(0x6ffu,
                                    &Dem_DtcArray[0u],
                                    80u);
                            /* Process ISO-TP request. */
                            Can_IsoTp_MainFunction();
                            Dcm_GlobalMasterIdReq = 0u;
                            break;
                        }
                        case 0x04u:
                        {
                            EncCal_ReadCoding(localArr);
                            /* Get ISO-TP message in ISO-TP buffer. */
                            Can_IsoTp_OnCanReceive((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                                    (uint8*)localArr,
                                    ENCCAL_CODING_SIZE);
                            /* Process ISO-TP request. */
                            Can_IsoTp_MainFunction();
                            break;
                        }

                        case 0x05u:
                        {
                            EncCal_ReadCalibration(localArr);
                            /* Get ISO-TP message in ISO-TP buffer. */
                            Can_IsoTp_OnCanReceive((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                                    (uint8*)localArr,
                                    ENCCAL_CALIBRATION_SIZE);
                            /* Process ISO-TP request. */
                            Can_IsoTp_MainFunction();
                            break;
                        }
                        default:
                            break;
                    }
                }
                else
                {
                    if(0x19u != Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[1u])
                    {
                        Dcm_FuncPtr[Dcm_Receive_DiagnosticMessageBuffer[i].masterDiagReqId]((uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData);
                        Can_IsoTp_SendFrame((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                                (uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData,
                                ((Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
                    }
                    else
                    {
                        Dcm_GlobalIndex = i;
                        Dcm_GlobalMasterIdReq = Dcm_Receive_DiagnosticMessageBuffer[i].masterDiagReqId;                   
                        Dcm_FuncPtr[Dcm_Receive_DiagnosticMessageBuffer[i].masterDiagReqId]((uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData);
                        Dcm_GlobalIndex = 0u;
                    }
                }
            }
            else
            {
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] = 0x03u;
                localData = (uint8)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[1u];
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[1u] = 0x7Fu;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[2u] = localData;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[3u] = 0x22u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[4u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[5u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[6u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[7u] = 0u;

                Can_IsoTp_SendFrame((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                        (uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData,
                        ((Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
            }
        }
        else
        {
            /* Check if we are allowed to respond to the tester. */
            if(1u == Dcm_Receive_DiagnosticMessageBuffer[i].isAllowed)
            {
                /* Check if response type shall be ISO-TP. */
                if(DIAGMASTER_ISOTPRXTX_TYPE == Dcm_Receive_DiagnosticMessageBuffer[i].msgType)
                {
                    /* Get ISO-TP message in ISO-TP buffer. */
                    Can_IsoTp_OnCanReceive((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                            (uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData,
                            ((Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
                    /* Process ISO-TP request. */
                    Can_IsoTp_MainFunction();
                }
                else
                {
                    /* Non-ISO-TP request. */
                    /* Slave request or response. */
                    /* We do not know, we do not care. As long as it is allowed. */
                    /* Even though it is not an ISO-TP frame, we have everything we need in the ISO-TP Send Frame function call. */
                    Can_IsoTp_SendFrame((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                            (uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData,
                            ((Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
                }
            }
            else
            {
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] = 0x03u;
                localData = (uint8)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[1u];
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[1u] = 0x7Fu;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[2u] = localData;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[3u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[4u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[5u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[6u] = 0u;
                Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[7u] = 0u;

                Can_IsoTp_SendFrame((uint16)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxMsg.messageId,
                        (uint8*)Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData,
                        ((Dcm_Receive_DiagnosticMessageBuffer[i].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
            }
        }
        localData = 0u;
    }
    memset(&Dcm_Receive_DiagnosticMessageBuffer, 0u, sizeof(Dcm_Receive_DiagnosticMessageBuffer));
    IfxCpu_enableInterrupts();
    Dcm_MainCounter++;
}

void Dcm_DSC_DefaultSession(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_ActiveSessionState = 1u;
}

void Dcm_DSC_ProgrammingSession(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_ActiveSessionState = 2u;
}

void Dcm_DSC_ExtendedSession(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_ActiveSessionState = 3u;
}

void Dcm_DSC_CodingSession(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_ActiveSessionState = 4u;
}

void Dcm_DSC_CalibrationSession(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_ActiveSessionState = 5u;
}

void Dcm_ER_HardReset(uint8* data)
{
    (void)data;
    //Nvm_WriteAll();
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxMsg.dataLengthCode = IfxCan_DataLengthCode_3;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxMsg.messageId = 0x6FFU;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[0u] = 0x02u;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[1u] = 0x51u;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[2u] = 0x01u;
    Can_IsoTp_SendFrame((uint16)Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxMsg.messageId,
            (uint8*)Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData,
            ((Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
    for (uint32 index = 0U; index < (uint32)90000U; index++){__asm("nop");}
    IfxScuRcu_performReset(IfxScuRcu_ResetType_application, 0u);
}

void Dcm_ER_SoftReset(uint8* data)
{
    (void)data;
    //Nvm_WriteAll();
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxMsg.dataLengthCode = IfxCan_DataLengthCode_3;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxMsg.messageId = 0x6FFU;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[0u] = 0x02u;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[1u] = 0x51u;
    Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[2u] = 0x02u;
    Can_IsoTp_SendFrame((uint16)Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxMsg.messageId,
            (uint8*)Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData,
            ((Dcm_Receive_DiagnosticMessageBuffer[0u].diagnosticMessage.rxData[0u] & 0x0Fu) + 1u));
    for (uint32 index = 0U; index < (uint32)90000U; index++){__asm("nop");}
    IfxScuRcu_performReset(IfxScuRcu_ResetType_application, 0u);
}

void Dcm_TP_TesterPresent(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_TesterPresentActive = 1u;
}

void Dcm_RDTCI_ReadSupportDTCInformation(uint8* data)
{
    (void)data;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxMsg.dataLengthCode = IfxCan_DataLengthCode_8;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxMsg.messageId = 0x6FFu;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[0u] = 0x07u;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[1u] = 0x10u;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[2u] = 0x50u;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[3u] = 0x59u;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[4u] = 0x0Au;
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[5u] = Dem_DtcArray[0u];
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[6u] = Dem_DtcArray[1u];
    Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[7u] = Dem_DtcArray[2u];
    Can_IsoTp_Transmit((uint16)Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxMsg.messageId,
            &Dcm_Receive_DiagnosticMessageBuffer[Dcm_GlobalIndex].diagnosticMessage.rxData[0u],
            80u);
}

void Dcm_CDTCI_ClearDTCInformation(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    Dem_PreInit();
    Dem_Init();
}

void Dcm_CC_CommunicationControl(uint8* data)
{
    data[1u] = data[1u] + 0x40u;

    if(data[2u] == 1u)
    {
        ComMaster_SwitchTxOff = 0u;
    }
    else
    {
        ComMaster_SwitchTxOff = 1u;
    }
}

void Dcm_CDTCS_ControlDTCSetting(uint8* data)
{
    data[1u] = data[1u] + 0x40u;

    if(data[2u] == 1u)
    {
        Dem_ControlDtcSetting = 1u;
    }
    else if(data[2u] == 2u)
    {
        Dem_ControlDtcSetting = 0u;
    }
    else
    {
        /* Do nothing. */
    }
}

void Dcm_RC_WriteCoding(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    //TODO
}

void Dcm_RC_ReadCoding(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    //TODO
}

void Dcm_RC_WriteCalibration(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    //TODO
}

void Dcm_RC_ReadCalibration(uint8* data)
{
    data[1] = data[1] + 0x40u;
    //TODO
}

void Dcm_RC_WriteVOData(uint8* data)
{
    data[1] = data[1] + 0x40u;
    //TODO
}

void Dcm_RC_ReadVOData(uint8* data)
{
    data[1] = data[1] + 0x40u;
    //TODO
}

void Dcm_RC_RequestDiagnosticModeActive(uint8* data)
{
    data[1] = data[1] + 0x40u;

    if(data[3u] == 1u)
    {
        DiagMaster_RequestDiagnosticMode = 0u;
    }
    else
    {
        DiagMaster_RequestDiagnosticMode = 1u;
    }
}

void Dcm_RDBI_AliveTime(uint8* data)
{
    data[0u] = data[0u] + 0x04u;
    data[1u] = data[1u] + 0x40u;
    data[2u] = (uint8)DiagMaster_AliveTime >> 24u;
    data[3u] = (uint8)DiagMaster_AliveTime >> 16u;
    data[4u] = (uint8)DiagMaster_AliveTime >> 8u;
    data[5u] = (uint8)DiagMaster_AliveTime;
}

void Dcm_RDBI_SWVersion(uint8* data)
{
    data[0u] = data[0u] + 0x04u;
    data[1u] = data[1u] + 0x40u;
    data[2u] = Dcm_SwVersion[0u];
    data[3u] = Dcm_SwVersion[1u];
    data[4u] = Dcm_SwVersion[2u];
    data[5u] = Dcm_SwVersion[3u];
}

void Dcm_RDBI_ActiveDiagnosticSession(uint8* data)
{
    data[0u] = data[0u] + 0x01u;
    data[1u] = data[1u] + 0x40u;
    data[4u] = DiagMaster_ActiveSessionState;
}

void Dcm_RC_Request701Active(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_Is701Active = 0x701u;
    DiagMaster_Is703Active = 0u;
    DiagMaster_IsMasterActive = 0u;
}

void Dcm_RC_Request703Active(uint8* data)
{
    data[1u] = data[1u] + 0x40u;
    DiagMaster_Is701Active = 0u;
    DiagMaster_Is703Active = 0x703u;
    DiagMaster_IsMasterActive = 0u;
}

void Dcm_RC_RequestMasterActive(uint8* data)
{
    data[1] = data[1] + 0x40u;
    DiagMaster_Is701Active = 0u;
    DiagMaster_Is703Active = 0u;
    DiagMaster_IsMasterActive = 0x6ffu;
}

void Dcm_RC_ResetDcy(uint8* data)
{
    data[1] = data[1] + 0x40u;
    DcyHandler_CanRx_ResetDcy = 1u;
}

void Dcm_ProcessDiagnosticRequest(const uint8_t *data, uint16_t length)
{
    if (length < 1)
        return;

    uint8_t serviceId = data[0];

    // --- Service 0x19: Read DTCs (Request: 19 0A) ---
    if (serviceId == 0x19)
    {
        if (length >= 2 && data[1] == 0x0A)
        {
            // Build positive response: 0x59 0x0A followed by 80 DTC bytes.
            uint8_t response[2 + 80];
            response[0] = 0x59;  // Positive response for 0x19
            response[1] = 0x0A;
            // For demonstration, fill 80 bytes with dummy DTC data.
            for (uint8_t i = 0; i < 80; i++)
            {
                response[2 + i] = i; // Replace with actual DTC data as needed.
            }
            // Transmit the response via ISO-TP (from ECU ID 0x6FF)
            CanIsoTpTransmit(0x6FF, response, sizeof(response));
        }
    }
    // --- Service 0x31: Either read or write calibration/coding data ---
    else if (serviceId == 0x31)
    {
        // Ensure that the request has at least 4 bytes so that sub-function exists.
        if (length < 4)
            return;

        uint8_t subFunction = data[3];

        // Group A: Tester requests data (ECU responds with stored data)
        // Sub-functions: 0x14, 0x15, 0x16
        if (subFunction == 0x14 || subFunction == 0x15 || subFunction == 0x16)
        {
            // Build positive response: first byte 0x71, then sub-function, then data payload.
            // For demonstration, we generate dummy data of variable length.
            uint8_t response[32] = {0};
            uint16_t respLen = 0;
            response[0] = 0x71;  // Positive response for service 0x31
            response[1] = subFunction;

            if (subFunction == 0x14)
            {
                // For example, send 12 data bytes.
                respLen = 2 + 12;
                for (uint8_t i = 0; i < 12; i++)
                    response[2 + i] = 0x10 + i; // Dummy data; replace as needed.
            }
            else if (subFunction == 0x15)
            {
                // For example, send 8 data bytes.
                respLen = 2 + 8;
                for (uint8_t i = 0; i < 8; i++)
                    response[2 + i] = 0x20 + i;
            }
            else if (subFunction == 0x16)
            {
                // For example, send 16 data bytes.
                respLen = 2 + 16;
                for (uint8_t i = 0; i < 16; i++)
                    response[2 + i] = 0x30 + i;
            }
            // Transmit the response via ISO-TP
            CanIsoTpTransmit(0x6FF, response, respLen);
        }
        // Group B: Tester sends data to ECU (store for later processing)
        // Sub-functions: 0x04, 0x05, 0x06
        else if (subFunction == 0x04 || subFunction == 0x05 || subFunction == 0x06)
        {
            // The data payload follows after the first 4 bytes.
            uint16_t payloadLength = (length > 4) ? (length - 4) : 0;
            if (subFunction == 0x04)
            {
                if (payloadLength > sizeof(storedData_04))
                    payloadLength = sizeof(storedData_04);
                memcpy(storedData_04, &data[4], payloadLength);
            }
            else if (subFunction == 0x05)
            {
                if (payloadLength > sizeof(storedData_05))
                    payloadLength = sizeof(storedData_05);
                memcpy(storedData_05, &data[4], payloadLength);
            }
            else if (subFunction == 0x06)
            {
                if (payloadLength > sizeof(storedData_06))
                    payloadLength = sizeof(storedData_06);
                memcpy(storedData_06, &data[4], payloadLength);
            }
            // Send an echo positive response: 0x71 followed by echoing bytes 1,2 and the sub-function.
            uint8 response[4] = {0};
            response[0] = 0x71;
            response[1] = data[1]; // echo original byte (if needed)
            response[2] = data[2]; // echo original byte (if needed)
            response[3] = subFunction;
            CanIsoTpTransmit(0x6FF, response, sizeof(response));
        }
    }
}
