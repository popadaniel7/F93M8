#include <Nvm.h>
#include "Crc.h"
#include "string.h"
#include "Fls.h"
#include "EncCal.h"

uint32 Nvm_CurrentAddress;
uint32 Nvm_SectorSwitchActivated;
uint32 Nvm_CurrentSector;
Nvm_Header_t Nvm_HeaderArr[NVM_NO_BLOCKS]=
{
        {0u, 0u, 0u, 0u}, // block 0 dummy not used
        {1u, ENCCAL_CALIBRATION_SIZE, 0u, 0u}, // calibration block
        {2u, ENCCAL_CODING_SIZE, 0u, 0u}, // coding block
        {3u, sizeof(EncCal_VODataComplete)/sizeof(uint32), 0u, 0u}, // VO data block
        //{4u, DEM_DTC_SIZE, 0u, 0u}, // dtc data block
};
Nvm_NvStat_t Nvm_NvStatArr[NVM_NO_BLOCKS] =
{
        {0u, 0u, 0u}, // block 0 dummy not used
        {ENCCAL_CALIBRATION_SIZE, 0u, 0u,}, // calibration block
        {ENCCAL_CODING_SIZE, 0u, 0u}, // coding block
        {sizeof(EncCal_VODataComplete)/sizeof(uint32), 0u, 0u}, // VO data block
        //{DEM_DTC_SIZE, 0u, 0u}, // dtc data block
};
Nvm_Block_t Nvm_BlockDataList[NVM_NO_BLOCKS] =
{
        {NULL_PTR, 0u}, // block 0 dummy not used
        {(uint32*)&EncCal_Calibration_Buffer, 0u},
        {(uint32*)&EncCal_Coding_Buffer, 0u},
        {(uint32*)&EncCal_VODataComplete, 0u},
        //{(uint32*)&Dem_DtcArray, 0u},
};
Nvm_Block_t Nvm_RomDefaults_BlockDataList[NVM_NO_BLOCKS] =
{
        {NULL_PTR, 0u}, // block 0 dummy not used
        {(uint32*)&EncCal_Calibration_DefaultBuffer, 0u},
        {(uint32*)&EncCal_Coding_DefaultBuffer, 0u},
        {(uint32*)&EncCal_VODataComplete_Default, 0u},
        //{(uint32*)&Dem_DtcArray, 0u},
};

uint8 Nvm_WriteAllFinished;
uint8 Nvm_ReadAllFinished;

void Nvm_SectorSwitch(void);
void Nvm_WriteBlock(uint16 blockId, uint32 *data);
void Nvm_ReadBlock(uint32 blockId, uint32 *data);
void Nvm_FindCurrentAddress();
void Nvm_ReadAll(void);
void Nvm_WriteAll(void);

void Nvm_SectorSwitch(void)
{

}

void Nvm_WriteBlock(uint16 blockId, uint32 *data)
{
    uint32 address = 0u;
    uint32 crc = 0u;
    uint16 size = 0u;

    address = Nvm_CurrentAddress;
    size = Nvm_NvStatArr[blockId].blockSize;
    crc = Crc_Calculate(data, size, 0u);

    if((address + NVM_SIZE_HEADER_BYTES + Nvm_NvStatArr[blockId].blockSize + 8) < 0xAF040000)
    {
        Fls_WriteBlock(address, (uint32*)&Nvm_HeaderArr[blockId], NVM_SIZE_HEADER_BYTES);
        address += NVM_SIZE_HEADER_BYTES;
        Fls_WriteBlock(address, data, Nvm_NvStatArr[blockId].blockSize);
        address += Nvm_NvStatArr[blockId].blockSize;
        Fls_WriteBlock(address, crc, 8u);
        address += 8u;
        Nvm_CurrentAddress = address;
    }
    else
    {
        /* Sector switch. */
        __debug();
//        Nvm_SectorSwitch();
//        Fls_WriteBlock(address, (uint32*)&Nvm_HeaderArr[blockId], NVM_SIZE_HEADER_BYTES);
//        address += NVM_SIZE_HEADER_BYTES;
//        Fls_WriteBlock(address, data, Nvm_NvStatArr[blockId].blockSize);
//        address += Nvm_NvStatArr[blockId].blockSize;
//        Fls_WriteBlock(address, crc, 8u);
//        address += 8u;
//        Nvm_CurrentAddress = address;
    }
}
void Nvm_ReadBlock(uint32 blockId, uint32 *data)
{
    *data = Nvm_BlockDataList[blockId].data;
}

void Nvm_FindCurrentAddress()
{
    uint32 localAddress = Nvm_CurrentAddress;
    uint32 startPattern[2] = {0, 0};
    Nvm_Header_t localHeader;
    uint8 localBlockId = 0u;
    uint8 localIterator = 0u;

    if(0u == localAddress)
    {
        localAddress = DFLASH_STARTING_ADDRESS;
        Nvm_CurrentAddress = localAddress;
    }
    else
    {
        /* Do nothing. */
    }

    if(DFLASH_STARTING_ADDRESS == localAddress ||
            DFLASH_SECOND_SECTOR_ADDRESS == localAddress)
    {
        /* Read start pattern of the sector. */
        Fls_ReadBlock(localAddress, (uint32*)&startPattern, 8u);

        if(0xA5A5 == startPattern[0] && 0xA5A5 == startPattern[1])
        {
            /* Sector pattern identified, proceed with header identification. */
            localAddress += 8u;

            while(localAddress + 8u < 0xAF040000)
            {
                Fls_ReadBlock(localAddress, (uint32*)&localHeader, NVM_SIZE_HEADER_BYTES);

                localBlockId = localHeader.blockId;

                if(0u != localBlockId
                        && NVM_NO_BLOCKS > localBlockId)
                {
                    if(localHeader.blockId == Nvm_HeaderArr[localBlockId].blockId
                            && localHeader.blockSize == Nvm_HeaderArr[localBlockId].blockSize)
                    {
                        Nvm_HeaderArr[localBlockId].blockId = localHeader.blockId;
                        Nvm_HeaderArr[localBlockId].blockSize = localHeader.blockSize;
                        Nvm_NvStatArr[localBlockId].blockSize = localHeader.blockSize;
                        Nvm_NvStatArr[localBlockId].blockAddress = localAddress + 8u;
                        localAddress += localHeader.blockSize + 8u; // 8u crc size and padding
                        Nvm_CurrentAddress = localAddress;
                    }
                    else
                    {
                        Nvm_HeaderArr[localBlockId].blockId = 0xFFu;
                        Nvm_HeaderArr[localBlockId].blockSize = 0xFFu;
                        localAddress += 8u;
                        Nvm_CurrentAddress = localAddress;
                    }
                }
                else
                {
                    localAddress += 8u;
                    Nvm_CurrentAddress = localAddress;
                }
            }
        }
        else if(0u != startPattern[0] && 0u != startPattern[1])
        {
            __asm("nop");
            __debug();
            //            /* Corrupted pattern, erase the data-flash. */
            //            Fls_Erase(localAddress);
            //            /* Write sector pattern, assumption is that the data-flash is empty. */
            //            startPattern[0] = 0xA5A5u;
            //            startPattern[1] = 0xA5A5u;
            //            Fls_WriteBlock(localAddress, (uint32*)&startPattern, 8u);
            //            localAddress += 8u;
            //            Nvm_CurrentAddress = localAddress;
        }
        else
        {
            /* Write sector pattern, assumption is that the data-flash is empty. */
            startPattern[0] = 0xA5A5u;
            startPattern[1] = 0xA5A5u;
            Fls_WriteBlock(localAddress, (uint32*)&startPattern, 8u);
            localAddress += 8u;
            Nvm_CurrentAddress = localAddress;
        }
    }
    else
    {
        /* Do nothing. */
    }


}

void Nvm_ReadAll(void)
{
    Nvm_FindCurrentAddress();

    for(uint8 i = 1u; i < NVM_NO_BLOCKS; i++)
    {
        if((Nvm_HeaderArr[i].blockId != 0u) && (Nvm_HeaderArr[i].blockId != 0xFF)
                && (Nvm_HeaderArr[i].blockSize != 0u && Nvm_HeaderArr[i].blockSize != 0xFF))
        {
            Fls_ReadBlock(Nvm_NvStatArr[i].blockAddress, (uint32*)&Nvm_BlockDataList[i].data, Nvm_NvStatArr[i].blockSize);
        }
        else
        {
            // write ROM defaults, to be added
        }
    }
}

void Nvm_WriteAll(void)
{

}
