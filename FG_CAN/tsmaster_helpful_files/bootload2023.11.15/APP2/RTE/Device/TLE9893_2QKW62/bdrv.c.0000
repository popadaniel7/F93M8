/*
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 **********************************************************************************************************************/

/*******************************************************************************
**                                  Includes                                  **
*******************************************************************************/

#include "bdrv.h"

/*******************************************************************************
**                        Private Constant Declarations                       **
*******************************************************************************/

/*******************************************************************************
**                         Private Macro Declarations                         **
*******************************************************************************/

/*******************************************************************************
**                        Private Variable Definitions                        **
*******************************************************************************/

/*******************************************************************************
**                        Private Function Declarations                       **
*******************************************************************************/

/*******************************************************************************
**                         Global Function Definitions                        **
*******************************************************************************/

/** \brief Initialize the Charge Pump in the BDRV module
 *
 * \param none
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_initCP(void)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if (BDRV_GLOBCONF_EN == 1)
  {
    BDRV->CP_CTRL.reg = (uint32)BDRV_CP_CTRL;
    BDRV->CP_CLK_CTRL.reg = (uint32)BDRV_CP_CLK_CTRL;
  }
  else
  {
    e_returnCode = ERR_LOG_CODE_MODULE_DISABLED_IN_CW;
  }
  
  return e_returnCode;
}

/** \brief Initialize all CW registers of the BDRV module
 *
 * \param none
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_init(void)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;
  
  if (BDRV_GLOBCONF_EN == 1)
  {
    /* Clear status bit */
    BDRV->STSCLR.reg = (uint32)0xFFFFFFFF;
    /* Configure bridge driver register */
    BDRV->CTRL1.reg = (uint32)BDRV_CTRL1;
    BDRV->CTRL2.reg = (uint32)BDRV_CTRL2;
    BDRV->PWMSRCSEL.reg = (uint32)BDRV_PWMSRCSEL;
    BDRV->SEQMAP.reg = (uint32)BDRV_SEQMAP;
    BDRV->PROT_CTRL.reg = (uint32)BDRV_PROT_CTRL;
    BDRV->HB1IGATECLMPC.reg = (uint32)BDRV_HB1IGATECLMPC;
    BDRV->HB2IGATECLMPC.reg = (uint32)BDRV_HB2IGATECLMPC;
    BDRV->HB3IGATECLMPC.reg = (uint32)BDRV_HB3IGATECLMPC;
    BDRV->LS1CONSTTC.reg = (uint32)BDRV_LS1CONSTTC;
    BDRV->LS1CONSTIC.reg = (uint32)BDRV_LS1CONSTIC;
    BDRV->HS1CONSTTC.reg = (uint32)BDRV_HS1CONSTTC;
    BDRV->HS1CONSTIC.reg = (uint32)BDRV_HS1CONSTIC;
    BDRV->LS2CONSTTC.reg = (uint32)BDRV_LS2CONSTTC;
    BDRV->LS2CONSTIC.reg = (uint32)BDRV_LS2CONSTIC;
    BDRV->HS2CONSTTC.reg = (uint32)BDRV_HS2CONSTTC;
    BDRV->HS2CONSTIC.reg = (uint32)BDRV_HS2CONSTIC;
    BDRV->LS1SEQOFFTC.reg = (uint32)BDRV_LS1SEQOFFTC;
    BDRV->LS1SEQOFFIC.reg = (uint32)BDRV_LS1SEQOFFIC;
    BDRV->HS1SEQOFFTC.reg = (uint32)BDRV_HS1SEQOFFTC;
    BDRV->HS1SEQOFFIC.reg = (uint32)BDRV_HS1SEQOFFIC;
    BDRV->LS2SEQOFFTC.reg = (uint32)BDRV_LS2SEQOFFTC;
    BDRV->LS2SEQOFFIC.reg = (uint32)BDRV_LS2SEQOFFIC;
    BDRV->HS2SEQOFFTC.reg = (uint32)BDRV_HS2SEQOFFTC;
    BDRV->HS2SEQOFFIC.reg = (uint32)BDRV_HS2SEQOFFIC;
    BDRV->LS1SEQONTC.reg = (uint32)BDRV_LS1SEQONTC;
    BDRV->LS1SEQONIC.reg = (uint32)BDRV_LS1SEQONIC;
    BDRV->HS1SEQONTC.reg = (uint32)BDRV_HS1SEQONTC;
    BDRV->HS1SEQONIC.reg = (uint32)BDRV_HS1SEQONIC;
    BDRV->LS2SEQONTC.reg = (uint32)BDRV_LS2SEQONTC;
    BDRV->LS2SEQONIC.reg = (uint32)BDRV_LS2SEQONIC;
    BDRV->HS2SEQONTC.reg = (uint32)BDRV_HS2SEQONTC;
    BDRV->HS2SEQONIC.reg = (uint32)BDRV_HS2SEQONIC;
    BDRV->SEQOFFT4I4.reg = (uint32)BDRV_SEQOFFT4I4;
    BDRV->HCDIS.reg = (uint32)BDRV_HCDIS;
    BDRV->ASEQC.reg = (uint32)BDRV_ASEQC;
    BDRV->ASEQERRCNT.reg = (uint32)BDRV_ASEQERRCNT;
    BDRV->ASEQONTMIN.reg = (uint32)BDRV_ASEQONTMIN;
    BDRV->ASEQONIMIN.reg = (uint32)BDRV_ASEQONIMIN;
    BDRV->ASEQONTMAX.reg = (uint32)BDRV_ASEQONTMAX;
    BDRV->ASEQONIMAX.reg = (uint32)BDRV_ASEQONIMAX;
    BDRV->ASEQOFFTMIN.reg = (uint32)BDRV_ASEQOFFTMIN;
    BDRV->ASEQOFFIMIN.reg = (uint32)BDRV_ASEQOFFIMIN;
    BDRV->ASEQOFFTMAX.reg = (uint32)BDRV_ASEQOFFTMAX;
    BDRV->ASEQOFFIMAX.reg = (uint32)BDRV_ASEQOFFIMAX;
    BDRV->ASEQOFFADDDLY.reg = (uint32)BDRV_ASEQOFFADDDLY;
    #if (UC_SERIES == 989)
      BDRV->LS3CONSTTC.reg = (uint32)BDRV_LS3CONSTTC;
      BDRV->LS3CONSTIC.reg = (uint32)BDRV_LS3CONSTIC;
      BDRV->HS3CONSTTC.reg = (uint32)BDRV_HS3CONSTTC;
      BDRV->HS3CONSTIC.reg = (uint32)BDRV_HS3CONSTIC;
      BDRV->LS3SEQOFFTC.reg = (uint32)BDRV_LS3SEQOFFTC;
      BDRV->LS3SEQOFFIC.reg = (uint32)BDRV_LS3SEQOFFIC;
      BDRV->HS3SEQOFFTC.reg = (uint32)BDRV_HS3SEQOFFTC;
      BDRV->HS3SEQOFFIC.reg = (uint32)BDRV_HS3SEQOFFIC;
      BDRV->LS3SEQONTC.reg = (uint32)BDRV_LS3SEQONTC;
      BDRV->LS3SEQONIC.reg = (uint32)BDRV_LS3SEQONIC;
      BDRV->HS3SEQONTC.reg = (uint32)BDRV_HS3SEQONTC;
      BDRV->HS3SEQONIC.reg = (uint32)BDRV_HS3SEQONIC;
    #endif
    
    if (BEMFC_GLOBCONF_EN == 1)
    {
      BDRV->BEMFC_CTRL.reg = (uint32)BDRV_BEMFC_CTRL;
    }
    
    /* Enable bridge driver */
    #if (UC_SERIES == 988)
      e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en);
    #elif (UC_SERIES == 989)
      e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en);
    #endif
  }
    else
  {
    e_returnCode = ERR_LOG_CODE_MODULE_DISABLED_IN_CW;
  }

  return e_returnCode;
}

#if (UC_SERIES == 988)
/** \brief Configure the 2 half-bridges of the device TLE988x
 *
 * \param e_ls1Cfg Configuration of the low-side driver 1
 * \param e_hs1Cfg Configuration of the high-side driver 1
 * \param e_ls2Cfg Configuration of the low-side driver 2
 * \param e_hs2Cfg Configuration of the high-side driver 2
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setBridge(tBDRV_chCfg e_ls1Cfg, tBDRV_chCfg e_hs1Cfg, tBDRV_chCfg e_ls2Cfg, tBDRV_chCfg e_hs2Cfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_ls1Cfg >= BDRV_chCfg_off) && (e_ls1Cfg <= BDRV_chCfg_on) && (e_hs1Cfg >= BDRV_chCfg_off) && (e_hs1Cfg <= BDRV_chCfg_hsDcs) && (e_ls2Cfg >= BDRV_chCfg_off) && (e_ls2Cfg <= BDRV_chCfg_on) && (e_hs2Cfg >= BDRV_chCfg_off) && (e_hs2Cfg <= BDRV_chCfg_hsDcs))
  {
    /* Setting Low Side 1 */
    if (e_ls1Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_ls1Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
    }
    else if (e_ls1Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.LS1_ON = (uint8)0;
      BDRV->CTRL1.bit.LS1_PWM = (uint8)1;
    }
    else /* e_ls1Cfg == BDRV_chCfg_on */
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.LS1_PWM = (uint8)0;
      BDRV->CTRL1.bit.LS1_ON = (uint8)1;
    }

    /* Setting High Side 1 */
    if (e_hs1Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_hs1Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
    }
    else if (e_hs1Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.HS1_ON = (uint8)0;
      BDRV->CTRL1.bit.HS1_PWM = (uint8)1;
    }
    else if (e_hs1Cfg == BDRV_chCfg_on)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.HS1_PWM = (uint8)0;
      BDRV->CTRL1.bit.HS1_ON = (uint8)1;
    }
    else /* e_hs1Cfg == BDRV_chCfg_hsDcs */
    {
      /* Clamping off current must be set to 0 before enabling diagnosis current source */
      BDRV->HB1IGATECLMPC.bit.HB1_ICLMPOFF = 0;
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.HS1_DCS_EN = (uint8)1;
    }

    /* Setting Low Side 2 */
    if (e_ls2Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_ls2Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
    }
    else if (e_ls2Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.LS2_ON = (uint8)0;
      BDRV->CTRL1.bit.LS2_PWM = (uint8)1;
    }
    else /* e_ls2Cfg == BDRV_chCfg_on */
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.LS2_PWM = (uint8)0;
      BDRV->CTRL1.bit.LS2_ON = (uint8)1;
    }

    /* Setting High Side 2 */
    if (e_hs2Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_hs2Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
    }
    else if (e_hs2Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.HS2_ON = (uint8)0;
      BDRV->CTRL1.bit.HS2_PWM = (uint8)1;
    }
    else if (e_hs2Cfg == BDRV_chCfg_on)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.HS2_PWM = (uint8)0;
      BDRV->CTRL1.bit.HS2_ON = (uint8)1;
    }
    else /* e_hs2Cfg == BDRV_chCfg_hsDcs */
    {
      /* Clamping off current must be set to 0 before enabling diagnosis current source */
      BDRV->HB1IGATECLMPC.bit.HB2_ICLMPOFF = 0;
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.HS2_DCS_EN = (uint8)1;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

  return e_returnCode;
}
#elif (UC_SERIES == 989)
/** \brief Configure the 3 half-bridges of the device TLE989x
 *
 * \param e_ls1Cfg Configuration of the low-side driver 1
 * \param e_hs1Cfg Configuration of the high-side driver 1
 * \param e_ls2Cfg Configuration of the low-side driver 2
 * \param e_hs2Cfg Configuration of the high-side driver 2
 * \param e_ls3Cfg Configuration of the low-side driver 3
 * \param e_hs3Cfg Configuration of the high-side driver 3
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setBridge(tBDRV_chCfg e_ls1Cfg, tBDRV_chCfg e_hs1Cfg, tBDRV_chCfg e_ls2Cfg, tBDRV_chCfg e_hs2Cfg, tBDRV_chCfg e_ls3Cfg, tBDRV_chCfg e_hs3Cfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_ls1Cfg <= BDRV_chCfg_on) && (e_hs1Cfg <= BDRV_chCfg_hsDcs) && (e_ls2Cfg <= BDRV_chCfg_on) && (e_hs2Cfg <= BDRV_chCfg_hsDcs) && (e_ls3Cfg <= BDRV_chCfg_on) && (e_hs3Cfg <= BDRV_chCfg_hsDcs))
  {
    /* Setting Low Side 1 */
    if (e_ls1Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_ls1Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
    }
    else if (e_ls1Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.LS1_ON = (uint8)0;
      BDRV->CTRL1.bit.LS1_PWM = (uint8)1;
    }
    else /* e_ls1Cfg == BDRV_chCfg_on */
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.LS1_PWM = (uint8)0;
      BDRV->CTRL1.bit.LS1_ON = (uint8)1;
    }

    /* Setting High Side 1 */
    if (e_hs1Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_hs1Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
    }
    else if (e_hs1Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.HS1_ON = (uint8)0;
      BDRV->CTRL1.bit.HS1_PWM = (uint8)1;
    }
    else if (e_hs1Cfg == BDRV_chCfg_on)
    {
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.HS1_PWM = (uint8)0;
      BDRV->CTRL1.bit.HS1_ON = (uint8)1;
    }
    else /* e_hs1Cfg == BDRV_chCfg_hsDcs */
    {
      /* Clamping off current must be set to 0 before enabling diagnosis current source */
      BDRV->HB1IGATECLMPC.bit.HB1_ICLMPOFF = 0;
      BDRV->CTRL1.bit.HB1_EN = (uint8)1;
      BDRV->CTRL1.bit.HS1_DCS_EN = (uint8)1;
    }

    /* Setting Low Side 2 */
    if (e_ls2Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_ls2Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
    }
    else if (e_ls2Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.LS2_ON = (uint8)0;
      BDRV->CTRL1.bit.LS2_PWM = (uint8)1;
    }
    else /* e_ls2Cfg == BDRV_chCfg_on */
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.LS2_PWM = (uint8)0;
      BDRV->CTRL1.bit.LS2_ON = (uint8)1;
    }

    /* Setting High Side 2 */
    if (e_hs2Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_hs2Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
    }
    else if (e_hs2Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.HS2_ON = (uint8)0;
      BDRV->CTRL1.bit.HS2_PWM = (uint8)1;
    }
    else if (e_hs2Cfg == BDRV_chCfg_on)
    {
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.HS2_PWM = (uint8)0;
      BDRV->CTRL1.bit.HS2_ON = (uint8)1;
    }
    else /* e_hs2Cfg == BDRV_chCfg_hsDcs */
    {
      /* Clamping off current must be set to 0 before enabling diagnosis current source */
      BDRV->HB2IGATECLMPC.bit.HB2_ICLMPOFF = 0;
      BDRV->CTRL1.bit.HB2_EN = (uint8)1;
      BDRV->CTRL1.bit.HS2_DCS_EN = (uint8)1;
    }

    /* Setting Low Side 3 */
    if (e_ls3Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_ls3Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
    }
    else if (e_ls3Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
      BDRV->CTRL1.bit.LS3_ON = (uint8)0;
      BDRV->CTRL1.bit.LS3_PWM = (uint8)1;
    }
    else /* e_ls3Cfg == BDRV_chCfg_on */
    {
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
      BDRV->CTRL1.bit.LS3_PWM = (uint8)0;
      BDRV->CTRL1.bit.LS3_ON = (uint8)1;
    }

    /* Setting High Side 3 */
    if (e_hs3Cfg == BDRV_chCfg_off)
    {
      BDRV->CTRL1.reg = (uint32)0;
    }
    else if (e_hs3Cfg == BDRV_chCfg_en)
    {
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
    }
    else if (e_hs3Cfg == BDRV_chCfg_pwm)
    {
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
      BDRV->CTRL1.bit.HS3_ON = (uint8)0;
      BDRV->CTRL1.bit.HS3_PWM = (uint8)1;
    }
    else if (e_hs3Cfg == BDRV_chCfg_on)
    {
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
      BDRV->CTRL1.bit.HS3_PWM = (uint8)0;
      BDRV->CTRL1.bit.HS3_ON = (uint8)1;
    }
    else /* e_hs3Cfg == BDRV_chCfg_hsDcs */
    {
      /* Clamping off current must be set to 0 before enabling diagnosis current source */
      BDRV->HB3IGATECLMPC.bit.HB3_ICLMPOFF = 0;
      BDRV->CTRL1.bit.HB3_EN = (uint8)1;
      BDRV->CTRL1.bit.HS3_DCS_EN = (uint8)1;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

  return e_returnCode;
}
#endif

/** \brief Set low-side charge times and currents for constant mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_constChrgCfg Configuration of the constant mode for charge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setLSChrgConstantMode(tBDRV_hb e_hb, tBDRV_constChrgCfg s_constChrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_constChrgCfg.e_constChrgCurrent <= BDRV_currentCfg_350mA) && (s_constChrgCfg.u16_constChrgTime_ns >= (uint16)50) && (s_constChrgCfg.u16_constChrgTime_ns <= (uint16)12800))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->LS1CONSTTC.bit.LS1_TCON = (uint8)((s_constChrgCfg.u16_constChrgTime_ns / 50) - 1);
      BDRV->LS1CONSTIC.bit.LS1_ICON = (uint8)s_constChrgCfg.e_constChrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->LS2CONSTTC.bit.LS2_TCON = (uint8)((s_constChrgCfg.u16_constChrgTime_ns / 50) - 1);
      BDRV->LS2CONSTIC.bit.LS2_ICON = (uint8)s_constChrgCfg.e_constChrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_constChrgCfg.e_constChrgCurrent <= BDRV_currentCfg_350mA) && (s_constChrgCfg.u16_constChrgTime_ns >= (uint16)50) && (s_constChrgCfg.u16_constChrgTime_ns <= (uint16)12800))
  {
    BDRV->LS3CONSTTC.bit.LS3_TCON = (uint8)((s_constChrgCfg.u16_constChrgTime_ns / 50) - 1);
    BDRV->LS3CONSTIC.bit.LS3_ICON = (uint8)s_constChrgCfg.e_constChrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set high-side charge times and currents for constant mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_constChrgCfg Configuration of the constant mode for charge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setHSChrgConstantMode(tBDRV_hb e_hb, tBDRV_constChrgCfg s_constChrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_constChrgCfg.e_constChrgCurrent <= BDRV_currentCfg_350mA) && (s_constChrgCfg.u16_constChrgTime_ns >= (uint16)50) && (s_constChrgCfg.u16_constChrgTime_ns <= (uint16)12800))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->HS1CONSTTC.bit.HS1_TCON = (uint8)((s_constChrgCfg.u16_constChrgTime_ns / 50) - 1);
      BDRV->HS1CONSTIC.bit.HS1_ICON = (uint8)s_constChrgCfg.e_constChrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->HS2CONSTTC.bit.HS2_TCON = (uint8)((s_constChrgCfg.u16_constChrgTime_ns / 50) - 1);
      BDRV->HS2CONSTIC.bit.HS2_ICON = (uint8)s_constChrgCfg.e_constChrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_constChrgCfg.e_constChrgCurrent <= BDRV_currentCfg_350mA) && (s_constChrgCfg.u16_constChrgTime_ns >= (uint16)50) && (s_constChrgCfg.u16_constChrgTime_ns <= (uint16)12800))
  {
    BDRV->HS3CONSTTC.bit.HS3_TCON = (uint8)((s_constChrgCfg.u16_constChrgTime_ns / 50) - 1);
    BDRV->HS3CONSTIC.bit.HS3_ICON = (uint8)s_constChrgCfg.e_constChrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set low-side discharge times and currents for constant mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_constDischrgCfg Configuration of the constant mode for discharge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setLSDischrgConstantMode(tBDRV_hb e_hb, tBDRV_constDischrgCfg s_constDischrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_constDischrgCfg.e_constDischrgCurrent <= BDRV_currentCfg_350mA) && (s_constDischrgCfg.u16_constDischrgTime_ns >= (uint16)50) && (s_constDischrgCfg.u16_constDischrgTime_ns <= (uint16)12800))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->LS1CONSTTC.bit.LS1_TCOFF = (uint8)((s_constDischrgCfg.u16_constDischrgTime_ns / 50) - 1);
      BDRV->LS1CONSTIC.bit.LS1_ICOFF = (uint8)s_constDischrgCfg.e_constDischrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->LS2CONSTTC.bit.LS2_TCOFF = (uint8)((s_constDischrgCfg.u16_constDischrgTime_ns / 50) - 1);
      BDRV->LS2CONSTIC.bit.LS2_ICOFF = (uint8)s_constDischrgCfg.e_constDischrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_constDischrgCfg.e_constDischrgCurrent <= BDRV_currentCfg_350mA) && (s_constDischrgCfg.u16_constDischrgTime_ns >= (uint16)50) && (s_constDischrgCfg.u16_constDischrgTime_ns <= (uint16)12800))
  {
    BDRV->LS3CONSTTC.bit.LS3_TCOFF = (uint8)((s_constDischrgCfg.u16_constDischrgTime_ns / 50) - 1);
    BDRV->LS3CONSTIC.bit.LS3_ICOFF = (uint8)s_constDischrgCfg.e_constDischrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set high-side discharge times and currents for constant mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_constDischrgCfg Configuration of the constant mode for discharge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setHSDischrgConstantMode(tBDRV_hb e_hb, tBDRV_constDischrgCfg s_constDischrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_constDischrgCfg.e_constDischrgCurrent <= BDRV_currentCfg_350mA) && (s_constDischrgCfg.u16_constDischrgTime_ns >= (uint16)50) && (s_constDischrgCfg.u16_constDischrgTime_ns <= (uint16)12800))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->HS1CONSTTC.bit.HS1_TCOFF = (uint8)((s_constDischrgCfg.u16_constDischrgTime_ns / 50) - 1);
      BDRV->HS1CONSTIC.bit.HS1_ICOFF = (uint8)s_constDischrgCfg.e_constDischrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->HS2CONSTTC.bit.HS2_TCOFF = (uint8)((s_constDischrgCfg.u16_constDischrgTime_ns / 50) - 1);
      BDRV->HS2CONSTIC.bit.HS2_ICOFF = (uint8)s_constDischrgCfg.e_constDischrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_constDischrgCfg.e_constDischrgCurrent <= BDRV_currentCfg_350mA) && (s_constDischrgCfg.u16_constDischrgTime_ns >= (uint16)50) && (s_constDischrgCfg.u16_constDischrgTime_ns <= (uint16)12800))
  {
    BDRV->HS3CONSTTC.bit.HS3_TCOFF = (uint8)((s_constDischrgCfg.u16_constDischrgTime_ns / 50) - 1);
    BDRV->HS3CONSTIC.bit.HS3_ICOFF = (uint8)s_constDischrgCfg.e_constDischrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set low-side charge times and currents for sequencer mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_seqChrgCfg Configuration of the sequencer mode for charge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setLSChrgSequencerMode(tBDRV_hb e_hb, tBDRV_seqChrgCfg s_seqChrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_seqChrgCfg.e_seqPhase1ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase2ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase3ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase4ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns <= (uint16)3200))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->LS1SEQONTC.bit.LS1_T1ON = (uint8)((s_seqChrgCfg.u16_seqPhase1ChrgTime_ns / 50) - 1);
      BDRV->LS1SEQONTC.bit.LS1_T2ON = (uint8)((s_seqChrgCfg.u16_seqPhase2ChrgTime_ns / 50) - 1);
      BDRV->LS1SEQONTC.bit.LS1_T3ON = (uint8)((s_seqChrgCfg.u16_seqPhase3ChrgTime_ns / 50) - 1);
      BDRV->LS1SEQONTC.bit.LS1_T4ON = (uint8)((s_seqChrgCfg.u16_seqPhase4ChrgTime_ns / 50) - 1);
      BDRV->LS1SEQONIC.bit.LS1_I1ON = (uint8)s_seqChrgCfg.e_seqPhase1ChrgCurrent;
      BDRV->LS1SEQONIC.bit.LS1_I2ON = (uint8)s_seqChrgCfg.e_seqPhase2ChrgCurrent;
      BDRV->LS1SEQONIC.bit.LS1_I3ON = (uint8)s_seqChrgCfg.e_seqPhase3ChrgCurrent;
      BDRV->LS1SEQONIC.bit.LS1_I4ON = (uint8)s_seqChrgCfg.e_seqPhase4ChrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->LS2SEQONTC.bit.LS2_T1ON = (uint8)((s_seqChrgCfg.u16_seqPhase1ChrgTime_ns / 50) - 1);
      BDRV->LS2SEQONTC.bit.LS2_T2ON = (uint8)((s_seqChrgCfg.u16_seqPhase2ChrgTime_ns / 50) - 1);
      BDRV->LS2SEQONTC.bit.LS2_T3ON = (uint8)((s_seqChrgCfg.u16_seqPhase3ChrgTime_ns / 50) - 1);
      BDRV->LS2SEQONTC.bit.LS2_T4ON = (uint8)((s_seqChrgCfg.u16_seqPhase4ChrgTime_ns / 50) - 1);
      BDRV->LS2SEQONIC.bit.LS2_I1ON = (uint8)s_seqChrgCfg.e_seqPhase1ChrgCurrent;
      BDRV->LS2SEQONIC.bit.LS2_I2ON = (uint8)s_seqChrgCfg.e_seqPhase2ChrgCurrent;
      BDRV->LS2SEQONIC.bit.LS2_I3ON = (uint8)s_seqChrgCfg.e_seqPhase3ChrgCurrent;
      BDRV->LS2SEQONIC.bit.LS2_I4ON = (uint8)s_seqChrgCfg.e_seqPhase4ChrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_seqChrgCfg.e_seqPhase1ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase2ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase3ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase4ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns <= (uint16)3200))
  {
    BDRV->LS3SEQONTC.bit.LS3_T1ON = (uint8)((s_seqChrgCfg.u16_seqPhase1ChrgTime_ns / 50) - 1);
    BDRV->LS3SEQONTC.bit.LS3_T2ON = (uint8)((s_seqChrgCfg.u16_seqPhase2ChrgTime_ns / 50) - 1);
    BDRV->LS3SEQONTC.bit.LS3_T3ON = (uint8)((s_seqChrgCfg.u16_seqPhase3ChrgTime_ns / 50) - 1);
    BDRV->LS3SEQONTC.bit.LS3_T4ON = (uint8)((s_seqChrgCfg.u16_seqPhase4ChrgTime_ns / 50) - 1);
    BDRV->LS3SEQONIC.bit.LS3_I1ON = (uint8)s_seqChrgCfg.e_seqPhase1ChrgCurrent;
    BDRV->LS3SEQONIC.bit.LS3_I2ON = (uint8)s_seqChrgCfg.e_seqPhase2ChrgCurrent;
    BDRV->LS3SEQONIC.bit.LS3_I3ON = (uint8)s_seqChrgCfg.e_seqPhase3ChrgCurrent;
    BDRV->LS3SEQONIC.bit.LS3_I4ON = (uint8)s_seqChrgCfg.e_seqPhase4ChrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set high-side charge times and currents for sequencer mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_seqChrgCfg Configuration of the sequencer mode for charge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setHSChrgSequencerMode(tBDRV_hb e_hb, tBDRV_seqChrgCfg s_seqChrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_seqChrgCfg.e_seqPhase1ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase2ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase3ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase4ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns <= (uint16)3200))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->HS1SEQONTC.bit.HS1_T1ON = (uint8)((s_seqChrgCfg.u16_seqPhase1ChrgTime_ns / 50) - 1);
      BDRV->HS1SEQONTC.bit.HS1_T2ON = (uint8)((s_seqChrgCfg.u16_seqPhase2ChrgTime_ns / 50) - 1);
      BDRV->HS1SEQONTC.bit.HS1_T3ON = (uint8)((s_seqChrgCfg.u16_seqPhase3ChrgTime_ns / 50) - 1);
      BDRV->HS1SEQONTC.bit.HS1_T4ON = (uint8)((s_seqChrgCfg.u16_seqPhase4ChrgTime_ns / 50) - 1);
      BDRV->HS1SEQONIC.bit.HS1_I1ON = (uint8)s_seqChrgCfg.e_seqPhase1ChrgCurrent;
      BDRV->HS1SEQONIC.bit.HS1_I2ON = (uint8)s_seqChrgCfg.e_seqPhase2ChrgCurrent;
      BDRV->HS1SEQONIC.bit.HS1_I3ON = (uint8)s_seqChrgCfg.e_seqPhase3ChrgCurrent;
      BDRV->HS1SEQONIC.bit.HS1_I4ON = (uint8)s_seqChrgCfg.e_seqPhase4ChrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->HS2SEQONTC.bit.HS2_T1ON = (uint8)((s_seqChrgCfg.u16_seqPhase1ChrgTime_ns / 50) - 1);
      BDRV->HS2SEQONTC.bit.HS2_T2ON = (uint8)((s_seqChrgCfg.u16_seqPhase2ChrgTime_ns / 50) - 1);
      BDRV->HS2SEQONTC.bit.HS2_T3ON = (uint8)((s_seqChrgCfg.u16_seqPhase3ChrgTime_ns / 50) - 1);
      BDRV->HS2SEQONTC.bit.HS2_T4ON = (uint8)((s_seqChrgCfg.u16_seqPhase4ChrgTime_ns / 50) - 1);
      BDRV->HS2SEQONIC.bit.HS2_I1ON = (uint8)s_seqChrgCfg.e_seqPhase1ChrgCurrent;
      BDRV->HS2SEQONIC.bit.HS2_I2ON = (uint8)s_seqChrgCfg.e_seqPhase2ChrgCurrent;
      BDRV->HS2SEQONIC.bit.HS2_I3ON = (uint8)s_seqChrgCfg.e_seqPhase3ChrgCurrent;
      BDRV->HS2SEQONIC.bit.HS2_I4ON = (uint8)s_seqChrgCfg.e_seqPhase4ChrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_seqChrgCfg.e_seqPhase1ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase2ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase3ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.e_seqPhase4ChrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase1ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase2ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase3ChrgTime_ns <= (uint16)3200)
      && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns >= (uint16)50) && (s_seqChrgCfg.u16_seqPhase4ChrgTime_ns <= (uint16)3200))
  {
    BDRV->HS3SEQONTC.bit.HS3_T1ON = (uint8)((s_seqChrgCfg.u16_seqPhase1ChrgTime_ns / 50) - 1);
    BDRV->HS3SEQONTC.bit.HS3_T2ON = (uint8)((s_seqChrgCfg.u16_seqPhase2ChrgTime_ns / 50) - 1);
    BDRV->HS3SEQONTC.bit.HS3_T3ON = (uint8)((s_seqChrgCfg.u16_seqPhase3ChrgTime_ns / 50) - 1);
    BDRV->HS3SEQONTC.bit.HS3_T4ON = (uint8)((s_seqChrgCfg.u16_seqPhase4ChrgTime_ns / 50) - 1);
    BDRV->HS3SEQONIC.bit.HS3_I1ON = (uint8)s_seqChrgCfg.e_seqPhase1ChrgCurrent;
    BDRV->HS3SEQONIC.bit.HS3_I2ON = (uint8)s_seqChrgCfg.e_seqPhase2ChrgCurrent;
    BDRV->HS3SEQONIC.bit.HS3_I3ON = (uint8)s_seqChrgCfg.e_seqPhase3ChrgCurrent;
    BDRV->HS3SEQONIC.bit.HS3_I4ON = (uint8)s_seqChrgCfg.e_seqPhase4ChrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set low-side discharge times and currents for sequencer mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_seqDischrgCfg Configuration of the sequencer mode for discharge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setLSDischrgSequencerMode(tBDRV_hb e_hb, tBDRV_seqDischrgCfg s_seqDischrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_seqDischrgCfg.e_seqPhase1DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase2DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase3DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase4DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns <= (uint16)3200))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->LS1SEQOFFTC.bit.LS1_T1OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns / 50) - 1);
      BDRV->LS1SEQOFFTC.bit.LS1_T2OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns / 50) - 1);
      BDRV->LS1SEQOFFTC.bit.LS1_T3OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns / 50) - 1);
      BDRV->SEQOFFT4I4.bit.T4OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns / 50) - 1);
      BDRV->LS1SEQOFFIC.bit.LS1_I1OFF = (uint8)s_seqDischrgCfg.e_seqPhase1DischrgCurrent;
      BDRV->LS1SEQOFFIC.bit.LS1_I2OFF = (uint8)s_seqDischrgCfg.e_seqPhase2DischrgCurrent;
      BDRV->LS1SEQOFFIC.bit.LS1_I3OFF = (uint8)s_seqDischrgCfg.e_seqPhase3DischrgCurrent;
      BDRV->SEQOFFT4I4.bit.I4OFF = (uint8)s_seqDischrgCfg.e_seqPhase4DischrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->LS2SEQOFFTC.bit.LS2_T1OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns / 50) - 1);
      BDRV->LS2SEQOFFTC.bit.LS2_T2OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns / 50) - 1);
      BDRV->LS2SEQOFFTC.bit.LS2_T3OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns / 50) - 1);
      BDRV->SEQOFFT4I4.bit.T4OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns / 50) - 1);
      BDRV->LS2SEQOFFIC.bit.LS2_I1OFF = (uint8)s_seqDischrgCfg.e_seqPhase1DischrgCurrent;
      BDRV->LS2SEQOFFIC.bit.LS2_I2OFF = (uint8)s_seqDischrgCfg.e_seqPhase2DischrgCurrent;
      BDRV->LS2SEQOFFIC.bit.LS2_I3OFF = (uint8)s_seqDischrgCfg.e_seqPhase3DischrgCurrent;
      BDRV->SEQOFFT4I4.bit.I4OFF = (uint8)s_seqDischrgCfg.e_seqPhase4DischrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_seqDischrgCfg.e_seqPhase1DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase2DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase3DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase4DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns <= (uint16)3200))
  {
    BDRV->LS3SEQOFFTC.bit.LS3_T1OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns / 50) - 1);
    BDRV->LS3SEQOFFTC.bit.LS3_T2OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns / 50) - 1);
    BDRV->LS3SEQOFFTC.bit.LS3_T3OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns / 50) - 1);
    BDRV->SEQOFFT4I4.bit.T4OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns / 50) - 1);
    BDRV->LS3SEQOFFIC.bit.LS3_I1OFF = (uint8)s_seqDischrgCfg.e_seqPhase1DischrgCurrent;
    BDRV->LS3SEQOFFIC.bit.LS3_I2OFF = (uint8)s_seqDischrgCfg.e_seqPhase2DischrgCurrent;
    BDRV->LS3SEQOFFIC.bit.LS3_I3OFF = (uint8)s_seqDischrgCfg.e_seqPhase3DischrgCurrent;
    BDRV->SEQOFFT4I4.bit.I4OFF = (uint8)s_seqDischrgCfg.e_seqPhase4DischrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set high-side charge times and currents for sequencer mode
 *
 * \param e_hb Selection of the half-bridge (HB1, HB2 or HB3)
 * \param s_seqDischrgCfg Configuration of the sequencer mode for charge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setHSDischrgSequencerMode(tBDRV_hb e_hb, tBDRV_seqDischrgCfg s_seqDischrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((e_hb >= BDRV_hb_1) && (e_hb <= BDRV_hb_2) && (s_seqDischrgCfg.e_seqPhase1DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase2DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase3DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase4DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns <= (uint16)3200))
  {
    if (e_hb == BDRV_hb_1)
    {
      BDRV->HS1SEQOFFTC.bit.HS1_T1OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns / 50) - 1);
      BDRV->HS1SEQOFFTC.bit.HS1_T2OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns / 50) - 1);
      BDRV->HS1SEQOFFTC.bit.HS1_T3OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns / 50) - 1);
      BDRV->SEQOFFT4I4.bit.T4OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns / 50) - 1);
      BDRV->HS1SEQOFFIC.bit.HS1_I1OFF = (uint8)s_seqDischrgCfg.e_seqPhase1DischrgCurrent;
      BDRV->HS1SEQOFFIC.bit.HS1_I2OFF = (uint8)s_seqDischrgCfg.e_seqPhase2DischrgCurrent;
      BDRV->HS1SEQOFFIC.bit.HS1_I3OFF = (uint8)s_seqDischrgCfg.e_seqPhase3DischrgCurrent;
      BDRV->SEQOFFT4I4.bit.I4OFF = (uint8)s_seqDischrgCfg.e_seqPhase4DischrgCurrent;
    }
    else /* e_hb == BDRV_hb_2 */
    {
      BDRV->HS2SEQOFFTC.bit.HS2_T1OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns / 50) - 1);
      BDRV->HS2SEQOFFTC.bit.HS2_T2OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns / 50) - 1);
      BDRV->HS2SEQOFFTC.bit.HS2_T3OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns / 50) - 1);
      BDRV->SEQOFFT4I4.bit.T4OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns / 50) - 1);
      BDRV->HS2SEQOFFIC.bit.HS2_I1OFF = (uint8)s_seqDischrgCfg.e_seqPhase1DischrgCurrent;
      BDRV->HS2SEQOFFIC.bit.HS2_I2OFF = (uint8)s_seqDischrgCfg.e_seqPhase2DischrgCurrent;
      BDRV->HS2SEQOFFIC.bit.HS2_I3OFF = (uint8)s_seqDischrgCfg.e_seqPhase3DischrgCurrent;
      BDRV->SEQOFFT4I4.bit.I4OFF = (uint8)s_seqDischrgCfg.e_seqPhase4DischrgCurrent;
    }
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#if (UC_SERIES == 989)

  if ((e_hb == BDRV_hb_3) && (s_seqDischrgCfg.e_seqPhase1DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase2DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase3DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.e_seqPhase4DischrgCurrent <= BDRV_currentCfg_350mA)
      && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns <= (uint16)3200)
      && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns >= (uint16)50) && (s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns <= (uint16)3200))
  {
    BDRV->HS3SEQOFFTC.bit.HS3_T1OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase1DischrgTime_ns / 50) - 1);
    BDRV->HS3SEQOFFTC.bit.HS3_T2OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase2DischrgTime_ns / 50) - 1);
    BDRV->HS3SEQOFFTC.bit.HS3_T3OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase3DischrgTime_ns / 50) - 1);
    BDRV->SEQOFFT4I4.bit.T4OFF = (uint8)((s_seqDischrgCfg.u16_seqPhase4DischrgTime_ns / 50) - 1);
    BDRV->HS3SEQOFFIC.bit.HS3_I1OFF = (uint8)s_seqDischrgCfg.e_seqPhase1DischrgCurrent;
    BDRV->HS3SEQOFFIC.bit.HS3_I2OFF = (uint8)s_seqDischrgCfg.e_seqPhase2DischrgCurrent;
    BDRV->HS3SEQOFFIC.bit.HS3_I3OFF = (uint8)s_seqDischrgCfg.e_seqPhase3DischrgCurrent;
    BDRV->SEQOFFT4I4.bit.I4OFF = (uint8)s_seqDischrgCfg.e_seqPhase4DischrgCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

#endif
  return e_returnCode;
}

/** \brief Set adaptive sequencer for charge
 *
 * \param s_aseqChrgCfg Configuration of the adaptive sequencer mode for charge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setChrgAdaptiveSequencerMode(tBDRV_aseqChrgCfg s_aseqChrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((s_aseqChrgCfg.e_aseqChrgMinCurrent <= BDRV_currentCfg_350mA)
      && (s_aseqChrgCfg.e_aseqChrgMaxCurrent <= BDRV_currentCfg_350mA)
      && (s_aseqChrgCfg.u16_aseqChrgMinTime_ns >= (uint16)50) && (s_aseqChrgCfg.u16_aseqChrgMinTime_ns <= (uint16)12800)
      && (s_aseqChrgCfg.u16_aseqChrgMaxTime_ns >= (uint16)50) && (s_aseqChrgCfg.u16_aseqChrgMaxTime_ns <= (uint16)12800))
  {
    BDRV->ASEQONTMIN.bit.T12ONMIN = (uint8)((s_aseqChrgCfg.u16_aseqChrgMinTime_ns / 50) - 1);
    BDRV->ASEQONTMAX.bit.T12ONMAX = (uint8)((s_aseqChrgCfg.u16_aseqChrgMaxTime_ns / 50) - 1);
    BDRV->ASEQONIMIN.bit.I1ONMIN = (uint8)s_aseqChrgCfg.e_aseqChrgMinCurrent;
    BDRV->ASEQONIMAX.bit.I1ONMAX = (uint8)s_aseqChrgCfg.e_aseqChrgMaxCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

  return e_returnCode;
}

/** \brief Set adaptive sequencer for discharge
 *
 * \param s_aseqDischrgCfg Configuration of the adaptive sequencer mode for discharge
 * \return sint8 0: success, <0: error codes
 */
sint8 BDRV_setDischrgAdaptiveSequencerMode(tBDRV_aseqDischrgCfg s_aseqDischrgCfg)
{
  sint8 e_returnCode;
  e_returnCode = ERR_LOG_SUCCESS;

  if ((s_aseqDischrgCfg.e_aseqDischrgMinCurrent <= BDRV_currentCfg_350mA)
      && (s_aseqDischrgCfg.e_aseqDischrgMaxCurrent <= BDRV_currentCfg_350mA)
      && (s_aseqDischrgCfg.u16_aseqDischrgMinTime_ns >= (uint16)50) && (s_aseqDischrgCfg.u16_aseqDischrgMinTime_ns <= (uint16)12800)
      && (s_aseqDischrgCfg.u16_aseqDischrgMaxTime_ns >= (uint16)50) && (s_aseqDischrgCfg.u16_aseqDischrgMaxTime_ns <= (uint16)12800))
  {
    BDRV->ASEQOFFTMIN.bit.T1OFFMIN = (uint8)((s_aseqDischrgCfg.u16_aseqDischrgMinTime_ns / 50) - 1);
    BDRV->ASEQOFFTMAX.bit.T1OFFMAX = (uint8)((s_aseqDischrgCfg.u16_aseqDischrgMaxTime_ns / 50) - 1);
    BDRV->ASEQOFFIMIN.bit.I1OFFMIN = (uint8)s_aseqDischrgCfg.e_aseqDischrgMinCurrent;
    BDRV->ASEQOFFIMAX.bit.I1OFFMAX = (uint8)s_aseqDischrgCfg.e_aseqDischrgMaxCurrent;
  }
  else /* arguments out of range */
  {
    e_returnCode = ERR_LOG_CODE_PARAM_OUT_OF_RANGE;
  }

  return e_returnCode;
}

/** \brief Off-State Diagnosis - Short to Ground or Short to Vbattery Detection
 *
 * \param none
 * \return tBDRV_offState Off-state diagnosis status for every phase
 */
tBDRV_offState BDRV_checkShortDiagnosis(void)
{
  int e_returnCode;
  tBDRV_offState s_offStateDiag;
  uint32 u32_intEnNode0 = 0;
  uint32 u32_intEnNode1 = 0;

  e_returnCode = ERR_LOG_SUCCESS;
  s_offStateDiag.b_globFailSts = false;
  s_offStateDiag.e_offStateDiagPhase1 = BDRV_offStateDiag_ok;
  s_offStateDiag.e_offStateDiagPhase2 = BDRV_offStateDiag_ok;
#if (UC_SERIES == 989)
  s_offStateDiag.e_offStateDiagPhase3 = BDRV_offStateDiag_ok;
#endif
  /* Save BDRV interrupt enable */
  u32_intEnNode0 = CPU->NVIC_ISER.bit.IRQEN0;
  u32_intEnNode1 = CPU->NVIC_ISER.bit.IRQEN1;
  /* Disable BDRV interrupt */
  CPU->NVIC_ICER.bit.IRQCLREN0 = (uint8)1;
  CPU->NVIC_ICER.bit.IRQCLREN1 = (uint8)1;
  /* Set Drain-Source comparator threshold to value < 1V */
  BDRV->CTRL2.bit.DSMONVTH = 3;
  /* Enable all gate drivers */
#if (UC_SERIES == 988)
  e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en);
#elif (UC_SERIES == 989)
  e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en);
#endif

  if (e_returnCode == ERR_LOG_SUCCESS)
  {
    /* Activate diagnosis current sources */
#if (UC_SERIES == 988)
    e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_hsDcs);
#elif (UC_SERIES == 989)
    e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_hsDcs);
#endif

    if (e_returnCode == ERR_LOG_SUCCESS)
    {
      /* Delay for the diagnosis current source to settle - it depends on the attached motor */
      //Delay_us(800u);
      /* Clear status flags */
      BDRV_clrFaultSts();

      /* Check status flags */
      if (BDRV_getLS1DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase1 = BDRV_offStateDiag_short2gnd;
      }

      if (BDRV_getHS1DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase1 = BDRV_offStateDiag_short2bat;
      }

      if (BDRV_getLS2DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase2 = BDRV_offStateDiag_short2gnd;
      }

      if (BDRV_getHS2DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase2 = BDRV_offStateDiag_short2bat;
      }

#if (UC_SERIES == 989)

      if (BDRV_getLS3DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase3 = BDRV_offStateDiag_short2gnd;
      }

      if (BDRV_getHS3DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase3 = BDRV_offStateDiag_short2bat;
      }

#endif
      /* Switch-off all drivers */
#if (UC_SERIES == 988)
      e_returnCode = BDRV_setBridge(BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off);
#elif (UC_SERIES == 989)
      e_returnCode = BDRV_setBridge(BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off);
#endif

      if (e_returnCode == ERR_LOG_SUCCESS)
      {
        /* Restore BDRV interrupt enable */
        if (u32_intEnNode0 == (uint8)1)
        {
          CPU->NVIC_ISER.bit.IRQEN0 = (uint8)1;
        }

        if (u32_intEnNode1 == (uint8)1)
        {
          CPU->NVIC_ISER.bit.IRQEN1 = (uint8)1;
        }
      }
    }
  }

  return s_offStateDiag;
}

/** \brief Off-State Diagnosis - Open-Load Detection
 *
 * \param none
 * \return tBDRV_offState Off-state diagnosis status for every phase
 */
tBDRV_offState BDRV_checkOpenload(void)
{
  int e_returnCode;
  tBDRV_offState s_offStateDiag;
  uint32 u32_intEnNode0 = 0;
  uint32 u32_intEnNode1 = 0;

  e_returnCode = ERR_LOG_SUCCESS;
  s_offStateDiag.b_globFailSts = false;
  s_offStateDiag.e_offStateDiagPhase1 = BDRV_offStateDiag_ok;
  s_offStateDiag.e_offStateDiagPhase2 = BDRV_offStateDiag_ok;
#if (UC_SERIES == 989)
  s_offStateDiag.e_offStateDiagPhase3 = BDRV_offStateDiag_ok;
#endif
  /* Save BDRV interrupt enable */
  u32_intEnNode0 = CPU->NVIC_ISER.bit.IRQEN0;
  u32_intEnNode1 = CPU->NVIC_ISER.bit.IRQEN1;
  /* Disable BDRV interrupt */
  CPU->NVIC_ICER.bit.IRQCLREN0 = (uint8)1;
  CPU->NVIC_ICER.bit.IRQCLREN1 = (uint8)1;
  /* Set Drain-Source comparator threshold to smallest value */
  BDRV->CTRL2.bit.DSMONVTH = 1;
  /* CHECK PHASE 1 */
#if (UC_SERIES == 988)
  /* TLE988x: Enable HS2 diagnosis current source */
  e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_hsDcs);
#elif (UC_SERIES == 989)
  /* TLE989x: Enable HS2 (&& HS3) diagnosis current source */
  e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_hsDcs);
#endif

  if (e_returnCode == ERR_LOG_SUCCESS)
  {
    /* Delay for the diagnosis current source to settle - it depends on the attached motor */
    //Delay_us(800u);
    /* Clear status flags */
    BDRV_clrFaultSts();

    /* Check status flags */
    if (BDRV_getHS1DrainSrcMonitoringSts() == (uint8)1)
    {
      s_offStateDiag.b_globFailSts = true;
      s_offStateDiag.e_offStateDiagPhase1 = BDRV_offStateDiag_openload;
    }

    /* CHECK PHASE 2 */
#if (UC_SERIES == 988)
    /* TLE988x: Enable HS1 diagnosis current source */
    e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_en);
#elif (UC_SERIES == 989)
    /* TLE989x: Enable HS1 (&& HS3) diagnosis current source */
    e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_en, BDRV_chCfg_hsDcs);
#endif

    if (e_returnCode == ERR_LOG_SUCCESS)
    {
      /* Delay for the diagnosis current source to settle - it depends on the attached motor */
      //Delay_us(800u);
      /* Clear status flags */
      BDRV_clrFaultSts();

      /* Check status flags */
      if (BDRV_getHS2DrainSrcMonitoringSts() == (uint8)1)
      {
        s_offStateDiag.b_globFailSts = true;
        s_offStateDiag.e_offStateDiagPhase2 = BDRV_offStateDiag_openload;
      }

#if (UC_SERIES == 989)
      /* CHECK PHASE 3 */
      /* TLE989x: Enable HS2 (&& HS3) diagnosis current source */
      e_returnCode = BDRV_setBridge(BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_hsDcs, BDRV_chCfg_en, BDRV_chCfg_en);

      if (e_returnCode == ERR_LOG_SUCCESS)
      {
        /* Delay for the diagnosis current source to settle - it depends on the attached motor */
        //Delay_us(800u);
        /* Clear status flags */
        BDRV_clrFaultSts();

        /* Check status flags */
        if (BDRV_getHS3DrainSrcMonitoringSts() == (uint8)1)
        {
          s_offStateDiag.b_globFailSts = true;
          s_offStateDiag.e_offStateDiagPhase3 = BDRV_offStateDiag_openload;
        }

#endif
        /* Switch-off all drivers */
#if (UC_SERIES == 988)
        e_returnCode = BDRV_setBridge(BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off);
#elif (UC_SERIES == 989)
        e_returnCode = BDRV_setBridge(BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off, BDRV_chCfg_off);
#endif

        if (e_returnCode == ERR_LOG_SUCCESS)
        {
          if (u32_intEnNode0 == (uint8)1)
          {
            CPU->NVIC_ISER.bit.IRQEN0 = (uint8)1;
          }

          if (u32_intEnNode1 == (uint8)1)
          {
            CPU->NVIC_ISER.bit.IRQEN1 = (uint8)1;
          }
        }
      }
    }
  }

  return s_offStateDiag;
}

/** \brief Read all status flags related to bridge driver and charge pump and return true if at least one is active, otherwise false
 *
 * \param none
 * \return bool True if one status flag is active otherwise false
 */
bool BDRV_getFaultSts(void)
{
  bool status = false;

  if (BDRV->STS.reg > (uint32)0)
  {
    status = true;
  }

  return status;
}

/** \brief Read the fault information related to bridge driver and charge pump and provides them encoded in the return value
 *
 * \param none
 * \return uint8 Fault information related to bridge driver and charge pump
 * \return Bit0: Over Current LS1
 * \return Bit1: Over Current HS1
 * \return Bit2: Over Current LS2
 * \return Bit3: Over Current HS2
 * \return Bit4: Over Current LS3
 * \return Bit5: Over Current HS3
 * \return Bit6: Under Voltage Charge Pump (incl. VSD and VCP)
 * \return Bit7: Over Voltage Charge Pump (incl. VSD and VCP)
 */
uint8 BDRV_getFaults(void)
{
  return (uint8)((uint8)((BDRV->STS.bit.VCP_UPTH_STS || BDRV->STS.bit.VSD_UPTH_STS || BDRV->STS.bit.VSD_OV_STS) << 7) || (uint8)((BDRV->STS.bit.VCP_LOTH1_STS || BDRV->STS.bit.VCP_LOTH2_STS || BDRV->STS.bit.VSD_LOTH_STS) << 6) || (uint8)(BDRV->STS.bit.HS3_OC_STS << 5) || (uint8)(BDRV->STS.bit.LS3_OC_STS << 4) || (uint8)(BDRV->STS.bit.HS2_OC_STS << 3) || (uint8)(BDRV->STS.bit.LS2_OC_STS << 2) || (uint8)(BDRV->STS.bit.HS1_OC_STS << 1) || BDRV->STS.bit.LS1_OC_STS);
}

/** \brief Clear all status bits related to bridge driver and charge pump
 *
 * \param none
 * \return none
 */
void BDRV_clrFaultSts(void)
{
  BDRV->STSCLR.reg = (uint32)0x80333333;
}

/*******************************************************************************
**                       Deprecated Function Definitions                      **
*******************************************************************************/

/*=================================== BDRV ===================================*/

void BDRV_setExternalLS1MosfetOvercurrentIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setExternalHS1MosfetOvercurrentIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setExternalLS2MosfetOvercurrentIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setExternalHS2MosfetOvercurrentIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setExternalLS3MosfetOvercurrentIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setExternalHS3MosfetOvercurrentIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setLS1DrainSrcMonitoringIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHS1DrainSrcMonitoringIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setLS2DrainSrcMonitoringIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHS2DrainSrcMonitoringIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setLS3DrainSrcMonitoringIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHS3DrainSrcMonitoringIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHB1AdaptSeqIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHB2AdaptSeqIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHB3AdaptSeqIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHB1ActDrvDetectIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHB2ActDrvDetectIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setHB3ActDrvDetectIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setDrvSeqErrIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

/*================================== BEMFC ===================================*/

void BDRV_setPh1ZCFallIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setPh2ZCFallIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setPh3ZCFallIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setPh1ZCRiseIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setPh2ZCRiseIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}

void BDRV_setPh3ZCRiseIntNodePtr(void)
{
  /* Do not change this at runtime, use the ConfigWizard to configure this feature! */
}


