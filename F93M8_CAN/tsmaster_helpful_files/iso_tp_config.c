/*
Copyright (c) 2022:Shanghai TOSUN Technology Ltd.

The software mentioned in this copyright statement includes the automatic code generator function module of TSMaster software and the embedded code it generates. Among them, the copyright of the automatic code generation function module of TSMaster software is owned by Shanghai TOSUN Technology Ltd..It is protected by the Copyright Law of the People's Republic of China, the Regulations on the Protection of Computer Software, the Intellectual Property Protection Law, the Patent Law of the People's Republic of China and relevant international copyright treaties, laws, regulations, and other intellectual property laws and treaties. 

The embedded code generated by the automatic code generation function of the TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN Technology Ltd. or the original copyright owner of the embedded code, and is only for personal learning and use. Shanghai TOSUN Technology Ltd. does not provide any kind of warranty, whether express or implied. All risks are borne by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint responsibility.

The semiconductor manufacturer's LOGO and product model displayed in the TSMaster are only for the convenience of user selection and useage,its copyright and ownership remain with the respective copyright owners,Shanghai TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for this, and does not assume joint and several liability for any possible infringement.

Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the software mentioned in this copyright statement without notifying users, and reserves the right to modify this license agreement.
*/
#include "can_iso_tp_private.h"

#define MAX_BUFF_LEN 4096
struct can_iso_tp_link_t link;
uint8_t rx_buff[MAX_BUFF_LEN];
uint8_t payload[MAX_BUFF_LEN];

static void print_debug_info(const char* msg)
{
	//e.g. printf this infor to uart port
}
static int L_Data_request(can_iso_tp_link_t_p link_src, const struct CAN_msg* msg)
{
	//todo：send frame to low layer
	return 0;
}
static void N_USData_indication(can_iso_tp_link_t_p link, const uint8_t payload[], uint32_t size, CAN_ISO_TP_RESAULT error)
{
	//todo: handle rx event
}
static void N_USData_confirm(can_iso_tp_link_t_p link, const uint8_t payload[], uint32_t size, CAN_ISO_TP_RESAULT error)
{
	//todo: handle tx done
}
void init_for_can_iso_tp(void)
{
	memset(&link, 0, sizeof(struct can_iso_tp_init_t));
	init[i].rx_id.id = 0x0;
	init[i].rx_id.isExt = 0;
	init[i].rx_id.isCANFD = 0;
	init[i].tx_id.id = 0x0;
	init[i].tx_id.isExt = 0;
	init[i].tx_id.isCANFD = 0;
	init[i].funtion_id.id = 0x0;
	init[i].funtion_id.isExt = 0;
	init[i].tx_id.isCANFD = 0;
	init[i].N_Ar = 1000;
	init[i].N_As = 1000;
	init[i].N_Bs = 1000;
	init[i].N_Cr = 1000;
	init[i].N_WFTmax = 3;
	init[i].L_Data_request = L_Data_request;
	init[i].N_USData_indication = N_USData_indication;
	init[i].N_USData_confirm = N_USData_confirm;
	init[i].rx_buff = rx_buff;
	init[i].rx_buff_len = MAX_BUFF_LEN;
	init[i].TX_DLC = 8;
	init[i].frame_pad = 0x77;
	init[i].FC_BS = 0;
	init[i].STmin = 0;
	init[i].print_debug = print_debug_info;
}
