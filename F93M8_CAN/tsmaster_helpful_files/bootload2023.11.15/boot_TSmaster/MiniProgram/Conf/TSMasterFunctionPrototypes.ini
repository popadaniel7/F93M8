[]
=void log(const char* format, ...);
=void printf(char* format, ...);
=void log_ok(const char* format, ...);
=void log_hint(const char* format, ...);
=void log_nok(const char* format, ...);
=void log_warning(const char* format, ...);
=void test_log(const char* format, ...);
=void test_log_ok(const char* format, ...);
=void test_log_nok(const char* format, ...);
=void test_logCAN(const char* ADesc, PCAN ACAN, const TLogLevel ALevel);

[var]
=Vtype get(void);
=void set(const Vtype AValue);

[timer]
=void start(void);
=void stop(void);
=void set_interval(const s32 AInterval);
=s32 get_interval(void);

[app]
=s32 set_current_application(const char* AAppName);
=s32 del_application(const char* AAppName);
=s32 add_application(const char* AAppName);
=s32 get_application_list(char** AAppNameList);
=s32 set_can_channel_count(const s32 ACount);
=s32 set_lin_channel_count(const s32 ACount);
=s32 get_can_channel_count(const ps32 ACount);
=s32 get_lin_channel_count(const ps32 ACount);
=s32 set_mapping(const PLIBTSMapping AMapping);
=s32 get_mapping(const PLIBTSMapping AMapping);
=s32 del_mapping(const PLIBTSMapping AMapping);
=s32 connect(void);
=s32 disconnect(void);
=s32 log(const char* AStr, const TLogLevel ALevel);
=s32 set_turbo_mode(const char* AAppName, const bool AEnable);
=s32 get_turbo_mode(const char* AAppName, const bool* AEnable);
=s32 get_error_description(const s32 ACode, char** ADesc);
=s32 configure_can_baudrate(const s32 AIdxChn, const float ABaudrateKbps, const bool AListenOnly, const bool AInstallTermResistor120Ohm);
=s32 configure_canfd_baudrate(const s32 AIdxChn, const float ABaudrateArbKbps, const float ABaudrateDataKbps, const TCANFDControllerType AControllerType, const TCANFDControllerMode AControllerMode, const bool AInstallTermResistor120Ohm);
=s32 terminate_application(void);
=void wait(const s32 ATimeMs, const char* AMsg);
=s32 check(const s32 AErrorCode);
=s32 start_log(void);
=s32 end_log(void);
=s32 check_terminate(void);
=s32 get_timestamp(s64* ATimestamp);
=s32 show_confirm_dialog(const char* ATitle, const char* APrompt, const char* AImage, const s32 ATimeoutMs, const bool ADefaultOK);
=s32 pause(void);
=s32 set_check_failed_terminate(const bool AToTerminate);
=s32 get_system_var_count(s32* AInternalCount, s32* AUserCount);
=s32 get_system_var_def_by_index(const bool AIsUser, const s32 AIndex, const PLIBSystemVarDef AVarDef);
=s32 get_system_var_def_by_name(const bool AIsUser, const char* ACompleteName, const PLIBSystemVarDef AVarDef);
=s32 get_system_var_double(const char* ACompleteName, double* AValue);
=s32 get_system_var_int32(const char* ACompleteName, s32* AValue);
=s32 get_system_var_uint32(const char* ACompleteName, u32* AValue);
=s32 get_system_var_int64(const char* ACompleteName, s64* AValue);
=s32 get_system_var_uint64(const char* ACompleteName, u64* AValue);
=s32 get_system_var_uint8_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, u8* AValue);
=s32 get_system_var_int32_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, s32* AValue);
=s32 get_system_var_int64_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, s64* AValue);
=s32 get_system_var_double_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, double* AValue);
=s32 get_system_var_string(const char* ACompleteName, const s32 ACapacity, char* AString);
=s32 set_system_var_double(const char* ACompleteName, double AValue);
=s32 set_system_var_int32(const char* ACompleteName, s32 AValue);
=s32 set_system_var_uint32(const char* ACompleteName, u32 AValue);
=s32 set_system_var_int64(const char* ACompleteName, s64 AValue);
=s32 set_system_var_uint64(const char* ACompleteName, u64 AValue);
=s32 set_system_var_uint8_array(const char* ACompleteName, const s32 ACapacity, u8* AValue);
=s32 set_system_var_int32_array(const char* ACompleteName, const s32 ACapacity, s32* AValue);
=s32 set_system_var_int64_array(const char* ACompleteName, const s32 ACapacity, s64* AValue);
=s32 set_system_var_double_array(const char* ACompleteName, const s32 ACapacity, double* AValue);
=s32 set_system_var_string(const char* ACompleteName, char* AString);
=s32 make_toast(const char* AString, const TLogLevel ALevel);
=s32 execute_python_string(const char* AString, const char* AArguments, const bool AIsSync, const bool AIsX64, char** AResultLog);
=s32 execute_python_script(const char* AFilePath, const char* AArguments, const bool AIsSync, const bool AIsX64, char** AResultLog);
=s32 execute_app(const char* AAppPath,  const char* AWorkingDir, const char* AParameter, const s32 AWaitTimeMS);
=s32 terminate_app_by_name(const char* AImageName);
=s32 excel_load(const char* AFileName, const void** AObj);
=s32 excel_get_sheet_count(const void* AObj, const s32* ACount);
=s32 excel_set_sheet_count(const void* AObj, const s32 ACount);
=s32 excel_get_sheet_name(const void* AObj, const s32 AIdxSheet, const char** AName);
=s32 excel_set_sheet_name(const void* AObj, const s32 AIdxSheet, const char* AName);
=s32 excel_get_cell_count(const void* AObj, const s32 AIdxSheet, const s32* ARowCount, const s32* AColCount);
=s32 excel_get_cell_value(const void* AObj, const s32 AIdxSheet, const s32 AIdxRow, const s32* AIdxCol, const char** AValue);
=s32 excel_set_cell_count(const void* AObj, const s32 AIdxSheet, const s32 ARowCount, const s32 AColCount);
=s32 excel_set_cell_value(const void* AObj, const s32 AIdxSheet, const s32 AIdxRow, const s32 AIdxCol, const char* AValue);
=s32 excel_unload(const void* AObj);
=s32 excel_unload_all(void);
=s32 log_system_var(const char* ACompleteName);
=s32 call_mini_program_api(const char* ALibName, const char* AFuncName, const char* AInParameters, char** AOutParameters);
=s32 split_string(const char* ASplitter, const char* AStr, const char** AArray, const s32 ASingleStrSize, const s32 AArraySize, s32* AActualCount);
=s32 wait_system_var_existance(const char* ACompleteName, const s32 ATimeOutMs);
=s32 wait_system_var_disappear(const char* ACompleteName, const s32 ATimeOutMs);
=s32 set_analysis_time_range(const s64 ATimeStartUs, const s64 ATimeEndUs);
=s32 get_configuration_file_name(char** AFileName);
=s32 get_configuration_file_path(char** AFilePath);
=s32 set_default_output_dir(const char* APath);
=s32 save_screenshot(const char* AFormCaption, const char* AFilePath);
=s32 enable_all_graphics(const bool AEnable, const char* AExceptCaption);
=s32 get_tsmaster_version(ps32 AYear, ps32 AMonth, ps32 ADay, ps32 ABuildNumber);
=s32 ui_show_page_by_index(const s32 AIndex);
=s32 ui_show_page_by_name(const char* AName);
=s32 write_realtime_comment(const char* AName);
=s32 set_thread_priority(const s32 APriority);
=s32 get_system_var_generic(const char* ACompleteName, const s32 ACapacity, char* AValue);
=s32 set_system_var_generic(const char* ACompleteName, const char* AValue);
=s32 write_text_file_start(const char* AFileName, s32* AHandle);
=s32 write_text_file_line(const s32 AHandle, const char* ALine);
=s32 write_text_file_line_double_array(const s32 AHandle, const double* AArray, const s32 ACount);
=s32 write_text_file_line_string_array(const s32 AHandle, const char** AArray, const s32 ACount);
=s32 write_text_file_end(const s32 AHandle);
=s32 force_directory(const char* ADir);
=s32 directory_exists(const char* ADir);
=s32 open_directory_and_select_file(const char* AFileName);
=s32 mini_delay_cpu(void);
=s32 wait_system_var(const char* ACompleteName, const char* AValue, const s32 ATimeoutMs);
=s32 write_mat_file_start(const char* AFileName, s32* AHandle);
=s32 write_mat_file_variable_double(const s32 AHandle, const char* AVarName, const double AValue);
=s32 write_mat_file_variable_string(const s32 AHandle, const char* AVarName, const char* AValue);
=s32 write_mat_file_variable_double_array(const s32 AHandle, const char* AVarName, const double* AArray, const s32 ACount);
=s32 write_mat_file_end(const s32 AHandle);
=s32 read_mat_file_start(const char* AFileName, s32* AHandle);
=s32 read_mat_file_variable_count(const s32 AHandle, const char* AVarName, ps32 ACount);
=s32 read_mat_file_variable_string(const s32 AHandle, const char* AVarName, char** AValue, const s32 ACapacity);
=s32 read_mat_file_variable_double(const s32 AHandle, const char* AVarName, const double* AValue, const s32 AStartIdx, const s32 ACount);
=s32 read_mat_file_end(const s32 AHandle);
=s32 prompt_user_input_value(const char* APrompt, double* AValue);
=s32 prompt_user_input_string(const char* APrompt, char* AValue, const s32 ACapacity);
=s32 ini_create(const char* AFileName, s32* AHandle);
=s32 ini_write_int32(const s32 AHandle, const char* ASection, const char* AKey, const s32 AValue);
=s32 ini_write_int64(const s32 AHandle, const char* ASection, const char* AKey, const s64 AValue);
=s32 ini_write_bool(const s32 AHandle, const char* ASection, const char* AKey, const bool AValue);
=s32 ini_write_float(const s32 AHandle, const char* ASection, const char* AKey, const double AValue);
=s32 ini_write_string(const s32 AHandle, const char* ASection, const char* AKey, const char* AValue);
=s32 ini_read_int32(const s32 AHandle, const char* ASection, const char* AKey, const s32* AValue, const s32 ADefault);
=s32 ini_read_int64(const s32 AHandle, const char* ASection, const char* AKey, const s64* AValue, const s64 ADefault);
=s32 ini_read_bool(const s32 AHandle, const char* ASection, const char* AKey, const bool* AValue, const bool ADefault);
=s32 ini_read_float(const s32 AHandle, const char* ASection, const char* AKey, const double* AValue, const double ADefault);
=s32 ini_read_string(const s32 AHandle, const char* ASection, const char* AKey, const char* AValue, s32* ACapacity, const char* ADefault);
=s32 ini_section_exists(const s32 AHandle, const char* ASection);
=s32 ini_key_exists(const s32 AHandle, const char* ASection, const char* AKey);
=s32 ini_delete_key(const s32 AHandle, const char* ASection, const char* AKey);
=s32 ini_delete_section(const s32 AHandle, const char* ASection);
=s32 ini_close(const s32 AHandle);
=s32 make_toast_until(const char* AString, const TLogLevel ALevel, const bool* ACloseCriteria, const bool AUserCanBreak);
=s32 make_toast_with_callback(const char* AString, const TLogLevel ALevel, const TCheckResultCallback ACallback, const bool AUserCanBreak);
=s32 get_doc_path(char** AFilePath); 
=s32 get_hardware_id_string(char** AIDString);
=s32 get_hardware_id_array(pu8 AArray8B);
=s32 create_system_var(const char* ACompleteName, const TLIBSystemVarType AType, const char* ADefaultValue, const char* AComment);
=s32 delete_system_var(const char* ACompleteName);
=s32 run_form(const char* AFormCaption);
=s32 stop_form(const char* AFormCaption);
=s32 clear_measurement_form(const char* AFormCaption);
=s32 read_text_file_start(const char* AFileName, s32* AHandle);
=s32 read_text_file_line(const s32 AHandle, const s32 ACapacity, ps32 AReadCharCount, char* ALine);
=s32 read_text_file_end(const s32 AHandle);
=s32 play_sound(const bool AIsSync, const char* AWaveFileName);
=s32 set_system_var_unit(const char* ACompleteName, const char* AUnit);
=s32 set_system_var_value_table(const char* ACompleteName, const char* ATable);
=s32 load_plugin(const char* APluginName);
=s32 unload_plugin(const char* APluginName);
=s32 set_system_var_double_async(const char* ACompleteName, double AValue);
=s32 set_system_var_int32_async(const char* ACompleteName, s32 AValue);
=s32 set_system_var_uint32_async(const char* ACompleteName, u32 AValue);
=s32 set_system_var_int64_async(const char* ACompleteName, s64 AValue);
=s32 set_system_var_uint64_async(const char* ACompleteName, u64 AValue);
=s32 set_system_var_uint8_array_async(const char* ACompleteName, const s32 ACapacity, u8* AValue);
=s32 set_system_var_int32_array_async(const char* ACompleteName, const s32 ACapacity, s32* AValue);
=s32 set_system_var_int64_array_async(const char* ACompleteName, const s32 ACapacity, s64* AValue);
=s32 set_system_var_double_array_async(const char* ACompleteName, const s32 ACapacity, double* AValue);
=s32 set_system_var_string_async(const char* ACompleteName, char* AString);
=s32 set_system_var_generic_async(const char* ACompleteName, const s32 ACapacity, char* AValue);
=s32 am_get_running_state(const char* AModuleName, PAMRunningState AState, char** ASubModuleName, char** ACurrentParameterGroupName);
=s32 am_run(const char* AModuleName, const char* ASubModuleName, const char* AParameterGroupName, const bool AIsSync);
=s32 am_stop(const char* AModuleName, const bool AIsSync);
=s32 am_select_sub_module(const bool AIsSelect, const char* AModuleName, const char* ASubModuleName, const char* AParameterGroupName);
=s32 panel_set_enable(const char* APanelName, const char* AControlName, const bool AEnable);
=s32 panel_set_position_x(const char* APanelName, const char* AControlName, const float AX);
=s32 panel_set_position_y(const char* APanelName, const char* AControlName, const float AY);
=s32 panel_set_position_xy(const char* APanelName, const char* AControlName, const float AX, const float AY);
=s32 panel_set_opacity(const char* APanelName, const char* AControlName, const float AOpacity);
=s32 panel_set_width(const char* APanelName, const char* AControlName, const float AWidth);
=s32 panel_set_height(const char* APanelName, const char* AControlName, const float AHeight);
=s32 panel_set_width_height(const char* APanelName, const char* AControlName, const float AWidth, const float AHeight);
=s32 panel_set_rotation_angle(const char* APanelName, const char* AControlName, const float AAngleDegree);
=s32 panel_set_rotation_center(const char* APanelName, const char* AControlName, const float ARatioX, const float ARatioY);
=s32 panel_set_scale_x(const char* APanelName, const char* AControlName, const float AScaleX);
=s32 panel_set_scale_y(const char* APanelName, const char* AControlName, const float AScaleY);
=s32 panel_get_enable(const char* APanelName, const char* AControlName, bool* AEnable);
=s32 panel_get_position_xy(const char* APanelName, const char* AControlName, float* AX, float* AY);
=s32 panel_get_opacity(const char* APanelName, const char* AControlName, float* AOpacity);
=s32 panel_get_width_height(const char* APanelName, const char* AControlName, float* AWidth, float* AHeight);
=s32 panel_get_rotation_angle(const char* APanelName, const char* AControlName, float* AAngleDegree);
=s32 panel_get_rotation_center(const char* APanelName, const char* AControlName, float* ARatioX, float* ARatioY);
=s32 panel_get_scale_xy(const char* APanelName, const char* AControlName, float* AScaleX, float* AScaleY);
=s32 stim_set_signal_status(const char* ASTIMName, const char* AUserLabel, TSTIMSignalStatus AStatus);
=s32 stim_get_signal_status(const char* ASTIMName, const char* AUserLabel, PSTIMSignalStatus AStatus);
=s32 panel_set_bkgd_color(const char* APanelName, const char* AControlName, const u32 AAlphaColor);
=s32 panel_get_bkgd_color(const char* APanelName, const char* AControlName, pu32 AAlphaColor);
=s32 get_system_var_address(const char* ACompleteName, ps32 AAddress);
=s32 set_system_var_logging(const char* ACompleteName, const bool AIsLogging);
=s32 get_system_var_logging(const char* ACompleteName, bool* AIsLogging);
=s32 log_system_var_value(const char* ACompleteName);
=s32 get_main_window_handle(ps32 AHandle);
=s32 print_delta_time(const char* AInfo);
=s32 atomic_increment32(const ps32 AAddr, const s32 AValue, ps32 AResult);
=s32 atomic_increment64(const ps64 AAddr, const s64 AValue, ps64 AResult);
=s32 atomic_set_32(const ps32 AAddr, const s32 AValue);
=s32 atomic_set_64(const ps64 AAddr, const s64 AValue);
=s32 get_constant_double(const char* AName, double* AValue);
=s32 add_direct_mapping_can(const char* ADestinationVarName, const char* ASignalAddress, const TSymbolMappingDirection ADirection);
=s32 add_expression_mapping(const char* ADestinationVarName, const char* AExpression, const char* AArguments);
=s32 delete_symbol_mapping_item(const char* ADestinationVarName);
=s32 enable_symbol_mapping_item(const char* ADestinationVarName, const bool AEnable);
=s32 enable_symbol_mapping_engine(const bool AEnable);
=s32 delete_symbol_mapping_items(void);
=s32 save_symbol_mapping_settings(const char* AFileName);
=s32 load_symbol_mapping_settings(const char* AFileName);
=s32 add_direct_mapping_with_factor_offset_can(const char* ADestinationVarName, const char* ASignalAddress, const TSymbolMappingDirection ADirection, const double AFactor, const double AOffset);
=s32 debug_log(const char* AFile, const char* AFunc, const s32 ALine, const char* AStr, const TLogLevel ALevel);
=s32 wait_with_dialog(const char* ATitle, const char* AMessage, const bool* ApResult, const float* ApProgress100);
=s32 is_connected(void);
=s32 get_flexray_channel_count(const ps32 ACount);
=s32 set_flexray_channel_count(const s32 ACount);
=s32 db_get_can_database_count(ps32 ACount);
=s32 db_get_lin_database_count(ps32 ACount);
=s32 db_get_flexray_database_count(ps32 ACount);
=s32 db_get_can_database_properties_by_index(PDBProperties AValue);
=s32 db_get_lin_database_properties_by_index(PDBProperties AValue);
=s32 db_get_flexray_database_properties_by_index(PDBProperties AValue);
=s32 db_get_can_ecu_properties_by_index(PDBECUProperties AValue);
=s32 db_get_lin_ecu_properties_by_index(PDBECUProperties AValue);
=s32 db_get_flexray_ecu_properties_by_index(PDBECUProperties AValue);
=s32 db_get_can_frame_properties_by_index(PDBFrameProperties AValue);
=s32 db_get_lin_frame_properties_by_index(PDBFrameProperties AValue);
=s32 db_get_flexray_frame_properties_by_index(PDBFrameProperties AValue);
=s32 db_get_can_signal_properties_by_index(PDBSignalProperties AValue);
=s32 db_get_lin_signal_properties_by_index(PDBSignalProperties AValue);
=s32 db_get_flexray_signal_properties_by_index(PDBSignalProperties AValue);
=s32 db_get_can_database_properties_by_address(const char* AAddr, PDBProperties AValue);
=s32 db_get_lin_database_properties_by_address(const char* AAddr, PDBProperties AValue);
=s32 db_get_flexray_database_properties_by_address(const char* AAddr, PDBProperties AValue);
=s32 db_get_can_ecu_properties_by_address(const char* AAddr, PDBECUProperties AValue);
=s32 db_get_lin_ecu_properties_by_address(const char* AAddr, PDBECUProperties AValue);
=s32 db_get_flexray_ecu_properties_by_address(const char* AAddr, PDBECUProperties AValue);
=s32 db_get_can_frame_properties_by_address(const char* AAddr, PDBFrameProperties AValue);
=s32 db_get_lin_frame_properties_by_address(const char* AAddr, PDBFrameProperties AValue);
=s32 db_get_flexray_frame_properties_by_address(const char* AAddr, PDBFrameProperties AValue);
=s32 db_get_can_signal_properties_by_address(const char* AAddr, PDBSignalProperties AValue);
=s32 db_get_lin_signal_properties_by_address(const char* AAddr, PDBSignalProperties AValue);
=s32 db_get_flexray_signal_properties_by_address(const char* AAddr, PDBSignalProperties AValue);

[com]
=s32 transmit_can_async(const PCAN ACAN);
=s32 transmit_canfd_async(const PCANFD ACANFD);
=s32 transmit_lin_async(const PLIN ALIN);
=s32 transmit_can_sync(const PCAN ACAN, const s32 ATimeoutMS);
=s32 transmit_canfd_sync(const PCANFD ACANFD, const s32 ATimeoutMS);
=s32 transmit_lin_sync(const PLIN ALIN, const s32 ATimeoutMS);
=double get_can_signal_value(const PCANSignal ACANSignal, const pu8 AData);
=void set_can_signal_value(const PCANSignal ACANSignal, const pu8 AData, const double AValue);
=s32 enable_bus_statistics(const bool AEnable);
=s32 clear_bus_statistics(void);
=s32 get_bus_statistics(const TLIBApplicationChannelType ABusType, const s32 AIdxChn, const TLIBCANBusStatistics AIdxStat, pdouble AStat);
=s32 get_fps_can(const s32 AIdxChn, const s32 AIdentifier, ps32 AFPS);
=s32 get_fps_canfd(const s32 AIdxChn, const s32 AIdentifier, ps32 AFPS);
=s32 get_fps_lin(const s32 AIdxChn, const s32 AIdentifier, ps32 AFPS);
=s32 wait_can_message(const PCAN ATxCAN, const PCAN ARxCAN, const s32 ATimeoutMS);
=s32 wait_canfd_message(const PCANFD ATxCANFD, const PCANFD ARxCANFD, const s32 ATimeoutMS);
=s32 add_cyclic_message_can(const PCAN ACAN, const float APeriodMS);
=s32 add_cyclic_message_canfd(const PCANFD ACANFD, const float APeriodMS);
=s32 del_cyclic_message_can(const PCAN ACAN);
=s32 del_cyclic_message_canfd(const PCANFD ACANFD);
=s32 del_cyclic_messages(void);
=s32 add_precise_cyclic_message(const s32 AIdentifier, const u8 AChn, const u8 AIsExt, const float APeriodMS, const int ATimeoutMS);
=s32 delete_precise_cyclic_message)(const s32 AIdentifier, const u8 AChn, const u8 AIsExt, const int ATimeoutMS);
=s32 tslog_add_online_replay_config(const char* AFileName, s32* AIndex);
=s32 tslog_set_online_replay_config(const s32 AIndex, const char* AName, const char* AFileName, const bool AAutoStart, const bool AIsRepetitiveMode, const TLIBOnlineReplayTimingMode AStartTimingMode, const s32 AStartDelayTimeMs, const bool ASendTx, const bool ASendRx, const char* AMappings);
=s32 tslog_get_online_replay_count(s32* ACount);
=s32 tslog_get_online_replay_config(const s32 AIndex, char** AName, char** AFileName, bool* AAutoStart, bool* AIsRepetitiveMode, TLIBOnlineReplayTimingMode* AStartTimingMode, s32* AStartDelayTimeMs, bool* ASendTx, bool* ASendRx, char** AMappings);
=s32 tslog_del_online_replay_config(const s32 AIndex);
=s32 tslog_del_online_replay_configs(void);
=s32 tslog_start_online_replay(const s32 AIndex);
=s32 tslog_start_online_replays(void);
=s32 tslog_pause_online_replay(const s32 AIndex);
=s32 tslog_pause_online_replays(void);
=s32 tslog_stop_online_replay(const s32 AIndex);
=s32 tslog_stop_online_replays(void);
=s32 tslog_get_online_replay_status(const s32 AIndex, TLIBOnlineReplayStatus* AStatus, float* AProgressPercent100);
=s32 can_rbs_start(void);
=s32 can_rbs_stop(void);
=s32 can_rbs_is_running(bool* AIsRunning);
=s32 can_rbs_configure(const bool AAutoStart, const bool AAutoSendOnModification, const bool AActivateNodeSimulation, const TLIBRBSInitValueOptions AInitValueOptions);
=s32 can_rbs_activate_all_networks(const bool AEnable, const bool AIncludingChildren);
=s32 can_rbs_activate_network_by_name(const s32 AIdxChn, const bool AEnable, const char* ANetworkName, const bool AIncludingChildren);
=s32 can_rbs_activate_node_by_name(const s32 AIdxChn, const bool AEnable, const char* ANetworkName, const char* ANodeName, const bool AIncludingChildren);
=s32 can_rbs_activate_message_by_name(const s32 AIdxChn, const bool AEnable, const char* ANetworkName, const char* ANodeName, const char* AMsgName);
=s32 can_rbs_set_message_cycle_by_name(const s32 AIdxChn, const s32 AIntervalMs, const char* ANetworkName, const char* ANodeName, const char* AMsgName);
=s32 can_rbs_get_signal_value_by_element(const s32 AIdxChn, const char* ANetworkName, const char* ANodeName, const char* AMsgName, const char* ASignalName, double* AValue);
=s32 can_rbs_get_signal_value_by_address(const char* ASymbolAddress, double* AValue);
=s32 can_rbs_set_signal_value_by_element(const s32 AIdxChn, const char* ANetworkName, const char* ANodeName, const char* AMsgName, const char* ASignalName, const double AValue);
=s32 can_rbs_set_signal_value_by_address(const char* ASymbolAddress, const double AValue);
=s32 tslog_blf_write_start(const char* AFileName, s32* AHandle);
=s32 tslog_blf_write_start_w_timestamp(const char* AFileName, s32* AHandle, u16* AYear, u16* AMonth, u16* ADay, u16* AHour, u16* AMinute, u16* ASecond, u16* AMilliseconds);
=s32 tslog_blf_write_set_max_count(const s32 AHandle, const u32 ACount);
=s32 tslog_blf_write_can(const s32 AHandle, const PCAN ACAN);
=s32 tslog_blf_write_can_fd(const s32 AHandle, const PCANFD ACANFD);
=s32 tslog_blf_write_lin(const s32 AHandle, const PLIN ALIN);
=s32 tslog_blf_write_realtime_comment(const s32 AHandle, const s64 ATimeUs, const char* AComment);
=s32 tslog_blf_write_end(const s32 AHandle);
=s32 tslog_blf_read_start(const char* AFileName, s32* AHandle, s32* AObjCount);
=s32 tslog_blf_read_status(const s32 AHandle, s32* AObjReadCount);
=s32 tslog_blf_read_object(const s32 AHandle, s32* AProgressedCnt, TSupportedBLFObjType* AType, PCAN ACAN, PLIN ALIN, PCANFD ACANFD);
=s32 tslog_blf_read_object_w_comment(const s32 AHandle, s32* AProgressedCnt, TSupportedBLFObjType* AType, PCAN ACAN, PLIN ALIN, PCANFD ACANFD, Prealtime_comment_t AComment);
=s32 tslog_blf_read_end(const s32 AHandle);
=s32 tslog_blf_seek_object_time(const s32 AHandle, const double AProg100, s64* ATime, s32* AProgressedCnt);
=s32 tslog_blf_to_asc(const char* ABLFFileName, const char* AASCFileName, const TProgressCallback AProgressCallback);
=s32 tslog_asc_to_blf(const char* AASCFileName, const char* ABLFFileName, const TProgressCallback AProgressCallback);
=s32 ioip_create(const u16 APortTCP, const u16 APortUDP, const TOnIoIPData AOnTCPDataEvent, const TOnIoIPData AOnUDPEvent, s32* AHandle);
=s32 ioip_delete(const s32 AHandle);
=s32 ioip_enable_tcp_server(const s32 AHandle, const bool AEnable);
=s32 ioip_enable_udp_server(const s32 AHandle, const bool AEnable);
=s32 ioip_connect_tcp_server(const s32 AHandle, const char* AIpAddress, const u16 APort);
=s32 ioip_connect_udp_server(const s32 AHandle, const char* AIpAddress, const u16 APort);
=s32 ioip_disconnect_tcp_server(const s32 AHandle);
=s32 ioip_send_buffer_tcp(const s32 AHandle, const pu8 APointer, const s32 ASize);
=s32 ioip_send_buffer_udp(const s32 AHandle, const pu8 APointer, const s32 ASize);
=s32 ioip_receive_tcp_client_response(const s32 AHandle, const s32 ATimeoutMs, const pu8 ABufferToReadTo, ps32 AActualSize);
=s32 ioip_send_tcp_server_response(const s32 AHandle, const pu8 ABufferToWriteFrom, const s32 ASize);
=s32 ioip_send_udp_broadcast(const void* AObj, const s32 AHandle, const u16 APort, const pu8 ABufferToWriteFrom, const s32 ASize);
=s32 ioip_set_udp_server_buffer_size(const void* AObj, const s32 AHandle, const s32 ASize);
=s32 ioip_receive_udp_client_response(const void* AObj, const s32 AHandle, const s32 ATimeoutMs, const pu8 ABufferToReadTo, ps32 AActualSize);
=s32 ioip_send_udp_server_response(const void* AObj, const s32 AHandle, const pu8 ABufferToWriteFrom, const s32 ASize);
=s32 sgnsrv_register_can_signal_by_msg_identifier(const s32 AIdxChn, const s32 AMsgId, const char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_lin_signal_by_msg_identifier(const s32 AIdxChn, const s32 AMsgId, const char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_can_signal_by_msg_name(const s32 AIdxChn, const char* ANetworkName, const char* AMsgName, char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_lin_signal_by_msg_name(const s32 AIdxChn, const char* ANetworkName, const char* AMsgName, char* ASgnName, ps32 AClientId);
=s32 sgnsrv_get_can_signal_phy_value_latest(const s32 AIdxChn, const s32 AClientId, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_lin_signal_phy_value_latest(const s32 AIdxChn, const s32 AClientId, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_can_signal_phy_value_in_msg(const s32 AIdxChn, const s32 AClientId, const PCANFD AMsg, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_lin_signal_phy_value_in_msg(const s32 AIdxChn, const s32 AClientId, const PLIN AMsg, pdouble AValue, ps64 ATimeUs);
=s32 can_rbs_enable(const bool AEnable);
=s32 can_rbs_batch_set_start(void);
=s32 can_rbs_batch_set_end(void);
=s32 inject_can_message(const PCANFD ACANFD);
=s32 inject_lin_message(const PLIN ALIN);
=s32 can_rbs_batch_set_signal(const char* ASymbolAddress, const double AValue);
=s32 can_rbs_set_message_direction(const s32 AIdxChn, const bool AIsTx, const char* ANetworkName, const char* ANodeName, const char* AMsgName);
=s32 pdu_container_set_cycle_count(const s32 AIdxChn, const s32 AMsgId, const s32 ACount);
=s32 pdu_container_set_cycle_by_index(const s32 AIdxChn, const s32 AMsgId, const s32 AIdxCycle, const pchar ASignalGroupIdList);
=s32 pdu_container_get_cycle_count(const s32 AIdxChn, const s32 AMsgId, ps32 ACount);
=s32 pdu_container_get_cycle_by_index(const s32 AIdxChn, const s32 AMsgId, const s32 AIdxCycle, char** ASignalGroupIdList);
=s32 pdu_container_refresh(const s32 AIdxChn, const s32 AMsgId);
=s32 can_rbs_fault_inject_clear(void);
=s32 can_rbs_fault_inject_message_lost(const bool AEnable, const s32 AIdxChn, const s32 AIdentifier);
=s32 can_rbs_fault_inject_signal_alter(const bool AEnable, const char* ASymbolAddress, const double AAlterValue);
=s32 j1939_make_id(const s32 APGN, const u8 ASource, const u8 ADestination, const u8 APriority, ps32 AIdentifier);
=s32 j1939_extract_id(const s32 AIdentifier, ps32 APGN, pu8 ASource, pu8 ADestination, pu8 APriority);
=s32 j1939_get_pgn(const s32 AIdentifier, ps32 APGN);
=s32 j1939_get_source(const s32 AIdentifier, pu8 ASource);
=s32 j1939_get_destination(const s32 AIdentifier, pu8 ADestination);
=s32 j1939_get_priority(const s32 AIdentifier, pu8 APriority);
=s32 j1939_get_r(const s32 AIdentifier, pu8 AR);
=s32 j1939_get_dp(const s32 AIdentifier, pu8 ADP);
=s32 j1939_get_edp(const s32 AIdentifier, pu8 AEDP);
=s32 j1939_set_pgn(const ps32 AIdentifier, const s32 APGN);
=s32 j1939_set_source(const ps32 AIdentifier, const u8 ASource);
=s32 j1939_set_destination(const ps32 AIdentifier, const u8 ADestination);
=s32 j1939_set_priority(const ps32 AIdentifier, const u8 APriority);
=s32 j1939_set_r(const ps32 AIdentifier, const u8 AR);
=s32 j1939_set_dp(const ps32 AIdentifier, const u8 ADP);
=s32 j1939_set_edp(const ps32 AIdentifier, const u8 AEDP);
=s32 j1939_get_last_pdu(const u8 AIdxChn, const s32 AIdentifier, const bool AIsTx, const s32 APDUBufferSize, pu8 APDUBuffer, ps32 APDUActualSize, ps64 ATimeUs);
=s32 j1939_get_last_pdu_as_string(const u8 AIdxChn, const s32 AIdentifier, const bool AIsTx, char** APDUData, ps32 APDUActualSize, ps64 ATimeUs);
=s32 j1939_transmit_pdu_async(const u8 AIdxChn, const s32 APGN, const u8 APriority, const u8 ASource, const u8 ADestination, const pu8 APDUData, const s32 APDUSize);
=s32 j1939_transmit_pdu_sync(const u8 AIdxChn, const s32 APGN, const u8 APriority, const u8 ASource, const u8 ADestination, const pu8 APDUData, const s32 APDUSize, const s32 ATimeoutMs);
=s32 j1939_transmit_pdu_as_string_async(const u8 AIdxChn, const s32 APGN, const u8 APriority, const u8 ASource, const u8 ADestination, const char* APDUData);
=s32 j1939_transmit_pdu_as_string_sync(const u8 AIdxChn, const s32 APGN, const u8 APriority, const u8 ASource, const u8 ADestination, const char* APDUData, const s32 ATimeoutMs);
=s32 can_rbs_set_normal_signal(const char* ASymbolAddress);
=s32 can_rbs_set_rc_signal(const char* ASymbolAddress);
=s32 can_rbs_set_crc_signal(const char* ASymbolAddress, const char* AAlgorithmName, const s32 AIdxByteStart, const s32 AByteCount);
=s32 can_rbs_set_rc_signal_with_limit(const char* ASymbolAddress, const s32 ALowerLimit, const s32 AUpperLimit);
=s32 get_can_signal_definition_verbose(const s32 AIdxChn, const char* ANetworkName, const char* AMsgName, const char* ASignalName, ps32 AMsgIdentifier, PCANSignal ASignalDef);
=s32 get_can_signal_definition(const char* ASignalAddress, ps32 AMsgIdentifier, PCANSignal ASignalDef);
=s32 transmit_flexray_async(const PFlexRay AFlexRay);
=s32 transmit_flexray_sync(const PFlexRay AFlexRay, const s32 ATimeoutMS);
=double get_flexray_signal_value(const PFlexRaySignal AFlexRaySignal, const pu8 AData);
=void set_flexray_signal_value(const PFlexRaySignal AFlexRaySignal, const pu8 AData, const double AValue);
=s32 inject_flexray_frame(const PFlexRay AFlexRay);
=s32 get_flexray_signal_definition(const char* ASignalAddress, PFlexRaySignal ASignalDef);
=s32 tslog_blf_write_flexray(const s32 AHandle, const PFlexRay AFlexRay);
=s32 sgnsrv_register_flexray_signal_by_frame(const s32 AIdxChn, const u8 AChnMask, const u8 ACycleNumber, const s32 ASlotId, const char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_flexray_signal_by_frame_name(const s32 AIdxChn, const char* ANetworkName, const char* AFrameName, const char* ASgnName, ps32 AClientId);
=s32 sgnsrv_get_flexray_signal_phy_value_latest(const s32 AIdxChn, const s32 AClientId, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_flexray_signal_phy_value_in_frame(const s32 AIdxChn, const s32 AClientId, const PFlexRay AFrame, pdouble AValue, ps64 ATimeUs);
=s32 flexray_rbs_start(void);
=s32 flexray_rbs_stop(void);
=s32 flexray_rbs_is_running(bool* AIsRunning);
=s32 flexray_rbs_configure(const bool AAutoStart, const bool AAutoSendOnModification, const bool AActivateECUSimulation, const TLIBRBSInitValueOptions AInitValueOptions);
=s32 flexray_rbs_enable(const bool AEnable);
=s32 flexray_rbs_activate_all_clusters(const bool AEnable, const bool AIncludingChildren);
=s32 flexray_rbs_activate_cluster_by_name(const s32 AIdxChn, const bool AEnable, const char* AClusterName, const bool AIncludingChildren);
=s32 flexray_rbs_activate_ecu_by_name(const s32 AIdxChn, const bool AEnable, const char* AClusterName, const char* AECUName, const bool AIncludingChildren);
=s32 flexray_rbs_activate_frame_by_name(const s32 AIdxChn, const bool AEnable, const char* AClusterName, const char* AECUName, const char* AFrameName);
=s32 flexray_rbs_get_signal_value_by_element(const s32 AIdxChn, const char* AClusterName, const char* AECUName, const char* AFrameName, const char* ASignalName, double* AValue);
=s32 flexray_rbs_get_signal_value_by_address(const char* ASymbolAddress, double* AValue);
=s32 flexray_rbs_set_signal_value_by_element(const s32 AIdxChn, const char* AClusterName, const char* AECUName, const char* AFrameName, const char* ASignalName, const double AValue);
=s32 flexray_rbs_set_signal_value_by_address(const char* ASymbolAddress, const double AValue);
=s32 flexray_rbs_batch_set_start(void);
=s32 flexray_rbs_batch_set_end(void);
=s32 flexray_rbs_batch_set_signal(const char* ASymbolAddress, const double AValue);
=s32 flexray_rbs_set_frame_direction(const s32 AIdxChn, const bool AIsTx, const char* AClusterName, const char* AECUName, const char* AFrameName);
=s32 flexray_rbs_set_normal_signal(const char* ASymbolAddress);
=s32 flexray_rbs_set_rc_signal(const char* ASymbolAddress);
=s32 flexray_rbs_set_rc_signal_with_limit(const char* ASymbolAddress, const s32 ALowerLimit, const s32 AUpperLimit);
=s32 flexray_rbs_set_crc_signal(const char* ASymbolAddress, const char* AAlgorithmName, const s32 AIdxByteStart, const s32 AByteCount);

[test]
=void set_verdict_ok(const char* AMsg);
=void set_verdict_nok(const char* AMsg);
=void set_verdict_cok(const char* AMsg);
=void log_info(const char* AMsg, const TLogLevel ALevel);
=void write_result_string(const char* AName, const char* AValue, const TLogLevel ALevel);
=void write_result_value(const char* AName, const double AValue, const TLogLevel ALevel);
=void check_error_begin(void);
=s32 check_error_end(const ps32 AErrorCount);
=s32 write_result_image(const char* AName, const char* AImageFileFullPath);
=s32 retrieve_current_result_folder(char** AFolder);
=s32 check_test_terminate(void);
=s32 check_verdict(const char* AName, const double AValue, const double AMin, const double AMax);
=s32 signal_checker_clear(void);
=s32 signal_checker_add_check_with_time(const TSignalType ASgnType, const TSignalCheckKind ACheckKind, const char* ASgnName, const double ASgnMin, const double ASgnMax, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_check_with_trigger(const TSignalType ASgnType, const TSignalCheckKind ACheckKind, const char* ASgnName, const double ASgnMin, const double ASgnMax, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_statistics_with_time(const TSignalType ASgnType, const TSignalStatisticsKind AStatisticsKind, const char* ASgnName, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_statistics_with_trigger(const TSignalType ASgnType, const TSignalStatisticsKind AStatisticsKind, const char* ASgnName, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_get_result(const s32 ACheckId, bool* APass, pdouble AResult, char** AResultRepr);
=s32 signal_checker_enable(const s32 ACheckId, const bool AEnable);
=s32 debug_log_info(const char* AFile, const char* AFunc, const s32 ALine, const char* AStr, const TLogLevel ALevel);
=s32 signal_checker_add_rising_edge_with_time(const TSignalType ASgnType, const char* ASgnName, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_rising_edge_with_trigger(const TSignalType ASgnType, const char* ASgnName, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_falling_edge_with_time(const TSignalType ASgnType, const char* ASgnName, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_falling_edge_with_trigger(const TSignalType ASgnType, const char* ASgnName, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_monotony_rising_with_time(const TSignalType ASgnType, const char* ASgnName, const s32 ASampleIntervalMs, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_monotony_rising_with_trigger(const TSignalType ASgnType, const char* ASgnName, const s32 ASampleIntervalMs, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_monotony_falling_with_time(const TSignalType ASgnType, const char* ASgnName, const s32 ASampleIntervalMs, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_monotony_falling_with_trigger(const TSignalType ASgnType, const char* ASgnName, const s32 ASampleIntervalMs, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_follow_with_time(const TSignalType ASgnType, const TSignalType AFollowSignalType, const char* ASgnName, const char* AFollowSgnName, const double AErrorRange, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_follow_with_trigger(const TSignalType ASgnType, const TSignalType AFollowSignalType, const char* ASgnName, const char* AFollowSgnName, const double AErrorRange, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_jump_with_time(const TSignalType ASgnType, const char* ASgnName, const bool AIgnoreFrom, const double AFrom, const double ATo, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_jump_with_trigger(const TSignalType ASgnType, const char* ASgnName, const bool AIgnoreFrom, const double AFrom, const double ATo, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_add_unchange_with_time(const TSignalType ASgnType, const char* ASgnName, const double ATimeStartS, const double ATimeEndS, ps32 ACheckId);
=s32 signal_checker_add_unchange_with_trigger(const TSignalType ASgnType, const char* ASgnName, const TSignalType ATriggerType, const char* ATriggerName, const double ATriggerMin, const double ATriggerMax, ps32 ACheckId);
=s32 signal_checker_check_statistics(const s32 ACheckId, const double AMin, const double AMax, bool* APass, pdouble AResult, char** AResultRepr);
